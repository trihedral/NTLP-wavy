c ----------------------------------------------------------------------
      module pars
c ----------------------------------------------------------------------
      integer :: iti,itmax,imean,ihst,itape
      integer :: itstr,it_his,it_viz,iviz

      integer :: ismlt,ifree,iradup,
     + iupwnd,iskew,ibuoy,ifilt,
     + itcut,isubs,ibrcl,i_move_step,
     + iocean,method,idebug,iz_space,
     + ivis0,ifix_dt,new_vis,iflat,
     + i3d_surf,i_pm,lpbc,k_stab,
     + no_pgrad,ispray,iDNS,
     + ifields

c
c -------- j_recl = record length in "bytes" for history file
c          k8     = kind parameter for integers in mpi_io routines
c
         integer, parameter :: j_recl=4, k8=8
c
c -------- SGI diamond
c
c        integer, parameter :: j_recl=1, k8=8
c
c -------- number of vars, size of problem in (x,y,z), max size, max processors
c
         integer, parameter :: nscl = 2, nvar = (4+nscl)
         integer, parameter :: nxg1  = 128, nyg1  = 128, nzg1  = 128
         integer, parameter :: maxnx = 128, maxny = 128, maxnz = 128

      !Boundary conditions and other parameters
      real :: Uo,Ttop(nscl),Tbot(nscl),qstar(nscl),tsfcc(nscl)
      real :: ugcont,vgcont,fcor,t00,grav
      real :: zi, zl, xl, yl, zw1, zo
      integer :: isfc(nscl)

c
c ------------ leave following definitions as is
c
         integer, parameter :: maxnz1 = maxnz + 1,
     +                         maxnz2 = maxnz + 2,
     +                         maxnx2 = maxnx + 2,
     +                         maxny2 = maxny + 2
c ----------------------------------------------------------------------
      integer ::    nnx, nny, nnz, nxy, ncx, nnxp1, nnyp1, ncy,
     +              nnxp2, nnyp2, nnzp1, ivis, nnzm1, isize, krec,
     +              izs, ize, ixs, ixe, jxs, jxe, kxs, kxe,
     +              mxs, mxe, iss, ise, iys, iye, jys, jye, i2xs, i2xe,
     +              nnx_c, nny_c, nnz_c, imesh
c ----------------------------------------------------------------------
      character case*3
c ----------------------------------------------------------------------
      integer  ::   nvel, npre, nhis1, nprt,
     +              nhisp, nvelc,
     +              nviz_z, nviz_y,
     +              nviz_x, nviz_s, ngrd, nbndy,
     +              kfile, jfile, ibcl, ibcu,
     +              igrdr, imach, itn, it_his_nxt, it_viz_nxt
      logical ::    mnout, micut, mtape, mhis, msave,mtrans,
     +              l_root, l_debug, msave_v, mviz
c ----------------------------------------------------------------------
      real    ::    windm,u1xy,v1xy,t1xy(nscl),
     +              t10xy(nscl),au13m,au23m,aut3m(nscl),tsfcm(nscl),
     +              thstar(nscl), eavg(maxnz), tr_tau(0:maxnz),
     +              pxym(0:maxnz1), zi_min, a_exp_grd, a_exp_grd2,
     +              a_decay, p_surf
      integer ::    izi, iz_min, i_match
      real, allocatable ::
     +              wind(:,:), tau13m(:,:), tau23m(:,:), 
     +              taut3m(:,:,:), t_grnd(:,:,:)
c ----------------------------------------------------------------------
      real ::       u_mn(0:maxnz1), v_mn(0:maxnz1),
     +              w_mn(0:maxnz1), t_mn(0:maxnz1,nscl)
c ----------------------------------------------------------------------
      real ::       dzw(0:maxnz2), dzu(0:maxnz2),
     +              dzw_i(0:maxnz2), dzu_i(0:maxnz2),
     +              weit(0:maxnz1), weitm(0:maxnz1)
c ----------------------------------------------------------------------
      real ::       t_factor, t_ref, c_rate, t_surf_i
c ----------------------------------------------------------------------
      real ::       dsl_z(0:maxnz1),
     +              xksurf, viscon, vise, almin_c, stabmin,
     +              ck, ceps, csmag, stab_c, vis_mean(0:maxnz), pow3
      integer ::    nmatch
c ----------------------------------------------------------------------
      real ::       zetas(3), gama(3), etas(4), 
     +              umax,vmax,wmax, wabs, emax, vismax,
     +              cfl, tzero,
     +              ucfl, vcfl, wcfl,
     +              t_stage, t_stage2, t_stage3,
     +              dtalp
c ----------------------------------------------------------------------
      real ::       dpdx_con, dpdx_con_z
c ----------------------------------------------------------------------
      integer, parameter :: ip_accel=100
      integer ::    ip_max, ip_ramp
      real ::       ptol, p_iter, p_err, accel_min, accel_max, 
     +              accel(ip_accel),
     +              avg_j(0:maxnz1), avg_j_i(0:maxnz1)
c ----------------------------------------------------------------------
      real, allocatable ::
     +              t11bc(:,:), t12bc(:,:), t13bc(:,:), t22bc(:,:),
     +              t23bc(:,:), t33bc(:,:), ustar(:,:), t1tbc(:,:,:),
     +              t2tbc(:,:,:), t3tbc(:,:,:), amol(:,:)
c ----------------------------------------------------------------------
      character*80  path_res, path_sav, path_his, path_prt,
     +              path_sav_v, path_sav_c, path_part,
     +              path_sav_p, path_sav_h, path_sav_part,
     +              path_sav_hp, path_sav_g, path_bndy,path_ran
      character case_inp*3
      character*80 path_viz_xy, path_viz_xz, path_viz_yz, path_stuf,
     +             path_seed
c ----------------------------------------------------------------------
      integer ::    myid, numprocs, i_root,
     +              ziloc, myid_newvis, ncpu_s, ncpu_z, maxp
      integer, allocatable, dimension(:) :: 
     +              ix_s, ix_e, jx_s, jx_e,
     +              kx_s, kx_e, mx_s, mx_e,
     +              iy_s, iy_e, jy_s, jy_e,
     +              is_s, is_e, iz_s, iz_e,
     +              i2x_s, i2x_e
      end module pars
c ----------------------------------------------------------------------
      module particles
      integer :: rproc,trproc,tproc,tlproc,lproc,blproc,bproc,brproc
      integer :: pr_r,pl_r,pt_r,pb_r,ptr_r,ptl_r,pbl_r,pbr_r
      integer :: pr_s,pl_s,pt_s,pb_s,ptr_s,ptl_s,pbl_s,pbr_s
      real :: ymin,ymax,zmin,zmax,xmax,xmin
      real, allocatable :: uext(:,:,:), vext(:,:,:), wext(:,:,:)
      real, allocatable :: u_t(:,:,:), v_t(:,:,:), w_t(:,:,:)
      real, allocatable :: Text(:,:,:),T_t(:,:,:)
      real, allocatable :: partTsrc(:,:,:),partTsrc_t(:,:,:)
      real, allocatable :: partcount_t(:,:,:),partsrc_t(:,:,:,:)
      real, allocatable :: vpsum_t(:,:,:,:),vpsqrsum_t(:,:,:,:)
      real, allocatable :: upwp_t(:,:,:),upwp(:,:,:)
      real, allocatable :: partcount(:,:,:),partsrc(:,:,:,:)
      real, allocatable :: vpsum(:,:,:,:),vpsqrsum(:,:,:,:)
      real, allocatable :: Tpsum(:,:,:),Tpsum_t(:,:,:)
      real, allocatable :: Tpsqrsum(:,:,:),Tpsqrsum_t(:,:,:)
      real, allocatable :: wpTpsum(:,:,:),wpTpsum_t(:,:,:)
      integer :: particletype,pad_diff
      integer :: numpart,tnumpart,ngidx
      integer :: num_reintro,tot_reintro,his_reintro
      integer :: iseed
      integer,parameter :: rbins=4
      real :: residual(rbins)
      real :: Rep_avg,part_grav,Vpmax
      real :: vp_init(3),Tp_init

      real :: radius,rhop,muf,taup_i
      real :: CpaCpp,Pra
      
      !REMEMBER: IF ADDING ANYTHING, MUST UPDATE MPI DATATYPE!
      type :: particle
      integer :: pidx,procidx
      real :: vp(3),xp(3),xip(3),uf(3),xrhs(3),vrhs(3),Tp,Tprhs,Tf
      type(particle), pointer :: prev,next
      end type particle

      type(particle), pointer :: part,first_particle
      end module particles
c     ---------------------------------------------------------------------
      module wavy_pars
c
      integer, parameter ::
     +           i_ranp = 0
c
      real :: u10, angle, wind_x, wind_y, dkx, dky
c
c --------- data arrays
c
      real, allocatable ::
     +      omega(:,:), eta_wrk(:,:),
     +      etax(:,:), etay(:,:), eta0(:,:,:),
     +      s_wrk(:,:,:), v_wrk(:,:,:)
      end module wavy_pars
c ----------------------------------------------------------------------
      module tank_pars
c
      integer, parameter ::
     +           nx_tank = 2000
c
      real :: wave_l, c_speed
c
c --------- data arrays
c
      real, allocatable ::
     +      z_tank(:), u_tank(:), w_tank(:),
     +      z_tank_f(:), u_tank_f(:), w_tank_f(:),
     +      z_tank_i(:), u_tank_i(:), w_tank_i(:),
     +      hdot_i(:), hx_i(:)
      end module tank_pars
c ----------------------------------------------------------------------
      module fields
        real, allocatable :: 
     +      u(:,:,:), v(:,:,:), w(:,:,:), t(:,:,:,:), e(:,:,:), 
     +      r1(:,:,:), r2(:,:,:), r3(:,:,:), r4(:,:,:,:), r5(:,:,:),
     +      uf(:,:,:), vf(:,:,:), wf(:,:,:), 
     +      ufi(:,:,:), vfi(:,:,:), wfi(:,:,:), rj(:,:,:)
        real, allocatable :: 
     +      ux(:,:,:), uy(:,:,:), vx(:,:,:), vy(:,:,:), 
     +      wx(:,:,:), wy(:,:,:),
     +      p(:,:,:), ptop(:,:,:), p_old(:,:,:), 
     +      vis_m(:,:,:), vis_s(:,:,:) 
        real, allocatable :: 
     +      ubc(:,:,:), vbc(:,:,:), wbc(:,:,:), tbc(:,:,:,:), 
     +      ebc(:,:,:), pbc(:,:,:), pbc2(:,:,:),
     +      ufbc(:,:,:), vfbc(:,:,:), wfbc(:,:,:)
        real, allocatable ::
     +      xgrid(:), ygrid(:), zgrid_w(:,:,:,:), zgrid_u(:,:,:),
     +      gm(:,:,:,:), gm2(:,:,:,:), gm3(:,:,:,:), gms(:,:,:), 
     +      bndy(:,:), hdot(:,:), 
     +      w_orbit(:,:), u_orbit(:,:), v_orbit(:,:),
     +      bndy_t(:,:,:), hdot_t(:,:,:), 
     +      z1b(:,:), z1b_2(:,:), z1b_3(:,:)
      end module fields
c ----------------------------------------------------------------------
      module fftwk
        real, allocatable :: trigx(:,:), trigc(:), trigcx(:)
      end module fftwk
c ----------------------------------------------------------------------
      module con_data
c ----------------------------------------------------------------------
        use pars, only : nscl
        type con_d
        sequence
        real ::  vk, vkin, vk74, vk74in, 
     +           gcp, fcor_h, pi2,
     +           batagk, batag, 
     +           cdbtm, dtdzf(nscl), dtjump, ugal, divgls,
     +           z1, utausv, dx, dy, dz, 
     +           dt, dt1, dt_new,
     +           fnxy, dzdz, dsl, c23, dtgama, dtzeta, xkmax,
     +           time, t_zero, zody, zody74, 
     +           utau, wtsfc(nscl),
     +           uusfc, uvsfc, uwsfc, vvsfc, vwsfc, wwsfc, amonin,
     +           zol, hol, smal_e, sml_eg,drg_x,drg_y
        end type con_d
        type(con_d), target :: c_c
        real, pointer ::
     +           vk, vkin, vk74, vk74in, 
     +           gcp, fcor_h, pi2,
     +           batagk, batag,
     +           cdbtm, dtdzf(:), dtjump, ugal, divgls,
     +           z1, utausv, dx, dy, dz, 
     +           dt, dt1, dt_new,
     +           fnxy, dzdz, dsl, c23, dtgama, dtzeta, xkmax, 
     +           time, t_zero, zody, zody74, 
     +           utau, wtsfc(:), 
     +           uusfc, uvsfc, uwsfc, vvsfc, vwsfc, wwsfc, amonin,
     +           zol, hol, smal_e, sml_eg,drg_x,drg_y
      contains
         subroutine fill_cc
c
c --------------- pointer associations for constant variables
c
             vk     => c_c%vk 
             vkin   => c_c%vkin
             vk74   => c_c%vk74
             vk74in => c_c%vk74in
             gcp    => c_c%gcp
             fcor_h => c_c%fcor_h
             pi2    => c_c%pi2
             batagk => c_c%batagk
             batag  => c_c%batag
             cdbtm  => c_c%cdbtm
             dtdzf  => c_c%dtdzf
             dtjump => c_c%dtjump
             ugal   => c_c%ugal
             divgls => c_c%divgls
             z1     => c_c%z1
             utausv => c_c%utausv
             dx     => c_c%dx
             dy     => c_c%dy
             dz     => c_c%dz
             dt     => c_c%dt
             dt1    => c_c%dt1
             dt_new => c_c%dt_new
             fnxy   => c_c%fnxy
             dzdz   => c_c%dzdz
             dsl    => c_c%dsl
             c23    => c_c%c23
             dtgama => c_c%dtgama
             dtzeta => c_c%dtzeta
             xkmax  => c_c%xkmax
             time   => c_c%time
             t_zero => c_c%t_zero
             zody   => c_c%zody
             zody74 => c_c%zody74
             utau   => c_c%utau
             wtsfc  => c_c%wtsfc
             uusfc  => c_c%uusfc
             uvsfc  => c_c%uvsfc
             uwsfc  => c_c%uwsfc
             vvsfc  => c_c%vvsfc
             vwsfc  => c_c%vwsfc
             wwsfc  => c_c%wwsfc
             amonin => c_c%amonin
             zol    => c_c%zol
             hol    => c_c%hol
             smal_e => c_c%smal_e
             sml_eg => c_c%sml_eg
             drg_x  => c_c%drg_x 
             drg_y  => c_c%drg_y 
         return
         end subroutine fill_cc
      end module con_data
c ----------------------------------------------------------------------
      module con_stats
        use pars
        type con_s
        sequence
        real ::  wwsb(maxnz),engz(0:maxnz1),
     +           engsbz(0:maxnz1),
     +           englez(maxnz),uxym(0:maxnz1),
     +           vxym(0:maxnz1),wxym(0:maxnz1), pm(0:maxnz1),
     +           txym(0:maxnz1,nscl),divz(0:maxnz1),
     +           utle(maxnz,nscl), utsb(maxnz,nscl),
     +           vtle(maxnz,nscl), vtsb(maxnz,nscl),
     +           wtle(maxnz,nscl), wtsb(maxnz,nscl),
     +           wctle(maxnz,nscl), wt_tot(maxnz,nscl),
     +           z(0:maxnz1),zz(0:maxnz1),
     +           shrz(maxnz),buyz(maxnz),
     +           triz(maxnz),
     +           uwsb(maxnz),vwsb(maxnz),
     +           uwle(maxnz),vwle(maxnz),wwle(maxnz),
     +           uwcle(maxnz),vwcle(maxnz),
     +           uw_tot(maxnz),vw_tot(maxnz),
     +           drg_z_x(maxnz),drg_z_y(maxnz),
     +           drg_zs_x(maxnz),drg_zs_y(maxnz),
     +           wcube(maxnz), wfour(maxnz),
     +           tcube(maxnz,nscl),
     +           ups(maxnz), vps(maxnz),
     +           wps(maxnz), tps(maxnz,nscl),
     +           t_rprod(maxnz), t_wq(maxnz),
     +           t_wp(maxnz), t_tau(maxnz),
     +           t_tran(maxnz), t_buoy(maxnz),
     +           t_diss(maxnz), t_sprod(maxnz),
     +           zconc(maxnz),
     +           vp1mean(maxnz),vp2mean(maxnz),vp3mean(maxnz),
     +           vp1msqr(maxnz),vp2msqr(maxnz),vp3msqr(maxnz),
     +           upwpm(maxnz),
     +           Tpmean(maxnz),Tpmsqr(maxnz),wpTpm(maxnz)
        real ::  xkn(maxnx),ykn(maxny),
     +           xk(maxnx),yk(maxny),
     +           xkk(maxnx),ykk(maxny),
     +           xks(maxnx2,maxny),wavexy(maxnx2,maxny)
        real ::  ug(maxnz),vg(maxnz),
     +           wls(maxnz),uls(maxnx)
        real ::  udrift,vdrift,
     +           stokesw,stokesa,
     +           stokess,stokes(maxnz1)
        real ::  dtg, dslg, dzg
        real ::  dfac(maxnz)
        end type con_s
        type(con_s), target :: c_s
        real, pointer ::
     +           wwsb(:), engz(:), engsbz(:),
     +           englez(:), uxym(:), vxym(:), wxym(:), pm(:),
     +           txym(:,:), divz(:), utle(:,:), utsb(:,:),
     +           vtle(:,:), vtsb(:,:), wtle(:,:), wtsb(:,:),
     +           wctle(:,:), wt_tot(:,:), z(:), zz(:), shrz(:), buyz(:),
     +           triz(:), uwsb(:), vwsb(:), uwle(:), vwle(:), wwle(:), 
     +           uwcle(:), vwcle(:),
     +           uw_tot(:), vw_tot(:), drg_z_x(:), drg_z_y(:),
     +           drg_zs_x(:), drg_zs_y(:),
     +           wcube(:), wfour(:),
     +           tcube(:,:), ups(:), vps(:),
     +           wps(:), tps(:,:), t_rprod(:), t_wq(:),
     +           t_wp(:), t_tau(:), t_tran(:), t_buoy(:),
     +           t_diss(:), t_sprod(:),
     +           zconc(:),
     +           vp1mean(:),vp2mean(:),vp3mean(:),
     +           vp1msqr(:),vp2msqr(:),vp3msqr(:),
     +           upwpm(:),
     +           Tpmean(:),Tpmsqr(:),wpTpm(:)
        real, pointer ::  
     +           xkn(:), ykn(:), xk(:), yk(:), xkk(:), ykk(:),
     +           xks(:,:), wavexy(:,:)
        real, pointer ::  
     +           ug(:), vg(:), wls(:), uls(:)
        real, pointer ::  
     +           udrift, vdrift, stokesw, stokesa,
     +           stokess, stokes(:)
        real, pointer ::  
     +           dtg, dslg, dzg
        real, pointer ::  
     +           dfac(:)
      contains
         subroutine fill_cs
c
c -------------- pointer association for stat arrays and get size
c                of stat arrays isize for history files
c
             isize = 0 
             wwsb     => c_s%wwsb      ; isize = isize + size(wwsb)
             engz     => c_s%engz      ; isize = isize + size(engz)
             engsbz   => c_s%engsbz    ; isize = isize + size(engsbz)
             englez   => c_s%englez    ; isize = isize + size(englez)
             uxym     => c_s%uxym      ; isize = isize + size(uxym)
             vxym     => c_s%vxym      ; isize = isize + size(vxym)
             wxym     => c_s%wxym      ; isize = isize + size(wxym)
             pm       => c_s%pm        ; isize = isize + size(pm)
             txym     => c_s%txym      ; isize = isize + size(txym)
             divz     => c_s%divz      ; isize = isize + size(divz)
             utle     => c_s%utle      ; isize = isize + size(utle)
             utsb     => c_s%utsb      ; isize = isize + size(utsb)
             vtle     => c_s%vtle      ; isize = isize + size(vtle)
             vtsb     => c_s%vtsb      ; isize = isize + size(vtsb)
             wtle     => c_s%wtle      ; isize = isize + size(wtle)
             wctle    => c_s%wctle     ; isize = isize + size(wctle)
             wtsb     => c_s%wtsb      ; isize = isize + size(wtsb)
             wt_tot   => c_s%wt_tot    ; isize = isize + size(wt_tot)
             z        => c_s%z         ; isize = isize + size(z)
             zz       => c_s%zz        ; isize = isize + size(zz)
             shrz     => c_s%shrz      ; isize = isize + size(shrz)
             buyz     => c_s%buyz      ; isize = isize + size(buyz)
             triz     => c_s%triz      ; isize = isize + size(triz)
             uwsb     => c_s%uwsb      ; isize = isize + size(uwsb)
             vwsb     => c_s%vwsb      ; isize = isize + size(vwsb)
             uwle     => c_s%uwle      ; isize = isize + size(uwle)
             vwle     => c_s%vwle      ; isize = isize + size(vwle)
             wwle     => c_s%wwle      ; isize = isize + size(wwle)
             uwcle    => c_s%uwcle     ; isize = isize + size(uwcle)
             vwcle    => c_s%vwcle     ; isize = isize + size(vwcle)
             uw_tot   => c_s%uw_tot    ; isize = isize + size(uw_tot)
             vw_tot   => c_s%vw_tot    ; isize = isize + size(vw_tot)
             drg_z_x  => c_s%drg_z_x   ; isize = isize + size(drg_z_x)
             drg_z_y  => c_s%drg_z_y   ; isize = isize + size(drg_z_y)
             drg_zs_x => c_s%drg_zs_x  ; isize = isize + size(drg_zs_x)
             drg_zs_y => c_s%drg_zs_y  ; isize = isize + size(drg_zs_y)
             wcube    => c_s%wcube     ; isize = isize + size(wcube)
             wfour    => c_s%wfour     ; isize = isize + size(wfour)
             tcube    => c_s%tcube     ; isize = isize + size(tcube)
             ups      => c_s%ups       ; isize = isize + size(ups)
             vps      => c_s%vps       ; isize = isize + size(vps)
             wps      => c_s%wps       ; isize = isize + size(wps)
             tps      => c_s%tps       ; isize = isize + size(tps)
             t_rprod  => c_s%t_rprod   ; isize = isize + size(t_rprod)
             t_wq     => c_s%t_wq      ; isize = isize + size(t_wq)
             t_wp     => c_s%t_wp      ; isize = isize + size(t_wp)
             t_tau    => c_s%t_tau     ; isize = isize + size(t_tau)
             t_tran   => c_s%t_tran    ; isize = isize + size(t_tran)
             t_buoy   => c_s%t_buoy    ; isize = isize + size(t_buoy)
             t_diss   => c_s%t_diss    ; isize = isize + size(t_diss)
             t_sprod  => c_s%t_sprod   ; isize = isize + size(t_sprod)
             zconc   => c_s%zconc    ; isize = isize + size(zconc)
             vp1mean  => c_s%vp1mean ; isize = isize + size(vp1mean)
             vp2mean  => c_s%vp2mean ; isize = isize + size(vp2mean)
             vp3mean  => c_s%vp3mean ; isize = isize + size(vp3mean)
             vp1msqr  => c_s%vp1msqr ; isize = isize + size(vp1msqr)
             vp2msqr  => c_s%vp2msqr ; isize = isize + size(vp2msqr)
             vp3msqr  => c_s%vp3msqr ; isize = isize + size(vp3msqr)
             upwpm   => c_s%upwpm    ; isize = isize + size(upwpm)
             Tpmean  => c_s%Tpmean   ; isize = isize + size(Tpmean)
             Tpmsqr  => c_s%Tpmsqr   ; isize = isize + size(Tpmsqr)
             wpTpm   => c_s%wpTpm    ; isize = isize + size(wpTpm)
             xkn      => c_s%xkn
             ykn      => c_s%ykn
             xk       => c_s%xk
             yk       => c_s%yk
             xkk      => c_s%xkk
             ykk      => c_s%ykk
             xks      => c_s%xks 
             wavexy   => c_s%wavexy
             ug       => c_s%ug
             vg       => c_s%vg
             wls      => c_s%wls
             uls      => c_s%uls
             udrift   => c_s%udrift
             vdrift   => c_s%vdrift
             stokesw  => c_s%stokesw
             stokesa  => c_s%stokesa
             stokess  => c_s%stokess
             stokes   => c_s%stokes
             dtg      => c_s%dtg
             dslg     => c_s%dslg 
             dzg      => c_s%dzg
             dfac     => c_s%dfac
         return
         end subroutine fill_cs
      end module con_stats
c ----------------------------------------------------------------------
      program les_mpi_2d
c
      use pars
      use fields
      use particles
      use con_data
      use con_stats
      include 'mpif.h'
c
c ------------- definition of internal flags
c
c       iDNS    = 0; call the subgrid computation of vis_m and vis_s
c               = 1; call the molecular viscosity and diffusivity
c
c       igrdr   =  3; data comes from restart file
c               =  2; data comes from initialization (random)
c               =  1; data comes from coarser grid (or otherwise)
c
c       ibcu    = 1 ; upper boundary condition set by radiation bc
c               = 0 ; fixed value = 0.
c               = -1; wind tunnel setup, gradient = 0 bcs
c               = 2; Sullivan et al. Couette flow, sets u = Uo and w = v = 0 (NO SCALAR CHANGE YET)
c
c       ibcl    = 0 ; lower boundary condition set by similarity theory (sr. setup)
c               = -1; value defined by coarser mesh for all variables
c
c       ifix_dt = 0 ; variable time step with fixed cfl number in setcon
c               = 1 ; fixed time step set in sr. get_dt
c
c       ifree   = 0 ; use spatially averaged surface conditions for MO (call lower)
c               = 1 ; use point-by-point conditions for MO free convection (call lower_free)
c               = 2 ; use point-by-point conditions for MO with curvy boundaries (call lower_curvy)
c               = 3 ; DNS no-slip conditions on the bottom boundary (call lower_curvy_dns)
c
c       iflat   = 0 ; flat lower bottom, no pressure iteration
c               = 1 ; curvy lower boundary terrain following grid
c                     iterate for pressure field
c               = 2 ; time dependent lower boundary shape
c
c       lpbc    = 0 ; dpdz = 0 lower boundary condition for (u,v,w,uf,vf) updates
c               = 1 ; linear extrapolation to get ghost point for p(iz=0)
c               = 2 ; solve for p(iz=0) from wf equation at boundary
c     
c       imesh   = 0 ; stationary bottom
c               = 1 ; moving lower bottom
c
c       i_move_step  < 0  ; never move the bottom
c                    = it ; step where the moving grid starts
c
c       i_pm    = 1 ; use Peirson-Moskowitz wave spectrum
c              /= 1 ; use Donelan spectrum with wave age and wind dependence
c
c       i3d_surf   = 0  ; call simple l_bndy surface
c                  = 1  ; call moving 3d surface (water waves)
c                  = 2  ; call moving 3d surface with time varying amplitude
c                  = 3  ; call moving 3d surface with time varying amplitude (tank)
c
c       ihst    = nn; frequency at which global variables are output in history file
c               < 0 ; no history files
c
c       iviz    = nn; frequency at which global variables are output in viz files
c               < 0 ; no viz files
c
c       it_his  = time step where history files start, incremented by itape
c
c       it_viz  = time step where viz files start, incremented by itape
c
c       ismlt   = 1 ; use businger formulas in MO 
c                 0 ; use large and everyone elses formulas in MO 
c
c       iupwnd  = 0;  use skew symmetric formulas for all derivatives
c                     in scalar equations
c               = 1;  use hybrid upwind scheme for all derivatives
c                     in scalar equations
c
c       iskew   = 0;  use skew symmetric form for advection in (u,v,w) equations
c               = 1;  use flux form for advection in momentum equations
c
c       ivis0   = 0; old eddy viscosity model 
c               = 1; new eddy viscosity model 
c
c       iz_space = 1; non-uniform spacing with first grid point = zw1
c                = 2; non-uniform grid with adjusted first point off
c                     the surface to give constant stretching
c                = 3; non-uniform exponential curvy grid, good for
c                     moving boundaries
c                = 4; non-uniform exponential curvy grid with constant
c                     grid space at boundary and first grid point, good for
c                     moving boundaries
c                = 5; algebraic mapping with control over decay with height
c                     good for wavy boundaries. see a_decay for grid decay
c                = 0; uniform spacing
c
c       k_stab   = an iz (or k) index where stability corrected length scale is turned on
c                = -1 correction is always on
c                > nnz correction is never on
c                = value correction is on at iz = value
c
c       new_vis = step; the iteration step for which the new model
c                       is turned on when ivis0=1
c               < 0; new model is on at all steps for ivis0=1
c
c       nscl  .ge. 1   number of scalars to be followed set in parameter statements
c                      change entries in sr. init, and sr. suft for surface bc's
c
c -------------------------------------------------------------------------------
c
c ---------- initialize MPI, get myid, numprocs, 
c            test if on root process
c
      call mpi_init(ierr)
      call mpi_comm_rank(mpi_comm_world,myid,ierr)
      call mpi_comm_size(mpi_comm_world,numprocs,ierr)
c
      i_root = 0
      l_root = .false.
      if(myid .eq. i_root) l_root = .true.
c
      l_debug = .false.
      if(idebug .eq. 1) l_debug = .true.
c
      ts_mpi = mpi_wtime()

      !Read the input file for all parameters
      call read_input_file

c
c -------- set number of x-y slab cpus
c
c
      case_inp = 'wav'
c
      call get_units
      call gridd
      call setcon
      call set_paths
c
c -------------- scratch run
c
      if (iti.eq.0)  then
         igrdr = 2
         case = case_inp
         call init
         call setup(it)
         call mesh
         
         if (ispray==1) then
            call particle_setup
            call particle_init
            !call read_part_res
         end if

c
c ---------- choose routine for getting initial guess
c
         if(iocean .eq. 1) then
            call randoc
         else
            if (ifields .eq. 1) then
               call get_fields
            else
               call random
               !call random_f
               !call random_wt
            end if
         endif
         !if (iDNS .eq. 1) call dns_vis
         call dns_vis
         call get_max
      else
         igrdr = 3
         call restart
         call get_max
         call setup(it)
         call mesh

         if (ispray==1) then
            call particle_setup
            call read_part_res
            !call particle_init
         end if
      endif
c
c --------------- time loop ------------
c
      tzero = time
      call get_dt(it)
 9000 continue
      call set_sav(it,iti)

      if (myid==0) then
      write(*,*) 'Starting time loop'
      write(*,*) 'it,time = ',it,time
      end if
      if (ispray==1) then
      if (it == 1) numpart = 0
      part => first_particle
      do while (associated(part))
      if (part%pidx == 1 .and. part%procidx == 0) then
      write(*,'(a4,4e15.6)') 'xp1:',time,part%xp(1:3)
      write(*,'(a5,4e15.6)') 'xip1:',time,part%xip(1:3)
      write(*,'(a4,4e15.6)') 'vp1:',time,part%vp(1:3)
      write(*,'(a4,4e15.6)') 'uf1:',time,part%uf(1:3)
      write(*,'(a4,2e15.6)') 'Tp1:',time,part%Tp
      write(*,'(a4,2e15.6)') 'Tf1:',time,part%Tf
      end if
      part => part%next
      if (it == 1) numpart = numpart + 1
      end do
      if (myid==0) write(*,*) 'time,tnumpart:',time,tnumpart
      end if

c
c --------- specially designed surface cooling routine
c           for gabls run
c
c     call forcing
c
      if(it .ge. new_vis .and. ivis0 .eq. 1) then
          ivis = 1
      else
          ivis = 0
      endif
c
c ---------------- 3 stage runge-kutta time stepping
c
      do  8999 istage=1,3
c
      dtzeta   = dt*zetas(istage)
      dtgama   = dt*gama(istage)
      dtalp    = dtzeta + dtgama
      t_stage  = time + dt*etas(istage)
      t_stage2 = time + dt*etas(istage+1)
      if(istage .le. 2) then
        t_stage3 = time + dt*etas(istage+2)
      else
        t_stage3 = time + dt + dt1*etas(istage-1)
      endif
c
c ---------- compute derivatives of (u,v,w)
c
      call exchange
c
      call get_derv
c
c --------- check for moving grid
c
      if(imesh .eq. 1) then
        call new_mesh(it,istage)
        call grid_speed(it,istage)
      endif

c
c --------- new eddy viscosity, and bcs
c
      if(iss .eq. 0 .and. ifree .eq. 0) then
         call lower(it)
      elseif(ifree .eq. 1) then
         call lower_free(it)
      elseif(ifree .eq. 2) then
         call lower_curvy(it,istage)
      elseif(ifree .eq. 3) then
         call lower_curvy_dns(it,istage)
      endif
c
      if(ise .eq. numprocs-1) then
         if (iDNS .eq. 1) then
            call upper_dns
         else
            call upper
         endif
      endif
      call bcast_pbc
      call bcast_surf
      call get_means(istage)
      if(ivis .eq. 1) then
         call iso(it)
         call surfvis(it)
      endif
      if(istage .eq. 1)then
        call xy_stats
        call tke_budget
        call pbltop(itop)
      endif
c
c ------------ save velocity aand pressure fields
c
      if(msave .and. istage .eq. 1) then
         call save_v(it)
         call save_p
         if (ispray==1) call save_particles
      endif
      if(msave_v .and. istage .eq. 1) then
         call save_bndy(it)
         call save_viz(it)
      endif
c
c --------- get rhs/J for all equations
c
      !write(*,*) 'DHR proc',myid,'before comp1'
      call comp1(istage,it)
      !write(*,*) 'DHR proc',myid,'after comp1'
c
      if(istage .eq. 1) then
         if(msave .and. l_root) call save_c(it)
      endif
c
c --------- solve for pressure
c
      call psolver(istage)
      !write(*,*) 'DHR proc',myid,'after psolver'
c     call chk_div
c
c --------- add pressure gradient and dealias
c
      call comp2
      !write(*,*) 'DHR proc',myid,'after comp2'
c
      if(micut) then
         call dealias
         call dealias_grid_speed
      endif
c     call chk_div

c      
c -------- update particles
c
      if (ispray==1) then
         !t_s = mpi_wtime() 
         call particle_update_rk3(it,istage) 
         !t_f = mpi_wtime()
         !call mpi_barrier(mpi_comm_world,ierr)
         !if (myid==5) write(*,*) 'time part: ',t_f-t_s
      end if

      if(mnout .and. istage .eq. 1)  then
          if(l_debug) then
             call print(nprt,it,izs,ize)
          endif
          if(l_root) call print(6,it,1,nnz)
      endif
      if(l_root) then
         if(mhis  .and. istage .eq. 1)  call write_his(itop)
         if(mhis  .and. istage .eq. 1 .and. mtape) call close_his
      endif
 8999 continue
      call get_max
      call get_dt(it)
c
      if (it.ge.itmax) go to 99000
      go to 9000
c
99000 continue
      te_mpi = mpi_wtime()
      write(6,9997) (te_mpi - ts_mpi)
 9997 format(' Job Execution Time = ',e15.6)
c
 9998 continue
      call mpi_finalize(ierr)
c
      stop
      end
      subroutine get_max
c
c --------- routine computes max velocities as sweep through
c           the flux velocity field 
c
      use pars
      use fields
      use fftwk
      use con_data
      use con_stats
      include 'mpif.h'
c
      real u_send(6), u_recv(6)
c
      dx_i = 1.0/dx
      dy_i = 1.0/dy
c
      u_temp   = 0.0
      v_temp   = 0.0
      w_temp   = 0.0
      e_temp   = 0.0
      vis_temp = 0.0
      do iz=izs,ize
c
        u_xy = 0.0
        v_xy = 0.0
        w_xy = 0.0
        e_xy = 0.0
        g_xy = gm(1,iys,iz,1)
        do iy=iys,iye
        do ix=1,nnx
c
c          u_xy = amax1(u_xy,abs(u(ix,iy,iz)+stokes(iz)))
c          v_xy = amax1(v_xy,abs(v(ix,iy,iz)))
c          w_xy = amax1(w_xy,abs(w(ix,iy,iz)))
           u_xy = amax1(u_xy,abs(uf(ix,iy,iz)))
           v_xy = amax1(v_xy,abs(vf(ix,iy,iz)))
c          w_xy = amax1(w_xy,abs(wf(ix,iy,iz) - gm(ix,iy,iz,5)))
           w_xy = amax1(w_xy,abs(wf(ix,iy,iz)),abs(gm(ix,iy,iz,5)))
           e_xy = amax1(e_xy,e(ix,iy,iz))
           g_xy = amax1(g_xy,gm(ix,iy,iz,1))
        enddo
        enddo
        u_xy   = u_xy*dx_i
        v_xy   = v_xy*dy_i
        wsav   = w_xy
        w_xy   = w_xy/abs(dzw(iz))
c
c ------- get max allowable diffusivity for scalars
c
        vis_xy = dfac(iz)*3.0*ck*dsl_z(iz)*(g_xy**pow3)*
     +           sqrt(e_xy)/amin1(dx,dy,dzw(iz))**2
c
        u_temp   = amax1(u_xy,u_temp)
        v_temp   = amax1(v_xy,v_temp)
        w_temp   = amax1(w_xy,w_temp)
        e_temp   = amax1(e_xy,e_temp)
        vis_temp = amax1(vis_xy,vis_temp)
c
c       if(iz .le. 15) then
c         write(6,6000) iz, wmax
c6000     format(' in get_dt iz = ',i3,' wmax = ',e15.6)
c       endif
c
      enddo
      u_send(1) = u_temp
      u_send(2) = v_temp
      u_send(3) = w_temp
      u_send(4) = wsav
      u_send(5) = e_temp
      u_send(6) = vis_temp
c
      call mpi_allreduce(u_send,u_recv,6,mpi_real8,
     +     mpi_max,mpi_comm_world,ierror)
c
      umax   = u_recv(1)
      vmax   = u_recv(2)
      wmax   = u_recv(3)
      wabs   = u_recv(4)
      emax   = u_recv(5)
      vismax = u_recv(6)
c
      return
      end
      subroutine get_dt(it)
c
c ---------- routine computes max time step for given cfl number
c            from max's found previously
c
      use pars
      use con_data
      use con_stats
c
      ucfl = umax
      vcfl = vmax
      wcfl = wmax
      vel_max = amax1(ucfl, vcfl, wcfl)
      if(vel_max .le. 0.0) then
          write(6,6000) ucfl, vcfl, wcfl, vel_max
 6000     format('6000, sr. get_dt bad news, umax = ',e15.6,/,
     +           ' vmax = ',e15.6,' wmax = ',e15.6,/,
     +           ' vel_max = ',e15.5,/,
     +           ' infinite time step !!!')
          stop
      endif
c
c ---------------- choose fixed or variable time step
c
      if(ifix_dt .ne. 0) then
c
c ------------- if used, change to fit your problem
c
        dt_new = 0.0002
      else
c
c ------------------- new estimate of best time step
c                     from cfl constraint
c
      dt_new  = cfl/vel_max
      dt_new = amin1(dt_new, 5.0)
c     dt_new = amin1(dt_new, 1.0)
c     dt_new = amin1(dt_new, 20.0)
c     dt_new = amin1(dt_new, 10.0)
      endif
c
c ---------------- compare against viscous stability limit
c
      if(vismax*dt_new .gt. 0.5) then
         dt_cfl = dt_new
         dt_new = 0.5/vismax
         if(l_root) then
            write(6,6200) dt_new, dt_cfl, vismax
 6200       format(' 6200 get_dt: cfl time step too large',/,
     +      '   viscous time step = ',e15.6,
     +      ' cfl time step = ',e15.6,' vismax = ',e15.6)
         endif
      endif
c
c -------- for safety if restart set timestep = saved timestep in
c          restart file
c
CHECK ... for moving grids?
c
      if(it .eq. iti .and. iti .ne. 0) then
        dt_new = dt1
        dt1    = dt
        write(nprt,4001) it, iti, dt_new, dt1, dt
 4001   format(' 4001: it = ',i5,' iti = ',i5,
     +         ' dt_new = ',e15.6,' dt1 = ',e15.6,
     +         ' dt = ',e15.6)
      endif
c
      return
      end
      subroutine lterp(n,zary,zpt,i,ip1,ratio)
c
c ---- linear interpolation for zpt in zary, where zary is 
c      monotonic increasing or decreasing function
c
      dimension zary(*)
      nm1 = n-1
      if(n.le.1) then
          i = 1
          ip1 = 1
          ratio = 0.0
          go to 999
      endif
      if(zary(1) .lt. zary(2)) go to 1
                               go to 101
    1 continue
c
c **** monotonic increasing array
c
        if(zpt .lt. zary(1)) then
          i = 1
          ip1 = 1
          ratio = 0.0
          go to 999
        else if(zpt .gt. zary(n)) then
          i = n
          ip1 = n
          ratio = 1.0
          go to 999
        endif
        do j=1,nm1
              if(zpt .ge. zary(j) .and.
     $           zpt .le. zary(j+1)) then
                 i = j
                 ip1 = j+1
                 ratio = (zpt - zary(i))/(zary(ip1) - zary(i))
                 go to 999
              endif
        enddo
c
c **** decreasing array
c
  101 continue 
        if(zpt .gt. zary(1)) then
          i = 1
          ip1 = 1
          ratio = 0.0
          go to 999
        else if(zpt .lt. zary(n)) then
          i = n
          ip1 = n
          ratio = 1.0
          go to 999
        endif
        do j=1,nm1
              if(zpt .le. zary(j) .and.
     $           zpt .ge. zary(j+1)) then
                 i = j
                 ip1 = j+1
                 ratio = (zpt - zary(i))/(zary(ip1) - zary(I))
                 go to 999
              endif
        enddo
  999 continue
      return
      end
      subroutine setcon
c
      use pars
      use fftwk
      use con_data
      use con_stats
      include 'mpif.h'
      external get_zi
c
c ----------------- get machine type, can read datadir also
c
      open(99,file='mach.file')
      read(99,9000) imach
 9000 format(i1)
c
      close(99)
c
c ----------- initialize fft
c
      call rffti(nnx,trigx(1,1))
      call rffti(nny,trigx(1,2))
      call cffti(nny,trigc(1))
      call cffti(nnx,trigcx(1))
c
c ----------- start step for history and viz files
c
      it_his_nxt = it_his
      it_viz_nxt = it_viz
c
c ---------------- set min value of e
c
      if(iocean .eq. 1) then
c
         smal_e = 0.0
         smal_e = 1.0e-12
c        smal_e = 6.0e-03
      else
         smal_e = 1.0e-09
c        smal_e = 0.0
      endif
c
c
c ---------------------- set constants in eddy viscosity model
c
      ck       = 0.1
      ceps     = 0.93
      csmag    = sqrt(ck*sqrt(ck/ceps))
      stab_c   = 0.76
      pow3     = 1.0/3.0
c
c ----------------- set stability constant
c
      stabmin = 1.0e-12
c
c ---------------- minimum dsl length constant
c 
      almin_c = 0.0001
c
c -------------------- set viscosity model parameters 
c                      to usual values, overridden by iso
c                      dfac is in constant file for calculation
c                      of max eddy viscosity
c
      viscon      = 0.0
      xksurf      = 0.0
      nmatch      = -1
      myid_newvis = 0
      do iz=1,nnz
         dfac(iz) = 1.0
      enddo
c
c -------------- initialize grid restart flag
c
      igrdr = 1
c
c ---------- set constants for pressure iteration
c
      p_surf = 0.0
c
      if(iflat .eq. 0) then
         ip_max    = 2
         ptol      = 0.0
         accel_max = 1.0
         accel_min = 1.0
         do i=1,ip_accel
            accel(i) = 1.0
         enddo
      else
c
c ------- with effectively flat just use 2 iterations
c
         ip_max  = 2
         ptol    = 1.0e-07
c        ptol    = 1.0e-20
c
         if(i3d_surf == 3) then   !  strategy for breaking waves in tank
            ptol      = 1.0e-10
            ip_max    = 50
            ip_max    = 35
            accel_max = 1.0
            accel_min = 0.1
            ip_ramp   = 30
c
c           accel_max = 1.0
c           accel_min = 1.0
c           ip_max    = 15
c      
c
c ---------- for initialization with flat
c
c           ip_max    = 2
c           ptol      = 1.0e-07
c           accel_max = 1.0
c           accel_min = 1.0
c           ip_ramp   = 30
         else                     !  strategy for pbl with surface waves or hills
            ptol      = 1.0e-10
            ip_max    = 30
c           ip_max    = 2
c
c           ip_max    = 1 ! with wave amplitude = 0 
c
            accel_max = 1.0
            accel_min = 1.0
            ip_ramp   = 10
         endif
         d_accel   = (accel_max - accel_min)/float(ip_ramp - 1)
         do i=1,ip_accel
            accel(i) = accel_max
         enddo
         do i=1,ip_ramp
            accel(i) = float(i-1)*d_accel + accel_min
         enddo
         write(nprt,1017) (i,accel(i),i=1,ip_accel)
 1017    format(' acceleration parameters',/,
     +          ' i ',5x,' accel',/,(i5,e15.6))
      endif
c
c -------------- set grid generation factor for type of simulation
c                in routines exp_grid, exp_grid2
c
         if(i3d_surf == 0) then
            a_exp_grd   = 0.020
            a_exp_grd2  = 0.00010
            a_decay     = 3.0
         elseif(i3d_surf == 1) then
            a_exp_grd   = 0.020
            a_exp_grd2  = 0.00010
            a_decay     = 3.0
         elseif(i3d_surf == 2) then
            a_exp_grd   = 0.020
            a_exp_grd2  = 0.00010
            a_decay     = 3.0
         elseif(i3d_surf == 3) then
c           a_exp_grd   = 50.00
            a_exp_grd   = 11.65
            a_exp_grd2  = -1000.0 ! fix for tank simulations
            a_decay     = 3.0
         endif
c
c -------------- create mpi operation to find max and location
c                using local gradient method
c
      call mpi_op_create(get_zi,.true.,ziloc,ierror)
c
c ---------- define coefficients for 3-order runge-kutta
c            time stepping scheme, borrowed from Spalart,
c            Moser and Rogers, J. Comp. Physics 3/21/90
c            Note this is a simplier version since all terms
c            are lumped in the non-linear terms.
c            cfl number is for an entire runge-kutta step
c            in this case three stages. cfl = max(u)*dt/dx
c
c            see jcp article by berkooz for time steps
c
      zetas(1) = 0.0
      zetas(2) = -17.0/60.0
      zetas(3) = -5.0/12.0
      gama(1)  = 8.0/15.0
      gama(2)  = 5.0/12.0
      gama(3)  = 3.0/4.0
c
      etas(1)  = 0.0
      etas(2)  = 8.0/15.0
      etas(3)  = 2.0/3.0 
c
c ----------- a full step, at the new time
c
      etas(4)  = 1.0
c
c     cfl = 0.63
c
      cfl = 0.50
c     cfl = 0.30
c     cfl = 0.10
c
c --------- set stationary flag on a restart
c           see sr. set_sav for tests
c
      imesh = 0
c
      return
c
      end
      subroutine set_paths
c
c ------------- set file path for RESTART, and
c               directories for saving, history, and viz files
c
c     path_res  --- the path and file name of the velocity restart file
c     path_sav  --- the path where the new 3d volumes are to be saved
c     path_his  --- the path where the new history files are to be saved
c     path_viz  --- the path where xy, xz, or yz planes of data will be stored
c     path_stuf --- the path where fun facts about the viz planes of 
c                   data will be stored
c     path_bndy --- the path where the boundary shape is stored
c     path_seed --- seed name
c
      use pars
c
c
c --------- initialization
c
      path_sav    = path_seed
      path_his    = path_seed
      path_viz_xy = path_seed
      path_viz_xz = path_seed
      path_viz_yz = path_seed
      path_stuf   = path_seed
      path_bndy   = path_seed
c
      return
      end
      subroutine setup(it)
c
      use pars
      use fields
      use fftwk
      use con_data
      use con_stats
c
      it = iti
c
c ------------ turn on new sgs model at a particular step
c
      if(it .ge. new_vis .and. ivis0 .eq. 1) then
          ivis = 1
      else
          ivis = 0
      endif
c
      if(igrdr . eq. 3) then
         if(l_root) then
            write(6,6)iti,utau,tsfcc(1) ,qstar(1)
            write(6,510)
            write(6,520) wtsfc(1),utau,amonin,dtdzf(1),zody,zo
     +            ,cdbtm,ugcont
            call print(6,it,1,nnz)
         endif
          if(l_debug) then
            write(nprt,6)iti,utau,tsfcc(1) ,qstar(1)
            write(nprt,510)
            write(nprt,520) wtsfc(1),utau,amonin,dtdzf(1),zody,zo
     +            ,cdbtm,ugcont
            call print(nprt,it,izs,ize)
          endif
      endif
c     if(ifilt.eq.1)call filter
      if(l_root) then
         write(6,1) nnx,nny,nnz,ismlt,ifilt,iti,itmax,
     +             iupwnd,ibuoy,itcut,
     +             dt,zo,tsfcc(1),isubs,ibrcl,
     +             method, iocean, ivis
      endif
      if(l_debug) then
         write(nprt,1) nnx,nny,nnz,ismlt,ifilt,iti,itmax,
     +             iupwnd,ibuoy,itcut,
     +             dt,zo,tsfcc(1),isubs,ibrcl,
     +             method, iocean, ivis
      endif
c
c -------------- boundary condition flags 
c
      !ibcu = 2
      ibcu = -1
      ibcl = 0
c
c -------------------- wavenumbers, introduce a normalized
c                      set of wavenumbers to eliminate computation
c                      in derivatives , xderiv, yderiv
c
      do i=1,nnx
         xkn(i) = float(i-1)*pi2/xl
         if(i.gt.ncx)xkn(i) = -float(nnx-i+1)*pi2/xl
      enddo
      fn = 1.0/float(nnx)
      do i=1,nnx
         xk(i)  = xkn(i)*fn
         xkk(i) = xkn(i)*xkn(i)*fn
      enddo
      do i=1,nny
         ykn(i) = float(i-1)*pi2/yl
         if(i.gt.ncy)ykn(i) = -float(nny-i+1)*pi2/yl
      enddo
      fn = 1.0/float(nny)
      do i=1,nny
         yk(i)  = ykn(i)*fn
         ykk(i) = ykn(i)*ykn(i)*fn
      enddo
      ii = -1
      do i=1,ncx
         ii = ii + 2
         temp = xkn(i)**2
         do j=1,nny
            temp1       = temp + ykn(j)**2
            xks(ii,j)   = temp1
            xks(ii+1,j) = temp1
         enddo
      enddo
      xnn = abs(batag*dtdzf(1))
c
c ----------- choose correct sign so gravity waves
c             propagate out of the domain
c
      sgn = 1.0
      if(iocean .eq. 1) sgn = -1.0
      if(ibcu.eq.1) then
         do iy=1,nny
         do ix=1,nnxp2
            if(xks(ix,iy) .le. 0.) then
              wavexy(ix,iy) = 0.0
            else
              wavexy(ix,iy) = sgn*sqrt(xnn/xks(ix,iy))
            endif
         enddo
         enddo
      endif
c
c -------------------- set length scale for SGS model
c
      if(iz_space .eq. 0) then
c
c ------------- uniform vertical spacing
c
      dx32 = dx*3./2.
      dy32 = dy*3./2.
      dsl  = (abs(dx32*dy32*dzw(1)))**(1./3.)
      dslg = dsl
c
c -------
c
      do iz=0,nnzp1
         dsl_z(iz) = dslg
      enddo
      if(l_root)  write(6,2000) dsl
      if(l_debug) write(nprt,2000) dsl
      if(l_root) write(6, 4033) (iz,dsl_z(iz),iz=0,nnz+1)
c
c ------------- variable vertical spacing
c
      else
c
c ----------- just estimate dsl for average spacing
c
         dx32 = dx*3./2.
         dy32 = dy*3./2.
c
         dsl_max = (abs(dx32*dy32*dzw(0)))**pow3
         do iz=0,nnzp1
            dsl_z(iz) = (abs(dx32*dy32*dzw(iz)))**pow3
            if(dsl_z(iz) .gt. dsl_max) dsl_max = dsl_z(iz)
         enddo
c        do iz=0,nnzp1
c           dsl_z(iz) = dsl_max
c        enddo
         dsl  = dsl_max
         dslg = dsl
         if(l_root) write(6, 4033) (iz,dsl_z(iz),iz=0,nnz+1)
      endif
c
c -------- SPECIAL for grid refinement study
c
c     nnx_c = 128
c     nny_c = 128
c     nnz_c = 128
c     dx32  = float(nnx)/float(nnx_c)*dx*1.5
c     dy32  = float(nny)/float(nny_c)*dy*1.5
c     dzw_c = float(nnz)/float(nnz_c)*dzw(1)
c
c     dsl  = (abs(dx32*dy32*dzw_c))**(1./3.)
c     dslg = dsl
c     if(l_root)  write(6,2100) dsl
c     if(l_debug) write(nprt,2100) dsl
c
c --------------------- create dsl array for easy indexing in comp1
c
c     do iz=0,nnzp1
c        dsl_z(iz) = dslg
c     enddo
      if(l_root) write(6, 4033) (iz,dsl_z(iz),iz=0,nnz+1)
c
      gridr = 1.0
      sml_eg = smal_e*gridr
c
c -------------------- set viscosity model parameters 
c                      now in setcon
c
c     if(ivis .ne. 1) then
c       viscon = 0.0
c       xksurf = 0.0
c       nmatch = -1
c       myid_newvis = 0
c       do iz=1,nnz
c          dfac(iz) = 1.0
c       enddo
c     endif
c ------------------- set stokes velocity for atmos/oceanic flow
c
      call stokesv
c
c --------- special for moving 3d surface
c
      if(i3d_surf .eq. 1) then
         call surf_setup
      elseif(i3d_surf .eq. 2) then
         call surf_setup_gabls
      elseif(i3d_surf .eq. 3) then
         call surf_setup_tank
      endif
c
c --------- can add a time factor so as to skip into any part of
c           the specified geostrophic arrays. time factor in seconds
c
      t_factor = 7200.0
c
c ---------- for print out to get more digits
c
c     t_ref = t00
c
c -------------- for wind tunnel simulations
c                account for box height
c
      t_ref      = 0.0
c
      dpdx_con_z = dpdx_con/zl
      !dpdx_con_z = 0.0
c
c -------------------- specify cooling rate and initial
c                      temperature even for restarts
c                      from runs with DM
c
      c_rate   = 0.375/3600.0
      t_surf_i = 287.99999
c
c -------------------- do not look for zi below zi_min
c
      zi_min = 30.0
      if(iocean .eq. 1) zi_min = -5.0
      iz_min = 1
      do iz=1,nnz-1
         if(zz(iz) .lt. zi_min .and.
     +      zz(iz+1) .ge. zi_min) iz_min = iz
      enddo
      if(l_root) then
         write(6,9000) zi_min, iz_min
      endif
c
c -------- for curvy bottom set the distribution
c          of specified heat flux. customize for
c          particular use
c
      call set_lower_bc
c
 9998 continue
      return
c --------------------------- format statements
    6 format(///,' DATA FROM RESTART FILE AT STEP =',I5,
     +       ' U_* = ',e15.6,' TS = ',e15.6,' Q_* = ',e15.6,///)
  510 format(' RESTART ***** CASE WITH : ******',/)
  520 format(' WT = ',e12.4,', U_* = ',e12.4,', L = ',e12.4,
     +       ', DTDZ FREE = ',e12.4,', ZODY = ',e12.4,/,10x,
     +       '  ZO(BTM) = ',e12.4,', CDBTM = ',e12.4,
     +       ', UG = ',e12.4)
    1 format(10x,' NNX = ',i5,',  NNY = ',i5,
     + ',  NNZ = ',i5,/,10x,' SFC SMLT = ',i1,
     + ',  FILTER = ',i1,
     + ',  ITI = ',i6,',  ITMAX = ',i6,/,10x,
     + ' IUPWIND = ',i1,',  BUYNCY = ',i1,
     + ',  ITCUT = ',i1,/,10x,
     + ' DT = ',e15.6,',  ZO = ',e15.6,',  TS = ',e15.6,
     + ',  SUBSD = ',i1,/,
     + 10x,' BRCLICITY = ',i1,',  METHOD = ',i1,',  IOCEAN = ',i1,
     + ',  IVIS = ',i1)
 4033 format(' Eddy viscosity length scale for variable z meshes',/,
     +          ' iz ',5x, ' dsl ',/,(i3,5x,e15.6))
 2000 format(10x,' DSL = ',e15.6)
 2100 format(10x,' DSL coarse = ',e15.6)
 9000 format(' Search for zi above the height = ',e15.6,/,
     +       ' iz_min = ',i5)
      end
      subroutine set_lower_bc
c
c -------- for curvy lower boundary set
c          distribution of heat flux or other 
c          scalar sources and sinks
c
      use pars
      use fields
      use fftwk
      use con_data
      use con_stats
c
      if(isfc .eq. 0) then ! given qstar compute surface temp
      write(nprt,2000) qstar(1)
 2000 format(' 2000 in set_lower_bc: qstar = ',e15.6)
c
      do j=iys,iye
      do i=1,nnx
         t3tbc(i,j,1)  = qstar(1)
         t_grnd(i,j,1) = tsfcc(1)
      enddo
      enddo
c
      else ! given surface temp compute qstar
c
      do j=iys,iye
      do i=1,nnx
         t3tbc(i,j,1)  = -99999.0
         t_grnd(i,j,1) = tsfcc(1)
      enddo
      enddo
c
      endif
c
      return
      end
      subroutine nblnk(word)
      parameter (nmax=304)
      character wordt*304, word*(*)
      nchar = len(word)
      if(nchar .gt. nmax) then
         write(6,6000) nchar,nmax
 6000    format(' TROUBLE, IN SR. NBLNK : NCHAR = ',i6,
     +          ' EXCEEDS NMAX = ',i6)
         stop
      endif
      jj = 0
      do j=1,nchar
         if(word(j:j) .ne. ' ') then
            jj = jj + 1
            wordt(jj:jj) = word(j:j)
         endif
         word(j:j) = ' '
      enddo
      do j=1,jj
         word(j:j) = wordt(j:j)
      enddo
c
      return
      end
      subroutine blnk(word)
      character word*(*)
      nchar = len(word)
      do j=1,nchar
         word(j:j) = ' '
      enddo
c
      return
      end
      subroutine iso(it)
c
CHECK new eddy viscosity ivis0 = 0 for testing
c
      use pars
      use fields
      use fftwk
      use con_data
      use con_stats
      include 'mpif.h'
c
      real sfk(1:nnz)
c
c ---- get isotropy factor and scale it to match at the matching
c      height. uses boundary conditions from lower and upper. 
c
      do iz=1,nnz
c        dfac(iz) = 1.0
         dfac(iz) = 0.0
         sfk(iz)  = 0.0
      enddo
      do iz=izs,ize
         dfac(iz) = 1.0
      enddo
c
c ------ set nmatch equal to fraction of initial zi in sr. random
c
c     nmatch = izi/2
c     nmatch = 16
      nmatch = 48
      do i=0,numprocs-1,ncpu_s
         if(nmatch .ge. iz_s(i) .and.
     +      nmatch .le. iz_e(i)) myid_newvis = i
      enddo
c
      do iz=izs,min(ize,nmatch)
         izp1 = iz + 1
         izm1 = iz - 1
c        weit = dzw(iz)/(dzw(iz) + dzw(izp1))
c        weit1 = 1.0 - weit
c
c ---- get fluctuating strains
c
         do j=iys,iye
         do i=1,nnx
            s11 = weitm(iz)*ux(i,j,iz)**2 + weit(iz)*ux(i,j,izp1)**2
            s22 = weitm(iz)*vy(i,j,iz)**2 + weit(iz)*vy(i,j,izp1)**2
            wz  = (w(i,j,iz)-w(i,j,izm1))*dzw_i(iz)
            wzp = (w(i,j,izp1)-w(i,j,iz))*dzw_i(izp1)
            s33 = weit(iz)*wzp**2 + weitm(iz)*wz**2
            s12 = weitm(iz)*(uy(i,j,iz) + vx(i,j,iz))**2 +
     +            weit(iz)*(uy(i,j,izp1) + vx(i,j,izp1))**2
            s13 = (((u(i,j,izp1) - u(i,j,iz) +
     +            u_mn(iz) - u_mn(izp1))*dzu_i(izp1) +
     +            wx(i,j,iz)))**2
            s23 = (((v(i,j,izp1) - v(i,j,iz) +
     +          v_mn(iz) - v_mn(izp1))*dzu_i(izp1) +
     +          wy(i,j,iz)))**2
            sfk(iz) = sfk(iz) + 2.0*(s11 + s22 + s33) +
     +                       s12 + s13 + s23
         enddo
         enddo
         sfk(iz) = sfk(iz)*fnxy
      enddo
      call mpi_sum_z(sfk,i_root,myid,nnz,1)
c
      do iz=izs,min(ize,nmatch)
         izp1 = iz + 1
         izm1 = iz - 1
c
         sfk(iz) = sqrt(sfk(iz))
         smk = sqrt((u_mn(izp1)-u_mn(iz))**2 +
     +              (v_mn(izp1)-v_mn(iz))**2)*abs(dzu_i(izp1))
         if(sfk(iz) .le. 0. .and. smk .le. 0.) then
           dfac(iz) = 1.0
         else
           dfac(iz) = sfk(iz)/(sfk(iz) + smk)
         endif
c     if(l_root) write(6,6001) iz,sfk(iz),smk,dfac(iz)
 6001 format(' iz = ',i3,' sfk = ',e15.6,
     +       ' smk = ',e15.6,' dfac = ',e15.6)
      enddo
c
c
c ---- rescale ratio to give unity at match height
c      and if nested grid match value at upper boundary
c      of coarser grid
c
      if(myid .eq. myid_newvis) then
         dfacm = dfac(nmatch)
      endif
c
      call mpi_bcast(dfacm,1,mpi_real8,
     +              myid_newvis,mpi_comm_world,ierr)
c
      do iz=izs,min(ize,nmatch)
         dfac(iz) = dfac(iz)/dfacm
         dfac(iz) = amax1(dfac(iz), 0.1)
         dfac(iz) = amin1(dfac(iz), 1.0)
      enddo
c
c --------- gather dfac on all processes for printing and use in tke_vis
c           use reduce and divide by number of slab cpus
c
      call mpi_sum_z(dfac,i_root,myid,nnz,1)
      fncpu_s = 1.0/float(ncpu_s)
      do iz=1,nnz
         dfac(iz) = dfac(iz)*fncpu_s
      enddo
c
c     call mpi_gath_root(dfac(izs),dfac(1),iz_s,iz_e,izs,ize,nnz,
c    +                   myid,numprocs,ncpu_s)
c
c     if(l_root) write(6,6000) nmatch,ivis,(iz,dfac(iz),iz=1,nnz)
 6000 format(' in sr. iso, nmatch = ',i3,/,
     +       ' ivis = ',i3,'iz',5x,'dfac',/,(i3,1x,e15.6))
c     write(nprt,3001) (iz,dfac(iz),iz=1,nnz)
 3001 format(' iz ',5x,' dfac ',/,(i5,e15.6))
      return
      end
      subroutine surfvis(it)
c
c FIX for transformed grids
c
      use pars
      use fields
      use fftwk
      use con_data
      use con_stats
      include 'mpif.h'
      real xkvis(nnx,iys:iye), alwk(nnx,iys:iye)
c
      real send(3), buf(3)
c
      xksurf = 0.0
      viscon = 0.0
      vise   = 0.0
c
c ----------- only root process(es) compute 
c
      if(iss .eq. 0) then

c     ck = 0.1
c     csmag = 0.18
c     xkmax  = dzdz/dt/5.
      iz   = 1
      izm1 = iz - 1
      izp1 = iz + 1
c     xkmax  = dzu(izp1)*dzu(izp1)/(5.0*dt)
      dz_i = dzu_i(izp1)
      if(iocean .eq. 1) then
         call sufto(it)
      else
         call suft(it)
      endif
      if(qstar(1) .eq. 0.) then
         zeta = 0.0
      else
         zeta = abs(z(1))/amonin
      endif
      if(ismlt .eq. 1) then
          call busngr(zeta,phim,phis,psim,psis)
      else
          call fzol(zeta,phim,phis,psim,psis)
      endif
      viscon = vk*abs(z(1))/(utau*phim)
      vise   = utau*vk*abs(z(1))/phim
c
c ---- get special value at z1 to match with surface layer
c
      uws = 0.0
      vws = 0.0
      do iy=iys,iye
      do ix=1,nnx
         uws = uws + 0.5*(u(ix,iy,iz)-u_mn(iz) + 
     +         u(ix,iy,izp1) - u_mn(izp1))*(w(ix,iy,iz)-w_mn(iz))
         vws = vws + 0.5*(v(ix,iy,iz)-v_mn(iz) + 
     +         v(ix,iy,izp1) - v_mn(izp1))*(w(ix,iy,iz)-w_mn(iz))
      enddo
      enddo
      uws = uws*fnxy
      vws = vws*fnxy
c
c ---- get average fluctuating eddy viscsoity
c
      do iy=iys,iye
      do ix=1,nnx
         e(ix,iy,iz)=amax1(e(ix,iy,iz),sml_eg)
      enddo
      enddo
      dslk = amin1(dsl,vk*abs(z(iz))/csmag)
c     stabmin = 1.e-12
c     almin = 0.0001*dsl
      almin = almin_c*dsl_z(iz)
      do iy=iys,iye
      do ix=1,nnx
         alwk(ix,iy)=dslk
c
c --------no stability corrected length scales when
c         new eddy viscosity is on
c
c         stab=batag*(t(ix,iy,1,izp1)-t(ix,iy,1,iz))*dz_i
c         if(stab.gt.stabmin) then
c           als = stab_c*sqrt(e(ix,iy,iz)/stab)
c           alwk(ix,iy) = amin1(dslk,als)
c         endif
c         alwk(ix,iy)=amax1(almin,alwk(ix,iy))
         xkvis(ix,iy)=ck*alwk(ix,iy)*sqrt(e(ix,iy,iz))*dfac(1)
c        xkvis(ix,iy)=amin1(xkvis(ix,iy),xkmax)
      enddo
      enddo
c
c ---- get average viscosity
c
      xkavg = 0.0
      do iy=iys,iye
      do ix=1,nnx
         xkavg = xkavg + xkvis(ix,iy)
      enddo
      enddo
      xkavg = xkavg*fnxy
c
      buf(1) = uws
      buf(2) = vws
      buf(3) = xkavg
      call mpi_sum_xy(buf,myid,iss,ise,3)
c
      uws   = buf(1)
      vws   = buf(2)
      xkavg = buf(3)
c
      xkz1 = vise - sqrt(uws**2 + vws**2)*viscon
      xksurf =  xkz1 - xkavg
      xksurf = amax1(xksurf,0.0)
      xksurf = amin1(xksurf,vise)
c     if(l_root) write(6,6000) dfac(1), xkavg, xkz1, vise, xksurf
 6000 format(' dfac = ',e12.4,' xkavg = ',e12.4,' xkz1 = ',e12.4,/,
     +       ' vise = ',e12.4,' xksurf = ',e12.4)
c
      endif
c
c ---------- broadcast values to other processes
c
      send(1) = xksurf
      send(2) = viscon
      send(3) = vise
c
      call mpi_bcast(send,3,mpi_real8,
     +              i_root,mpi_comm_world,ierr)
c
      xksurf = send(1)
      viscon = send(2)
      vise   = send(3)
c
      return
      end
      subroutine comp1(istep,it)
c
c ----- 3-order runge-kutta time stepping and monotone scalar fluxes in x,y,z.
c       designed to use mpi in x & y directions.
c       variables advanced are (u,v,w,e,theta)/J
c
      use pars
      use fields
      use fftwk
      use con_data
      use con_stats
      include 'mpif.h'
      integer istatus(mpi_status_size)
c
      parameter(js = 7, ns = 3, nstat = js + ns*nscl)
      real stat(1:nnz,nstat)
c
c ------ temp arrays to hold rhs from step n-1 and
c        field variables from step n 
c
      real urhs(nnx,iys:iye,izs:ize), 
     +     vrhs(nnx,iys:iye,izs:ize),
     +     wrhs(nnx,iys:iye,izs:ize),
     +     erhs(nnx,iys:iye,izs:ize),
     +     trhs(nnx,iys:iye,nscl,izs:ize)
c
c ------------ build rhs with u/J from last time step
c              when the routine is entered (u,v,w,e,theta) are
c              free of (1/J)
c
      do k=izs,ize
         do j=iys,iye
         do i=1,nnx
            urhs(i,j,k) = u(i,j,k)*gm(i,j,k,1) + dtzeta*r1(i,j,k)
            vrhs(i,j,k) = v(i,j,k)*gm(i,j,k,1) + dtzeta*r2(i,j,k)
            wrhs(i,j,k) = w(i,j,k)*gm(i,j,k,1) + dtzeta*r3(i,j,k)
            erhs(i,j,k) = e(i,j,k)*gm(i,j,k,1) + dtzeta*r5(i,j,k)
         enddo
         enddo
      enddo
c
      do k=izs,ize
         do l=1,nscl
         do j=iys,iye
         do i=1,nnx
            trhs(i,j,l,k) = t(i,j,l,k)*gm(i,j,k,1) + dtzeta*r4(i,j,l,k)
         enddo
         enddo
         enddo
      enddo
c
c --------- get viscosity and rhs of (e,u,v,w)-equations
c           at next step
c
      if (iDNS .eq. 1) then
         call dns_vis
         call rhs_uvw_dns(istep)
      else
         call tke_vis(istep)
         call rhs_uvw(istep)
      endif
c
c -------- evaluate rhs of scalar equations
c
      do l=1,nscl
         if (iDNS .eq. 1) then
            call rhs_scl_dns(istep,l) 
         else
            call rhs_scl(istep,l) 
         endif
      enddo
c
c ---------- gather stat sums on root processor
c            using mpi_reduction over all processors
c
      if(istep .eq. 1) then
c
        do j=1,nstat
        do k=1,nnz
           stat(k,j) = 0.0
        enddo
        enddo
        do k=izs,ize
           stat(k,1) = uwsb(k)
           stat(k,2) = vwsb(k)
           stat(k,3) = wwsb(k)
           stat(k,4) = tr_tau(k)
           stat(k,5) = triz(k)
           stat(k,6) = shrz(k)
           stat(k,7) = t_diss(k)
        enddo
        m1 = js
        m2 = js + nscl
        m3 = js + 2*nscl
        do l=1,nscl
           do k=izs,ize
              stat(k,m1+l) = utsb(k,l)
              stat(k,m2+l) = vtsb(k,l)
              stat(k,m3+l) = wtsb(k,l)
           enddo
        enddo
        call mpi_sum_z(stat(1,1),i_root,myid,nstat*nnz,1)
        do k=1,nnz
           uwsb(k)   = stat(k,1)
           vwsb(k)   = stat(k,2)
           wwsb(k)   = stat(k,3)
           tr_tau(k) = stat(k,4)
           triz(k)   = stat(k,5)
           shrz(k)   = stat(k,6)
           t_diss(k) = stat(k,7)
        enddo
        do l=1,nscl
           do k=1,nnz
              utsb(k,l) = stat(k,m1+l)
              vtsb(k,l) = stat(k,m2+l)
              wtsb(k,l) = stat(k,m3+l)
           enddo
        enddo
        do k=1,nnz
           buyz(k) = batag*wtsb(k,1)
        enddo
c
c -------- end if block
c
      endif
c
c ------- save old rhs in field variables for RK-advancement
c         add new rhs for computation of flux velocities
c         at this stage field variables are (u,v,w,e,theta)/J
c
      do k=izs,ize
         do j=iys,iye
         do i=1,nnx
            u(i,j,k) = urhs(i,j,k) + dtgama*r1(i,j,k)
            v(i,j,k) = vrhs(i,j,k) + dtgama*r2(i,j,k)
            w(i,j,k) = wrhs(i,j,k) + dtgama*r3(i,j,k)
            e(i,j,k) = erhs(i,j,k) + dtgama*r5(i,j,k)
         enddo
         enddo
      enddo
      do k=izs,ize
         do l=1,nscl
         do j=iys,iye
         do i=1,nnx
            t(i,j,l,k) = trhs(i,j,l,k) + dtgama*r4(i,j,l,k)
         enddo
         enddo
         enddo
      enddo
c
c --------- generate rhs of contravariant flux velocities equations
c           at cell faces
c
      call rhs_flux_vel(istep)
c
      return
      end
      subroutine rhs_flux_vel(istep)
c
c ------ get rhs of intermediate velocity (uf,vf,wf)
c        by interpolating from cell center values.
c        extrapolate from interior to get surface value for wf.
c        assumes that rhs of the (u,v,w) equations are
c        multiplied by (1/J) from comp1, ie, 
c        the right sides used in the interpolation here
c        are (u/J,v/J,w/J).
c
      use pars
      use fields
      use fftwk
      use con_data
      use con_stats
      include 'mpif.h'
      real fs(nnx,iys:iye,3), fr(nnx,iys:iye,3)
      integer istatus(mpi_status_size)
      real wfi_sum(0:nnz)
c
c --------- Send updated (u,v,w) (from comp1)
c           to processor below the current myid to
c           get the contravariant flux velocities.
c
      nb = myid - ncpu_s
      nt = myid + ncpu_s
      if(iss .eq. 0) then
         nb = mpi_proc_null
      endif
      if(ise .eq. numprocs-1) then
         nt = mpi_proc_null
      endif
      nsend = 3*nnx*(iye + 1 - iys)
      nrecv = nsend
      do j=iys,iye
      do i=1,nnx
         fs(i,j,1) = u(i,j,izs)
         fs(i,j,2) = v(i,j,izs)
         fs(i,j,3) = w(i,j,izs)
      enddo
      enddo
      call mpi_sendrecv(
     +     fs(1,iys,1),nsend,mpi_real8,nb,2,
     +     fr(1,iys,1),nrecv,mpi_real8,nt,2,
     +     mpi_comm_world,istatus,ierr)
      if(ise .ne. numprocs-1) then
         do j=iys,iye
         do i=1,nnx
            u(i,j,ize+1)  = fr(i,j,1)
            v(i,j,ize+1)  = fr(i,j,2)
            w(i,j,ize+1)  = fr(i,j,3)
         enddo
         enddo
      endif

c
c ---------- get mean of wfi
c
      do k=0,nnz
         wfi_sum(k) = 0.0
      enddo
c
      do k=izs,ize
         km1 = k - 1
         kp1 = k + 1
         if(k .eq. nnz) then
c
c ------------ don't worry about upper bc for wf,
c              correct value is used in psolver
c
           do j=iys,iye
           do i=1,nnx
              wfi(i,j,k) = wfbc(i,j,1)
              ufi(i,j,k) = u(i,j,k)
              vfi(i,j,k) = v(i,j,k)
           enddo
           enddo
         else
           do j=iys,iye
           do i=1,nnx
              ufi(i,j,k) = u(i,j,k)
              vfi(i,j,k) = v(i,j,k)
              wf_k       = w(i,j,k)*gm(i,j,k,4)  +
     +                     u(i,j,k)*gm(i,j,k,2)  +
     +                     v(i,j,k)*gm(i,j,k,3) 
              wf_kp1     = w(i,j,kp1)*gm(i,j,kp1,4)  +
     +                     u(i,j,kp1)*gm(i,j,kp1,2)  +
     +                     v(i,j,kp1)*gm(i,j,kp1,3) 
              wfi(i,j,k) = wf_k*weitm(k) + wf_kp1*weit(k)
           enddo
           enddo
         endif
c
         do j=iys,iye
         do i=1,nnx
            wfi_sum(k) = wfi_sum(k) + wfi(i,j,k)
         enddo
         enddo
         wfi_sum(k) = wfi_sum(k)*fnxy
c
c --------- linear extrapolation to get wfi surface value
c
         if(k == 1) then
            w1 = -dzw(k)/(dzw(k) + dzw(kp1))
            w2 = 1.0 - w1
            do j=iys,iye
            do i=1,nnx
               ufi(i,j,km1) = u(i,j,k)
               vfi(i,j,km1) = v(i,j,k)
               wf_k         = w(i,j,k)*gm(i,j,k,4)  +
     +                        u(i,j,k)*gm(i,j,k,2)  +
     +                        v(i,j,k)*gm(i,j,k,3) 
               wf_kp1       = w(i,j,kp1)*gm(i,j,kp1,4)  +
     +                        u(i,j,kp1)*gm(i,j,kp1,2)  +
     +                        v(i,j,kp1)*gm(i,j,kp1,3) 
               wfi(i,j,km1) = wf_k*w2 + wf_kp1*w1
               wfi_sum(km1) = wfi_sum(km1) + wfi(i,j,km1)
            enddo
            enddo
            wfi_sum(km1) = wfi_sum(km1)*fnxy
         endif
c
      enddo
c
      call mpi_sum_z(wfi_sum(0),i_root,myid,nnz+1,1)
c
c -------  take out mean here
c
      do k=izs,ize
         do j=iys,iye
         do i=1,nnx
            wfi(i,j,k) = wfi(i,j,k) - wfi_sum(k)
         enddo
         enddo
      enddo
c
      if(izs == 1) then
         k = 0
         do j=iys,iye
         do i=1,nnx
            wfi(i,j,k) = wfi(i,j,k) - wfi_sum(k)
         enddo
         enddo
      endif
c
c     if(izs .eq. 1) then
c       write(nprt,7002) istep
c7002   format(' 7002 rhs flux istage = ',i3)
c       k = 1
c       km1 = k - 1
c       kp1 = k + 1
c       j   = iys
c       write(nprt,7001) (i,wfi(i,j,km1), wfi(i,j,k), wfi(i,j,k+1),
c    +                      ufi(i,j,k), vfi(i,j,k),i=1,nnx)
c7001   format(' 7001 rhs_flux',/,
c    +  ' i ',5x,' wfi 0',5x,' wfi 1',5x,' wfi 2',5x,
c    +  ' ufi 1 ',5x,' vfi ',5x,/,(i5,5e15.6))
c     endif
c
      return
      end
      subroutine rhs_uvw(istep)
c
c ---------- get right hand sides of (u,v,w) equations
c            for pencil size (nnx, iys:iye, izs:ize).
c            rhs are (r1,r2,r3)/J, but the field
c            variables used to build rhs are (u,v,w,e,theta).
c
      use pars
      use fields
      use fftwk
      use con_data
      use con_stats
c
      real fntd(nnx,iys:iye,izs:ize)
      real fnt1(nnx,iys:iye), fnt2(nnx,iys:iye), fnt3(nnx,iys:iye)
      real fnt4(nnx,iys:iye), fnt5(nnx,iys:iye)
      real tauij(nnx,iys:iye,6,2), sij(nnx,iys:iye,6)
      real pm_z(1:nnz)
c
      if(iskew .eq. 0) then
         upfac = 0.5
      else 
         upfac = 1.0
      endif
c
c --------- special first grid point arrays, to avoid repeating
c
      if(izs .eq. 1) then
         k   = 1
         kp1 = k + 1
         km1 = k - 1
         do j=iys,iye
         do i=1,nnx
            fnt4(i,j) = weit(k)*gm(i,j,kp1,1) + weitm(k)*gm(i,j,k,1)
            fnt4(i,j) = 2.0*(weit(k)*vis_m(i,j,kp1) + 
     +                       weitm(k)*vis_m(i,j,k))*fnt4(i,j)
            fnt5(i,j) = weit(km1)*gm(i,j,k,1) + weitm(km1)*gm(i,j,km1,1)
         enddo
         enddo
      endif
c
      do k=izs,ize
c
      km1 = k - 1
      kp1 = k + 1
c
c ------------ geostrophic wind
c
c     u_geo = -fcor*vg(k)
c     v_geo =  fcor*(ug(k)-ugal)
c
c ----------- for wind tunnel type simulations, account for box height
c
      u_geo = dpdx_con_z
      v_geo = 0.0
c
      do j=iys,iye
      do i=1,nnx
c
c ----------- boussinesq approximation for buoyancy (no hydro static piece)
c
         w_buy = batag*(t(i,j,1,k) - t00)
c
c ------------ coriolis, vertical and horizontal components
c
         u_cor     =  fcor*v(i,j,k) - fcor_h*w(i,j,k)
         v_cor     = -fcor*u(i,j,k)
         w_cor     =  fcor_h*u(i,j,k)
c
c ------------ build rhs times 1/J
c
         r1(i,j,k) = (u_cor + u_geo)*gm(i,j,k,1)
         r2(i,j,k) = (v_cor + v_geo)*gm(i,j,k,1)
         r3(i,j,k) = (w_cor + w_buy)*gm(i,j,k,1)
      enddo
      enddo
c
      enddo ! end z-loop
c
c ---------- advection for skew symmetric form
c
      if(iskew .eq. 0) then    ! skew symmetric form no grid speed
c
      do k=izs,ize
      km1 = k - 1
      kp1 = k + 1
      do j=iys,iye
      do i=1,nnx
         uzm     = (u(i,j,k) - u(i,j,km1))*dzu_i(k)
         vzm     = (v(i,j,k) - v(i,j,km1))*dzu_i(k)
         wzm     = (w(i,j,k) - w(i,j,km1))*dzu_i(k)
         uz      = (u(i,j,kp1) - u(i,j,k))*dzu_i(kp1)
         vz      = (v(i,j,kp1) - v(i,j,k))*dzu_i(kp1)
         wz      = (w(i,j,kp1) - w(i,j,k))*dzu_i(kp1)
c
         u_avg_u = u(i,j,k)*weitm(k) + u(i,j,kp1)*weit(k)
         v_avg_u = v(i,j,k)*weitm(k) + v(i,j,kp1)*weit(k)
         w_avg_u = w(i,j,k)*weitm(k) + w(i,j,kp1)*weit(k)
         u_avg_l = u(i,j,k)*weit(km1) + u(i,j,km1)*weitm(km1)
         v_avg_l = v(i,j,k)*weit(km1) + v(i,j,km1)*weitm(km1)
         w_avg_l = w(i,j,k)*weit(km1) + w(i,j,km1)*weitm(km1)
c
         u_adv = 0.5*(uf(i,j,k)*ux(i,j,k) + vf(i,j,k)*uy(i,j,k) +
     +           (wf(i,j,k)*u_avg_u - wf(i,j,km1)*u_avg_l)*dzw_i(k)) +
     +           0.25*(wf(i,j,k)*uz + wf(i,j,km1)*uzm) 
         v_adv = 0.5*(uf(i,j,k)*vx(i,j,k) + vf(i,j,k)*vy(i,j,k) +
     +           (wf(i,j,k)*v_avg_u - wf(i,j,km1)*v_avg_l)*dzw_i(k)) +
     +           0.25*(wf(i,j,k)*vz + wf(i,j,km1)*vzm) 
         w_adv = 0.5*(uf(i,j,k)*wx(i,j,k) + vf(i,j,k)*wy(i,j,k) +
     +           (wf(i,j,k)*w_avg_u - wf(i,j,km1)*w_avg_l)*dzw_i(k)) +
     +           0.25*(wf(i,j,k)*wz + wf(i,j,km1)*wzm) 
c
c ------------ totals
c
         r1(i,j,k) = r1(i,j,k) - u_adv
         r2(i,j,k) = r2(i,j,k) - v_adv 
         r3(i,j,k) = r3(i,j,k) - w_adv 
      enddo
      enddo
      enddo ! end z-loop
c
      else   ! flux form with grid speed
c
      do k=izs,ize
      km1 = k - 1
      kp1 = k + 1
      do j=iys,iye
      do i=1,nnx
c
         u_avg_u = u(i,j,k)*weitm(k) + u(i,j,kp1)*weit(k)
         v_avg_u = v(i,j,k)*weitm(k) + v(i,j,kp1)*weit(k)
         w_avg_u = w(i,j,k)*weitm(k) + w(i,j,kp1)*weit(k)
         u_avg_l = u(i,j,k)*weit(km1) + u(i,j,km1)*weitm(km1)
         v_avg_l = v(i,j,k)*weit(km1) + v(i,j,km1)*weitm(km1)
         w_avg_l = w(i,j,k)*weit(km1) + w(i,j,km1)*weitm(km1)
c
         wflx_u  = wf(i,j,k) - gm(i,j,k,5)
         wflx_l  = wf(i,j,km1) - gm(i,j,km1,5)
         u_adv   = (wflx_u*u_avg_u - wflx_l*u_avg_l)*dzw_i(k)
         v_adv   = (wflx_u*v_avg_u - wflx_l*v_avg_l)*dzw_i(k)
         w_adv   = (wflx_u*w_avg_u - wflx_l*w_avg_l)*dzw_i(k)
c
c ------------ totals
c
         r1(i,j,k) = r1(i,j,k) - u_adv
         r2(i,j,k) = r2(i,j,k) - v_adv 
         r3(i,j,k) = r3(i,j,k) - w_adv 
      enddo
      enddo
      enddo ! end z-loop
c
      endif ! end of skew check
c
c ----------- SGS cell center x-contributions + resolved fluxes
c             advective terms can be written in skew symmetric 
c             or flux form. treat first point special if at lower boundary,
c             average boundary and upper cell tau flux
c
      do k=izs,ize
         if(k .eq. 1) then
            call strain_u(sij,k)
            do j=iys,iye
            do i=1,nnx
               tauij(i,j,1,2) = 0.5*(fnt4(i,j)*sij(i,j,1) - 
     +                               t11bc(i,j)*fnt5(i,j))
               tauij(i,j,2,2) = 0.5*(fnt4(i,j)*sij(i,j,2) - 
     +                               t12bc(i,j)*fnt5(i,j))
               tauij(i,j,3,2) = 0.5*(fnt4(i,j)*sij(i,j,3) - 
     +                               t13bc(i,j)*fnt5(i,j))
            enddo
            enddo
         else
            call strain_c(sij,k)
            do j=iys,iye
            do i=1,nnx
               tauij(i,j,1,2) = 2.0*vis_m(i,j,k)*sij(i,j,1)*gm(i,j,k,1)
               tauij(i,j,2,2) = 2.0*vis_m(i,j,k)*sij(i,j,2)*gm(i,j,k,1)
               tauij(i,j,3,2) = 2.0*vis_m(i,j,k)*sij(i,j,3)*gm(i,j,k,1)
            enddo
            enddo
         endif
         do j=iys,iye
         do i=1,nnx
            fnt1(i,j) = tauij(i,j,1,2) - upfac*uf(i,j,k)*u(i,j,k)
            fnt2(i,j) = tauij(i,j,2,2) - upfac*uf(i,j,k)*v(i,j,k)
            fnt3(i,j) = tauij(i,j,3,2) - upfac*uf(i,j,k)*w(i,j,k)
         enddo
         enddo
         call xderivp(fnt1(1,iys),trigx(1,1),xk(1),nnx,iys,iye)
         call xderivp(fnt2(1,iys),trigx(1,1),xk(1),nnx,iys,iye)
         call xderivp(fnt3(1,iys),trigx(1,1),xk(1),nnx,iys,iye)
         do j=iys,iye
         do i=1,nnx
            r1(i,j,k) = r1(i,j,k) + fnt1(i,j)
            r2(i,j,k) = r2(i,j,k) + fnt2(i,j)
            r3(i,j,k) = r3(i,j,k) + fnt3(i,j)
         enddo
         enddo
      enddo
c
c ----------- SGS z-contributions
c
      if(izs .eq. 1) then
         do j=iys,iye
         do i=1,nnx
            tauij(i,j,1,2) = -t11bc(i,j)
            tauij(i,j,2,2) = -t12bc(i,j)
            tauij(i,j,3,2) = -t13bc(i,j)
            tauij(i,j,4,2) = -t22bc(i,j)
            tauij(i,j,5,2) = -t23bc(i,j)
            tauij(i,j,6,2) = -t33bc(i,j)
         enddo
         enddo
      else
         call strain_u(sij,izs-1)
         do n=1,6
         do j=iys,iye
         do i=1,nnx
            fac   = 2.0*(weit(izs-1)*vis_m(i,j,izs) + 
     +              weitm(izs-1)*vis_m(i,j,izs-1))
            tauij(i,j,n,2) = fac*sij(i,j,n)
         enddo
         enddo
         enddo
      endif
      do k=izs,ize
         kp1 = k + 1
         km1 = k - 1
         do n=1,6
         do j=iys,iye
         do i=1,nnx
            tauij(i,j,n,1) = tauij(i,j,n,2)
         enddo
         enddo
         enddo
         call strain_u(sij,k)
         do n=1,6
         do j=iys,iye
         do i=1,nnx
            fac   = 2.0*(weit(k)*vis_m(i,j,kp1) + 
     +                   weitm(k)*vis_m(i,j,k))
            tauij(i,j,n,2) = fac*sij(i,j,n)
         enddo
         enddo
         enddo
         uw_sum = 0.0
         vw_sum = 0.0
         ww_sum = 0.0
         do j=iys,iye
         do i=1,nnx
            gm_xu     = weit(k)*gm(i,j,kp1,1)*gm(i,j,kp1,2) + 
     +                  weitm(k)*gm(i,j,k,1)*gm(i,j,k,2)  
            gm_xl     = weit(km1)*gm(i,j,k,1)*gm(i,j,k,2) + 
     +                  weitm(km1)*gm(i,j,km1,1)*gm(i,j,km1,2)  
            gm_yu     = weit(k)*gm(i,j,kp1,1)*gm(i,j,kp1,3) + 
     +                  weitm(k)*gm(i,j,k,1)*gm(i,j,k,3)  
            gm_yl     = weit(km1)*gm(i,j,k,1)*gm(i,j,k,3) + 
     +                  weitm(km1)*gm(i,j,km1,1)*gm(i,j,km1,3)  
            tau_up    = tauij(i,j,1,2)*gm_xu + tauij(i,j,2,2)*gm_yu +
     +                  tauij(i,j,3,2)
            tau_lo    = tauij(i,j,1,1)*gm_xl + tauij(i,j,2,1)*gm_yl +
     +                  tauij(i,j,3,1)
            uw_sum    = uw_sum + tau_up
            r1(i,j,k) = r1(i,j,k) + (tau_up - tau_lo)*dzw_i(k)
            tau_up    = tauij(i,j,2,2)*gm_xu + tauij(i,j,4,2)*gm_yu +
     +                  tauij(i,j,5,2)
            tau_lo    = tauij(i,j,2,1)*gm_xl + tauij(i,j,4,1)*gm_yl +
     +                  tauij(i,j,5,1)
            vw_sum    = vw_sum + tau_up
            r2(i,j,k) = r2(i,j,k) + (tau_up - tau_lo)*dzw_i(k)
            tau_up    = tauij(i,j,3,2)*gm_xu + tauij(i,j,5,2)*gm_yu +
     +                  tauij(i,j,6,2)
            tau_lo    = tauij(i,j,3,1)*gm_xl + tauij(i,j,5,1)*gm_yl +
     +                  tauij(i,j,6,1)
            ww_sum    = ww_sum + tau_up
            r3(i,j,k) = r3(i,j,k) + (tau_up - tau_lo)*dzw_i(k)
         enddo
         enddo
c
c -------- save SGS fluxes for printout
c
      if(istep .eq. 1) then
         tr_tau(k) = 0.0
         do j=iys,iye
         do i=1,nnx
            ufluc    = (u(i,j,kp1) - uxym(kp1))*weit(k) +
     +                 (u(i,j,k) - uxym(k))*weitm(k)
            vfluc    = (v(i,j,kp1) - vxym(kp1))*weit(k) +
     +                 (v(i,j,k) - vxym(k))*weitm(k)
            tr_tau(k) = tr_tau(k) -
     +                 tauij(i,j,3,2)*ufluc - tauij(i,j,5,2)*vfluc
         enddo
         enddo
         uwsb(k)   = -uw_sum*fnxy
         vwsb(k)   = -vw_sum*fnxy
         wwsb(k)   = -ww_sum*fnxy
         tr_tau(k) = tr_tau(k)*fnxy
      endif
c
c ---------- end z loop
c
      enddo
c
c ---------- SGS fluxes tau_12, tau_22, tau_23 that depend on 
c            y-derivatives at cell centers. special treatment
c            of first point at lower boundary. assumes strain
c            at k = 1 is at upper face, see strain_12,_22,_23
c
      do k=izs,ize
         call strain_12(sij(1,iys,1),k)
         if(k .eq. 1) then
            do j=iys,iye
            do i=1,nnx
               tau_c       = 0.5*(fnt4(i,j)*sij(i,j,1) - 
     +                            t12bc(i,j)*fnt5(i,j))
               fntd(i,j,k) = tau_c  - upfac*vf(i,j,k)*u(i,j,k)
            enddo
            enddo
         else
            do j=iys,iye
            do i=1,nnx
               tau_c       = 2.0*gm(i,j,k,1)*vis_m(i,j,k)*sij(i,j,1)
               fntd(i,j,k) = tau_c - upfac*vf(i,j,k)*u(i,j,k)
            enddo
            enddo
         endif
      enddo
      call yd_mpi(fntd(1,iys,izs),trigx(1,2),yk(1),
     +           nnx,nny,ixs,ixe,ix_s,ix_e,
     +           iys,iye,iy_s,iy_e,izs,ize,myid,ncpu_s,numprocs)
      do k=izs,ize
         do j=iys,iye
         do i=1,nnx
            r1(i,j,k)   = r1(i,j,k) + fntd(i,j,k)
         enddo
         enddo
      enddo
c
      do k=izs,ize
         call strain_22(sij(1,iys,1),k)
         if(k .eq. 1) then
            do j=iys,iye
            do i=1,nnx
               tau_c       = 0.5*(fnt4(i,j)*sij(i,j,1) - 
     +                            t22bc(i,j)*fnt5(i,j))
               fntd(i,j,k) = tau_c  - upfac*vf(i,j,k)*v(i,j,k)
            enddo
            enddo
         else
            do j=iys,iye
            do i=1,nnx
               tau_c       = 2.0*gm(i,j,k,1)*vis_m(i,j,k)*sij(i,j,1)
               fntd(i,j,k) = tau_c - upfac*vf(i,j,k)*v(i,j,k)
            enddo
            enddo
         endif
      enddo
      call yd_mpi(fntd(1,iys,izs),trigx(1,2),yk(1),
     +           nnx,nny,ixs,ixe,ix_s,ix_e,
     +           iys,iye,iy_s,iy_e,izs,ize,myid,ncpu_s,numprocs)
      do k=izs,ize
         do j=iys,iye
         do i=1,nnx
            r2(i,j,k)   = r2(i,j,k) + fntd(i,j,k)
         enddo
         enddo
      enddo
c
      do k=izs,ize
         call strain_23(sij(1,iys,1),k)
         if(k .eq. 1) then
            do j=iys,iye
            do i=1,nnx
               tau_c       = 0.5*(fnt4(i,j)*sij(i,j,1) - 
     +                            t23bc(i,j)*fnt5(i,j))
               fntd(i,j,k) = tau_c - upfac*vf(i,j,k)*w(i,j,k)
            enddo
            enddo
         else
            do j=iys,iye
            do i=1,nnx
               tau_c       = 2.0*gm(i,j,k,1)*vis_m(i,j,k)*sij(i,j,1)
               fntd(i,j,k) = tau_c - upfac*vf(i,j,k)*w(i,j,k)
            enddo
            enddo
         endif
      enddo
      call yd_mpi(fntd(1,iys,izs),trigx(1,2),yk(1),
     +           nnx,nny,ixs,ixe,ix_s,ix_e,
     +           iys,iye,iy_s,iy_e,izs,ize,myid,ncpu_s,numprocs)
      do k=izs,ize
         do j=iys,iye
         do i=1,nnx
            r3(i,j,k) = r3(i,j,k) + fntd(i,j,k)
         enddo
         enddo
      enddo
c
c --------- get average of r3 as estimate of mean pressure gradient
c           from turbulence and add it to right hand sides of all equations
c
      do k=1,nnz
         pm_z(k) = 0.0
      enddo
      do k=izs,ize
         do j=iys,iye
         do i=1,nnx
            pm_z(k) = pm_z(k) + r3(i,j,k)
         enddo
         enddo
         pm_z(k) = pm_z(k)*fnxy
      enddo
      call mpi_sum_z(pm_z,i_root,myid,nnz,1)
c
      do k=izs,ize
         do j=iys,iye
         do i=1,nnx
            r3(i,j,k) = r3(i,j,k) - pm_z(k)
         enddo
         enddo
      enddo
c
c ------- integrate p-gradient to get values at wf points
c
      pm(0) = p_surf
      do k=1,nnz
         pm(k) = pm(k-1) + pm_z(k)*dzw(k)
      enddo
c
      if(no_pgrad == 1) then
c
c --------- add mean p-gradients to right hand sides
c           of u and v equations using non-conservative form
c           to avoid specifying the surface pressure
c
      do k=izs,ize
         do j=iys,iye
         do i=1,nnx
            r1(i,j,k) = r1(i,j,k) - pm_z(k)*gm(i,j,k,1)*gm(i,j,k,2)
            r2(i,j,k) = r2(i,j,k) - pm_z(k)*gm(i,j,k,1)*gm(i,j,k,3)
         enddo
         enddo
      enddo
c
      endif ! check for no mean dpdx in (u,v)
c
c --------- leave with (r1,r2,r3)/J
c
      return
      end
      subroutine rhs_uvw_dns(istep)
c
c ---------- get right hand sides of (u,v,w) equations
c            for pencil size (nnx, iys:iye, izs:ize).
c            rhs are (r1,r2,r3)/J, but the field
c            variables used to build rhs are (u,v,w,e,theta).
c
      use pars
      use fields
      use fftwk
      use con_data
      use con_stats
c
      real fntd(nnx,iys:iye,izs:ize)
      real fnt1(nnx,iys:iye), fnt2(nnx,iys:iye), fnt3(nnx,iys:iye)
      real fnt4(nnx,iys:iye), fnt5(nnx,iys:iye)
      real tauij(nnx,iys:iye,6,2), sij(nnx,iys:iye,6)
      real pm_z(1:nnz)
      real sfc_flx(2)
c
      if(iskew .eq. 0) then
         upfac = 0.5
      else 
         upfac = 1.0
      endif
      sfc_flx = 0.0
c
c --------- special first grid point arrays, to avoid repeating
c
      if(izs .eq. 1) then
         k   = 1
         kp1 = k + 1
         km1 = k - 1
         do j=iys,iye
         do i=1,nnx
            fnt4(i,j) = weit(k)*gm(i,j,kp1,1) + weitm(k)*gm(i,j,k,1)
            fnt4(i,j) = 2.0*(weit(k)*vis_m(i,j,kp1) + 
     +                       weitm(k)*vis_m(i,j,k))*fnt4(i,j)
            fnt5(i,j) = weit(km1)*gm(i,j,k,1) + weitm(km1)*gm(i,j,km1,1)
         enddo
         enddo
      endif
c
      do k=izs,ize
c
      km1 = k - 1
      kp1 = k + 1
c
c ------------ geostrophic wind
c
c     u_geo = -fcor*vg(k)
c     v_geo =  fcor*(ug(k)-ugal)
c
c ----------- for wind tunnel type simulations, account for box height
c
      u_geo = dpdx_con_z
      v_geo = 0.0
c
      do j=iys,iye
      do i=1,nnx
c
c ----------- boussinesq approximation for buoyancy (no hydro static piece)
c
         w_buy = batag*(t(i,j,1,k) - t00)
c
c ------------ coriolis, vertical and horizontal components
c
         u_cor     =  fcor*v(i,j,k) - fcor_h*w(i,j,k)
         v_cor     = -fcor*u(i,j,k)
         w_cor     =  fcor_h*u(i,j,k)
c
c ------------ build rhs times 1/J
c
         r1(i,j,k) = (u_cor + u_geo)*gm(i,j,k,1)
         r2(i,j,k) = (v_cor + v_geo)*gm(i,j,k,1)
         r3(i,j,k) = (w_cor + w_buy)*gm(i,j,k,1)
      enddo
      enddo
c
      enddo ! end z-loop
c
c ---------- advection for skew symmetric form
c
      if(iskew .eq. 0) then    ! skew symmetric form no grid speed
c
      do k=izs,ize
      km1 = k - 1
      kp1 = k + 1
      do j=iys,iye
      do i=1,nnx
         uzm     = (u(i,j,k) - u(i,j,km1))*dzu_i(k)
         vzm     = (v(i,j,k) - v(i,j,km1))*dzu_i(k)
         wzm     = (w(i,j,k) - w(i,j,km1))*dzu_i(k)
         uz      = (u(i,j,kp1) - u(i,j,k))*dzu_i(kp1)
         vz      = (v(i,j,kp1) - v(i,j,k))*dzu_i(kp1)
         wz      = (w(i,j,kp1) - w(i,j,k))*dzu_i(kp1)
c
         u_avg_u = u(i,j,k)*weitm(k) + u(i,j,kp1)*weit(k)
         v_avg_u = v(i,j,k)*weitm(k) + v(i,j,kp1)*weit(k)
         w_avg_u = w(i,j,k)*weitm(k) + w(i,j,kp1)*weit(k)
         u_avg_l = u(i,j,k)*weit(km1) + u(i,j,km1)*weitm(km1)
         v_avg_l = v(i,j,k)*weit(km1) + v(i,j,km1)*weitm(km1)
         w_avg_l = w(i,j,k)*weit(km1) + w(i,j,km1)*weitm(km1)
c
         u_adv = 0.5*(uf(i,j,k)*ux(i,j,k) + vf(i,j,k)*uy(i,j,k) +
     +           (wf(i,j,k)*u_avg_u - wf(i,j,km1)*u_avg_l)*dzw_i(k)) +
     +           0.25*(wf(i,j,k)*uz + wf(i,j,km1)*uzm) 
         v_adv = 0.5*(uf(i,j,k)*vx(i,j,k) + vf(i,j,k)*vy(i,j,k) +
     +           (wf(i,j,k)*v_avg_u - wf(i,j,km1)*v_avg_l)*dzw_i(k)) +
     +           0.25*(wf(i,j,k)*vz + wf(i,j,km1)*vzm) 
         w_adv = 0.5*(uf(i,j,k)*wx(i,j,k) + vf(i,j,k)*wy(i,j,k) +
     +           (wf(i,j,k)*w_avg_u - wf(i,j,km1)*w_avg_l)*dzw_i(k)) +
     +           0.25*(wf(i,j,k)*wz + wf(i,j,km1)*wzm) 
c
c ------------ totals
c
         r1(i,j,k) = r1(i,j,k) - u_adv
         r2(i,j,k) = r2(i,j,k) - v_adv 
         r3(i,j,k) = r3(i,j,k) - w_adv 
      enddo
      enddo
      enddo ! end z-loop
c
      else   ! flux form with grid speed
c
      do k=izs,ize
      km1 = k - 1
      kp1 = k + 1
      do j=iys,iye
      do i=1,nnx
c
         u_avg_u = u(i,j,k)*weitm(k) + u(i,j,kp1)*weit(k)
         v_avg_u = v(i,j,k)*weitm(k) + v(i,j,kp1)*weit(k)
         w_avg_u = w(i,j,k)*weitm(k) + w(i,j,kp1)*weit(k)
         u_avg_l = u(i,j,k)*weit(km1) + u(i,j,km1)*weitm(km1)
         v_avg_l = v(i,j,k)*weit(km1) + v(i,j,km1)*weitm(km1)
         w_avg_l = w(i,j,k)*weit(km1) + w(i,j,km1)*weitm(km1)
c
         wflx_u  = wf(i,j,k) - gm(i,j,k,5)
         wflx_l  = wf(i,j,km1) - gm(i,j,km1,5)
         u_adv   = (wflx_u*u_avg_u - wflx_l*u_avg_l)*dzw_i(k)
         v_adv   = (wflx_u*v_avg_u - wflx_l*v_avg_l)*dzw_i(k)
         w_adv   = (wflx_u*w_avg_u - wflx_l*w_avg_l)*dzw_i(k)
c
c ------------ totals
c
         r1(i,j,k) = r1(i,j,k) - u_adv
         r2(i,j,k) = r2(i,j,k) - v_adv 
         r3(i,j,k) = r3(i,j,k) - w_adv 
      enddo
      enddo
      enddo ! end z-loop
c
      endif ! end of skew check
c
c ----------- SGS cell center x-contributions + resolved fluxes
c             advective terms can be written in skew symmetric 
c             or flux form. treat first point special if at lower boundary,
c             average boundary and upper cell tau flux
c
      do k=izs,ize
!         if(k .eq. 1) then
!            call strain_u(sij,k)
!            do j=iys,iye
!            do i=1,nnx
!               tauij(i,j,1,2) = 0.5*(fnt4(i,j)*sij(i,j,1) - 
!     +                               t11bc(i,j)*fnt5(i,j))
!               tauij(i,j,2,2) = 0.5*(fnt4(i,j)*sij(i,j,2) - 
!     +                               t12bc(i,j)*fnt5(i,j))
!               tauij(i,j,3,2) = 0.5*(fnt4(i,j)*sij(i,j,3) - 
!     +                               t13bc(i,j)*fnt5(i,j))
!            enddo
!            enddo
!         else
            call strain_c_dns(sij,k)
            do j=iys,iye
            do i=1,nnx
               tauij(i,j,1,2) = 2.0*vis_m(i,j,k)*sij(i,j,1)*gm(i,j,k,1)
               tauij(i,j,2,2) = 2.0*vis_m(i,j,k)*sij(i,j,2)*gm(i,j,k,1)
               tauij(i,j,3,2) = 2.0*vis_m(i,j,k)*sij(i,j,3)*gm(i,j,k,1)
            enddo
            enddo
!         endif
         do j=iys,iye
         do i=1,nnx
            fnt1(i,j) = tauij(i,j,1,2) - upfac*uf(i,j,k)*u(i,j,k)
            fnt2(i,j) = tauij(i,j,2,2) - upfac*uf(i,j,k)*v(i,j,k)
            fnt3(i,j) = tauij(i,j,3,2) - upfac*uf(i,j,k)*w(i,j,k)
         enddo
         enddo
         call xderivp(fnt1(1,iys),trigx(1,1),xk(1),nnx,iys,iye)
         call xderivp(fnt2(1,iys),trigx(1,1),xk(1),nnx,iys,iye)
         call xderivp(fnt3(1,iys),trigx(1,1),xk(1),nnx,iys,iye)
         do j=iys,iye
         do i=1,nnx
            r1(i,j,k) = r1(i,j,k) + fnt1(i,j)
            r2(i,j,k) = r2(i,j,k) + fnt2(i,j)
            r3(i,j,k) = r3(i,j,k) + fnt3(i,j)
         enddo
         enddo
      enddo
c
c ----------- SGS z-contributions
c
!      if(izs .eq. 1) then
!         do j=iys,iye
!         do i=1,nnx
!            tauij(i,j,1,2) = -t11bc(i,j)
!            tauij(i,j,2,2) = -t12bc(i,j)
!            tauij(i,j,3,2) = -t13bc(i,j)
!            tauij(i,j,4,2) = -t22bc(i,j)
!            tauij(i,j,5,2) = -t23bc(i,j)
!            tauij(i,j,6,2) = -t33bc(i,j)
!         enddo
!         enddo
!      else
         call strain_u(sij,izs-1)  !NOTE: strain_u does not need dns revision -- doesn't treat k=1 specially
         do n=1,6
         do j=iys,iye
         do i=1,nnx
            fac   = 2.0*(weit(izs-1)*vis_m(i,j,izs) + 
     +              weitm(izs-1)*vis_m(i,j,izs-1))
            tauij(i,j,n,2) = fac*sij(i,j,n)
         enddo
         enddo
         enddo
!      endif
      do k=izs,ize
         kp1 = k + 1
         km1 = k - 1
         do n=1,6
         do j=iys,iye
         do i=1,nnx
            tauij(i,j,n,1) = tauij(i,j,n,2)
         enddo
         enddo
         enddo
         call strain_u(sij,k)
         do n=1,6
         do j=iys,iye
         do i=1,nnx
            fac   = 2.0*(weit(k)*vis_m(i,j,kp1) + 
     +                   weitm(k)*vis_m(i,j,k))
            tauij(i,j,n,2) = fac*sij(i,j,n)
         enddo
         enddo
         enddo
         uw_sum = 0.0
         vw_sum = 0.0
         ww_sum = 0.0
         do j=iys,iye
         do i=1,nnx
            gm_xu     = weit(k)*gm(i,j,kp1,1)*gm(i,j,kp1,2) + 
     +                  weitm(k)*gm(i,j,k,1)*gm(i,j,k,2)  
            gm_xl     = weit(km1)*gm(i,j,k,1)*gm(i,j,k,2) + 
     +                  weitm(km1)*gm(i,j,km1,1)*gm(i,j,km1,2)  
            gm_yu     = weit(k)*gm(i,j,kp1,1)*gm(i,j,kp1,3) + 
     +                  weitm(k)*gm(i,j,k,1)*gm(i,j,k,3)  
            gm_yl     = weit(km1)*gm(i,j,k,1)*gm(i,j,k,3) + 
     +                  weitm(km1)*gm(i,j,km1,1)*gm(i,j,km1,3)  
            tau_up    = tauij(i,j,1,2)*gm_xu + tauij(i,j,2,2)*gm_yu +
     +                  tauij(i,j,3,2)
            tau_lo    = tauij(i,j,1,1)*gm_xl + tauij(i,j,2,1)*gm_yl +
     +                  tauij(i,j,3,1)
            uw_sum    = uw_sum + tau_up
            r1(i,j,k) = r1(i,j,k) + (tau_up - tau_lo)*dzw_i(k)

            if (k==1) then
            sfc_flx(1) = sfc_flx(1) + tau_lo
            end if

            tau_up    = tauij(i,j,2,2)*gm_xu + tauij(i,j,4,2)*gm_yu +
     +                  tauij(i,j,5,2)
            tau_lo    = tauij(i,j,2,1)*gm_xl + tauij(i,j,4,1)*gm_yl +
     +                  tauij(i,j,5,1)
            vw_sum    = vw_sum + tau_up

            if (k==1) then
            sfc_flx(2) = sfc_flx(2) + tau_lo
            end if

            r2(i,j,k) = r2(i,j,k) + (tau_up - tau_lo)*dzw_i(k)
            tau_up    = tauij(i,j,3,2)*gm_xu + tauij(i,j,5,2)*gm_yu +
     +                  tauij(i,j,6,2)
            tau_lo    = tauij(i,j,3,1)*gm_xl + tauij(i,j,5,1)*gm_yl +
     +                  tauij(i,j,6,1)
            ww_sum    = ww_sum + tau_up
            r3(i,j,k) = r3(i,j,k) + (tau_up - tau_lo)*dzw_i(k)

         enddo
         enddo
c
c -------- save SGS fluxes for printout
c
      if(istep .eq. 1) then
         tr_tau(k) = 0.0
         do j=iys,iye
         do i=1,nnx
            ufluc    = (u(i,j,kp1) - uxym(kp1))*weit(k) +
     +                 (u(i,j,k) - uxym(k))*weitm(k)
            vfluc    = (v(i,j,kp1) - vxym(kp1))*weit(k) +
     +                 (v(i,j,k) - vxym(k))*weitm(k)
            tr_tau(k) = tr_tau(k) -
     +                 tauij(i,j,3,2)*ufluc - tauij(i,j,5,2)*vfluc
         enddo
         enddo
         uwsb(k)   = -uw_sum*fnxy
         vwsb(k)   = -vw_sum*fnxy
         wwsb(k)   = -ww_sum*fnxy
         tr_tau(k) = tr_tau(k)*fnxy
      endif

      !As an aside, compute the values uwsfc and vwsfc for output:
      if (k==1) then
         call mpi_sum_xy(sfc_flx,myid,iss,ise,2)
         uwsfc = sfc_flx(1)*fnxy
         vwsfc = sfc_flx(2)*fnxy
      end if
c
c ---------- end z loop
c
      enddo
c
c ---------- SGS fluxes tau_12, tau_22, tau_23 that depend on 
c            y-derivatives at cell centers. special treatment
c            of first point at lower boundary. assumes strain
c            at k = 1 is at upper face, see strain_12,_22,_23
c
      do k=izs,ize
         !call strain_12(sij(1,iys,1),k)
         call strain_12_dns(sij(1,iys,1),k)
!         if(k .eq. 1) then
!            do j=iys,iye
!            do i=1,nnx
!               tau_c       = 0.5*(fnt4(i,j)*sij(i,j,1) - 
!     +                            t12bc(i,j)*fnt5(i,j))
!               fntd(i,j,k) = tau_c  - upfac*vf(i,j,k)*u(i,j,k)
!            enddo
!            enddo
!         else
            do j=iys,iye
            do i=1,nnx
               tau_c       = 2.0*gm(i,j,k,1)*vis_m(i,j,k)*sij(i,j,1)
               fntd(i,j,k) = tau_c - upfac*vf(i,j,k)*u(i,j,k)
            enddo
            enddo
!         endif
      enddo
      call yd_mpi(fntd(1,iys,izs),trigx(1,2),yk(1),
     +           nnx,nny,ixs,ixe,ix_s,ix_e,
     +           iys,iye,iy_s,iy_e,izs,ize,myid,ncpu_s,numprocs)
      do k=izs,ize
         do j=iys,iye
         do i=1,nnx
            r1(i,j,k)   = r1(i,j,k) + fntd(i,j,k)
         enddo
         enddo
      enddo
c
      do k=izs,ize
         !call strain_22(sij(1,iys,1),k)
         call strain_22_dns(sij(1,iys,1),k)
!         if(k .eq. 1) then
!            do j=iys,iye
!            do i=1,nnx
!               tau_c       = 0.5*(fnt4(i,j)*sij(i,j,1) - 
!     +                            t22bc(i,j)*fnt5(i,j))
!               fntd(i,j,k) = tau_c  - upfac*vf(i,j,k)*v(i,j,k)
!            enddo
!            enddo
!         else
            do j=iys,iye
            do i=1,nnx
               tau_c       = 2.0*gm(i,j,k,1)*vis_m(i,j,k)*sij(i,j,1)
               fntd(i,j,k) = tau_c - upfac*vf(i,j,k)*v(i,j,k)
            enddo
            enddo
!         endif
      enddo
      call yd_mpi(fntd(1,iys,izs),trigx(1,2),yk(1),
     +           nnx,nny,ixs,ixe,ix_s,ix_e,
     +           iys,iye,iy_s,iy_e,izs,ize,myid,ncpu_s,numprocs)
      do k=izs,ize
         do j=iys,iye
         do i=1,nnx
            r2(i,j,k)   = r2(i,j,k) + fntd(i,j,k)
         enddo
         enddo
      enddo
c
      do k=izs,ize
         !call strain_23(sij(1,iys,1),k)
         call strain_23_dns(sij(1,iys,1),k)
!         if(k .eq. 1) then
!            do j=iys,iye
!            do i=1,nnx
!               tau_c       = 0.5*(fnt4(i,j)*sij(i,j,1) - 
!     +                            t23bc(i,j)*fnt5(i,j))
!               fntd(i,j,k) = tau_c - upfac*vf(i,j,k)*w(i,j,k)
!            enddo
!            enddo
!         else
            do j=iys,iye
            do i=1,nnx
               tau_c       = 2.0*gm(i,j,k,1)*vis_m(i,j,k)*sij(i,j,1)
               fntd(i,j,k) = tau_c - upfac*vf(i,j,k)*w(i,j,k)
            enddo
            enddo
!         endif
      enddo
      call yd_mpi(fntd(1,iys,izs),trigx(1,2),yk(1),
     +           nnx,nny,ixs,ixe,ix_s,ix_e,
     +           iys,iye,iy_s,iy_e,izs,ize,myid,ncpu_s,numprocs)
      do k=izs,ize
         do j=iys,iye
         do i=1,nnx
            r3(i,j,k) = r3(i,j,k) + fntd(i,j,k)
         enddo
         enddo
      enddo
c
c --------- get average of r3 as estimate of mean pressure gradient
c           from turbulence and add it to right hand sides of all equations
c
      do k=1,nnz
         pm_z(k) = 0.0
      enddo
      do k=izs,ize
         do j=iys,iye
         do i=1,nnx
            pm_z(k) = pm_z(k) + r3(i,j,k)
         enddo
         enddo
         pm_z(k) = pm_z(k)*fnxy
      enddo
      call mpi_sum_z(pm_z,i_root,myid,nnz,1)
c
      do k=izs,ize
         do j=iys,iye
         do i=1,nnx
            r3(i,j,k) = r3(i,j,k) - pm_z(k)
         enddo
         enddo
      enddo
c
c ------- integrate p-gradient to get values at wf points
c
      pm(0) = p_surf
      do k=1,nnz
         pm(k) = pm(k-1) + pm_z(k)*dzw(k)
      enddo
c
      if(no_pgrad == 1) then
c
c --------- add mean p-gradients to right hand sides
c           of u and v equations using non-conservative form
c           to avoid specifying the surface pressure
c
      do k=izs,ize
         do j=iys,iye
         do i=1,nnx
            r1(i,j,k) = r1(i,j,k) - pm_z(k)*gm(i,j,k,1)*gm(i,j,k,2)
            r2(i,j,k) = r2(i,j,k) - pm_z(k)*gm(i,j,k,1)*gm(i,j,k,3)
         enddo
         enddo
      enddo
c
      endif ! check for no mean dpdx in (u,v)
c
c --------- leave with (r1,r2,r3)/J
c
      return
      end
      subroutine rhs_uvw_old(istep)
c
c ---------- get right hand sides of (u,v,w) equations
c            for pencil size (nnx, iys:iye, izs:ize).
c            rhs are (r1,r2,r3)/J, but the field
c            variables used to build rhs are (u,v,w,e,theta).
c
      use pars
      use fields
      use fftwk
      use con_data
      use con_stats
c
      real fntd(nnx,iys:iye,izs:ize)
      real fnt1(nnx,iys:iye), fnt2(nnx,iys:iye), fnt3(nnx,iys:iye)
      real tauij(nnx,iys:iye,6,2), sij(nnx,iys:iye,6)
      real r3_sum(1:nnz)
c
      if(iskew .eq. 0) then
         upfac = 0.5
      else 
         upfac = 1.0
      endif
c
      do k=izs,ize
c
      km1 = k - 1
      kp1 = k + 1
c
c ------------ geostrophic wind
c
      u_geo = -fcor*vg(k)
      v_geo =  fcor*(ug(k)-ugal)
c
c ----------- for wind tunnel type simulations
c
c     u_geo = dpdx_con
c     v_geo = 0.0
c
      do j=iys,iye
      do i=1,nnx
c
c ------------ buoyancy (with hydrostatic part)
c              will correct at the bottom
c              of the routine
c
c        w_buy = batag*(t(i,j,1,k) - t_mn(k,1))
         w_buy = batag*t(i,j,1,k)
c
c ------------ coriolis, vertical and horizontal components
c
         u_cor     =  fcor*v(i,j,k) - fcor_h*w(i,j,k)
         v_cor     = -fcor*u(i,j,k)
         w_cor     =  fcor_h*u(i,j,k)
c
c ------------ build rhs times 1/J
c
         r1(i,j,k) = (u_cor + u_geo)*gm(i,j,k,1)
         r2(i,j,k) = (v_cor + v_geo)*gm(i,j,k,1)
         r3(i,j,k) = (w_cor + w_buy)*gm(i,j,k,1)
      enddo
      enddo
c
      enddo ! end z-loop
c
c ---------- advection for skew symmetric form, fix for moving grids
c
      if(iskew .eq. 0) then    ! skew symmetric form no grid speed
c
      do k=izs,ize
      km1 = k - 1
      kp1 = k + 1
      do j=iys,iye
      do i=1,nnx
         uzm     = (u(i,j,k) - u(i,j,km1))*dzu_i(k)
         vzm     = (v(i,j,k) - v(i,j,km1))*dzu_i(k)
         wzm     = (w(i,j,k) - w(i,j,km1))*dzu_i(k)
         uz      = (u(i,j,kp1) - u(i,j,k))*dzu_i(kp1)
         vz      = (v(i,j,kp1) - v(i,j,k))*dzu_i(kp1)
         wz      = (w(i,j,kp1) - w(i,j,k))*dzu_i(kp1)
c
         u_avg_u = u(i,j,k)*weitm(k) + u(i,j,kp1)*weit(k)
         v_avg_u = v(i,j,k)*weitm(k) + v(i,j,kp1)*weit(k)
         w_avg_u = w(i,j,k)*weitm(k) + w(i,j,kp1)*weit(k)
         u_avg_l = u(i,j,k)*weit(km1) + u(i,j,km1)*weitm(km1)
         v_avg_l = v(i,j,k)*weit(km1) + v(i,j,km1)*weitm(km1)
         w_avg_l = w(i,j,k)*weit(km1) + w(i,j,km1)*weitm(km1)
c
         u_adv = 0.5*(uf(i,j,k)*ux(i,j,k) + vf(i,j,k)*uy(i,j,k) +
     +           (wf(i,j,k)*u_avg_u - wf(i,j,km1)*u_avg_l)*dzw_i(k)) +
     +           0.25*(wf(i,j,k)*uz + wf(i,j,km1)*uzm) 
         v_adv = 0.5*(uf(i,j,k)*vx(i,j,k) + vf(i,j,k)*vy(i,j,k) +
     +           (wf(i,j,k)*v_avg_u - wf(i,j,km1)*v_avg_l)*dzw_i(k)) +
     +           0.25*(wf(i,j,k)*vz + wf(i,j,km1)*vzm) 
         w_adv = 0.5*(uf(i,j,k)*wx(i,j,k) + vf(i,j,k)*wy(i,j,k) +
     +           (wf(i,j,k)*w_avg_u - wf(i,j,km1)*w_avg_l)*dzw_i(k)) +
     +           0.25*(wf(i,j,k)*wz + wf(i,j,km1)*wzm) 
c
c ------------ totals
c
         r1(i,j,k) = r1(i,j,k) - u_adv
         r2(i,j,k) = r2(i,j,k) - v_adv 
         r3(i,j,k) = r3(i,j,k) - w_adv 
      enddo
      enddo
      enddo ! end z-loop
c
      else   ! flux form with grid speed
c
      do k=izs,ize
      km1 = k - 1
      kp1 = k + 1
      do j=iys,iye
      do i=1,nnx
c
         u_avg_u = u(i,j,k)*weitm(k) + u(i,j,kp1)*weit(k)
         v_avg_u = v(i,j,k)*weitm(k) + v(i,j,kp1)*weit(k)
         w_avg_u = w(i,j,k)*weitm(k) + w(i,j,kp1)*weit(k)
         u_avg_l = u(i,j,k)*weit(km1) + u(i,j,km1)*weitm(km1)
         v_avg_l = v(i,j,k)*weit(km1) + v(i,j,km1)*weitm(km1)
         w_avg_l = w(i,j,k)*weit(km1) + w(i,j,km1)*weitm(km1)
c
         wflx_u  = wf(i,j,k) - gm(i,j,k,5)
         wflx_l  = wf(i,j,km1) - gm(i,j,km1,5)
         u_adv   = (wflx_u*u_avg_u - wflx_l*u_avg_l)*dzw_i(k)
         v_adv   = (wflx_u*v_avg_u - wflx_l*v_avg_l)*dzw_i(k)
         w_adv   = (wflx_u*w_avg_u - wflx_l*w_avg_l)*dzw_i(k)
c
c ------------ totals
c
         r1(i,j,k) = r1(i,j,k) - u_adv
         r2(i,j,k) = r2(i,j,k) - v_adv 
         r3(i,j,k) = r3(i,j,k) - w_adv 
      enddo
      enddo
      enddo ! end z-loop
c
      endif ! end of skew check
c
c ----------- SGS cell center x-contributions + resolved fluxes
c             advective terms written in skew symmetric form
c
      do k=izs,ize
         call strain_c(sij,k)
         do j=iys,iye
         do i=1,nnx
            fac       = 2.0*gm(i,j,k,1)*vis_m(i,j,k)
            fnt1(i,j) = fac*sij(i,j,1) - upfac*uf(i,j,k)*u(i,j,k)
            fnt2(i,j) = fac*sij(i,j,2) - upfac*uf(i,j,k)*v(i,j,k)
            fnt3(i,j) = fac*sij(i,j,3) - upfac*uf(i,j,k)*w(i,j,k)
         enddo
         enddo
         call xderivp(fnt1(1,iys),trigx(1,1),xk(1),nnx,iys,iye)
         call xderivp(fnt2(1,iys),trigx(1,1),xk(1),nnx,iys,iye)
         call xderivp(fnt3(1,iys),trigx(1,1),xk(1),nnx,iys,iye)
         do j=iys,iye
         do i=1,nnx
            r1(i,j,k) = r1(i,j,k) + fnt1(i,j)
            r2(i,j,k) = r2(i,j,k) + fnt2(i,j)
            r3(i,j,k) = r3(i,j,k) + fnt3(i,j)
         enddo
         enddo
      enddo
c
c ----------- SGS z-contributions
c
      if(izs .eq. 1) then
         do j=iys,iye
         do i=1,nnx
            tauij(i,j,1,2) = -t11bc(i,j)
            tauij(i,j,2,2) = -t12bc(i,j)
            tauij(i,j,3,2) = -t13bc(i,j)
            tauij(i,j,4,2) = -t22bc(i,j)
            tauij(i,j,5,2) = -t23bc(i,j)
            tauij(i,j,6,2) = -t33bc(i,j)
         enddo
         enddo
      else
         call strain_u(sij,izs-1)
         do n=1,6
         do j=iys,iye
         do i=1,nnx
            fac   = 2.0*(weit(izs-1)*vis_m(i,j,izs) + 
     +              weitm(izs-1)*vis_m(i,j,izs-1))
            tauij(i,j,n,2) = fac*sij(i,j,n)
         enddo
         enddo
         enddo
      endif
      do k=izs,ize
         kp1 = k + 1
         km1 = k - 1
         do n=1,6
         do j=iys,iye
         do i=1,nnx
            tauij(i,j,n,1) = tauij(i,j,n,2)
         enddo
         enddo
         enddo
         call strain_u(sij,k)
         do n=1,6
         do j=iys,iye
         do i=1,nnx
            fac   = 2.0*(weit(k)*vis_m(i,j,kp1) + 
     +                   weitm(k)*vis_m(i,j,k))
            tauij(i,j,n,2) = fac*sij(i,j,n)
         enddo
         enddo
         enddo
         uw_sum = 0.0
         vw_sum = 0.0
         ww_sum = 0.0
         do j=iys,iye
         do i=1,nnx
            gm_xu     = weit(k)*gm(i,j,kp1,1)*gm(i,j,kp1,2) + 
     +                  weitm(k)*gm(i,j,k,1)*gm(i,j,k,2)  
            gm_xl     = weit(km1)*gm(i,j,k,1)*gm(i,j,k,2) + 
     +                  weitm(km1)*gm(i,j,km1,1)*gm(i,j,km1,2)  
            gm_yu     = weit(k)*gm(i,j,kp1,1)*gm(i,j,kp1,3) + 
     +                  weitm(k)*gm(i,j,k,1)*gm(i,j,k,3)  
            gm_yl     = weit(km1)*gm(i,j,k,1)*gm(i,j,k,3) + 
     +                  weitm(km1)*gm(i,j,km1,1)*gm(i,j,km1,3)  
            tau_up    = tauij(i,j,1,2)*gm_xu + tauij(i,j,2,2)*gm_yu +
     +                  tauij(i,j,3,2)
            tau_lo    = tauij(i,j,1,1)*gm_xl + tauij(i,j,2,1)*gm_yl +
     +                  tauij(i,j,3,1)
            uw_sum    = uw_sum + tau_up
            r1(i,j,k) = r1(i,j,k) + (tau_up - tau_lo)*dzw_i(k)
            tau_up    = tauij(i,j,2,2)*gm_xu + tauij(i,j,4,2)*gm_yu +
     +                  tauij(i,j,5,2)
            tau_lo    = tauij(i,j,2,1)*gm_xl + tauij(i,j,4,1)*gm_yl +
     +                  tauij(i,j,5,1)
            vw_sum    = vw_sum + tau_up
            r2(i,j,k) = r2(i,j,k) + (tau_up - tau_lo)*dzw_i(k)
            tau_up    = tauij(i,j,3,2)*gm_xu + tauij(i,j,5,2)*gm_yu +
     +                  tauij(i,j,6,2)
            tau_lo    = tauij(i,j,3,1)*gm_xl + tauij(i,j,5,1)*gm_yl +
     +                  tauij(i,j,6,1)
            ww_sum    = ww_sum + tau_up
            r3(i,j,k) = r3(i,j,k) + (tau_up - tau_lo)*dzw_i(k)
         enddo
         enddo
c
c -------- save SGS fluxes for printout
c
      if(istep .eq. 1) then
         tr_tau(k) = 0.0
         do j=iys,iye
         do i=1,nnx
            ufluc    = (u(i,j,kp1) - uxym(kp1))*weit(k) +
     +                 (u(i,j,k) - uxym(k))*weitm(k)
            vfluc    = (v(i,j,kp1) - vxym(kp1))*weit(k) +
     +                 (v(i,j,k) - vxym(k))*weitm(k)
            tr_tau(k) = tr_tau(k) -
     +                 tauij(i,j,3,2)*ufluc - tauij(i,j,5,2)*vfluc
         enddo
         enddo
         uwsb(k)   = -uw_sum*fnxy
         vwsb(k)   = -vw_sum*fnxy
         wwsb(k)   = -ww_sum*fnxy
         tr_tau(k) = tr_tau(k)*fnxy
      endif
c
c ---------- end z loop
c
      enddo
c
c ---------- SGS fluxes tau_12, tau_22, tau_23 that depend on 
c            y-derivatives at cell centers
c
      do k=izs,ize
         call strain_12(sij(1,iys,1),k)
         do j=iys,iye
         do i=1,nnx
            fac         = 2.0*gm(i,j,k,1)*vis_m(i,j,k)
c           fntd(i,j,k) = fac*sij(i,j,1) - upfac*vf(i,j,k)*u(i,j,k)
            fntd(i,j,k) = tauij(i,j,2,2) - upfac*vf(i,j,k)*u(i,j,k)
         enddo
         enddo
      enddo
      call yd_mpi(fntd(1,iys,izs),trigx(1,2),yk(1),
     +           nnx,nny,ixs,ixe,ix_s,ix_e,
     +           iys,iye,iy_s,iy_e,izs,ize,myid,ncpu_s,numprocs)
      do k=izs,ize
         do j=iys,iye
         do i=1,nnx
            r1(i,j,k)   = r1(i,j,k) + fntd(i,j,k)
         enddo
         enddo
      enddo
      do k=izs,ize
         call strain_22(sij(1,iys,1),k)
         do j=iys,iye
         do i=1,nnx
            fac         = 2.0*gm(i,j,k,1)*vis_m(i,j,k)
c           fntd(i,j,k) = fac*sij(i,j,1) - upfac*vf(i,j,k)*v(i,j,k)
            fntd(i,j,k) = tauij(i,j,4,2) - upfac*vf(i,j,k)*u(i,j,k)
         enddo
         enddo
      enddo
      call yd_mpi(fntd(1,iys,izs),trigx(1,2),yk(1),
     +           nnx,nny,ixs,ixe,ix_s,ix_e,
     +           iys,iye,iy_s,iy_e,izs,ize,myid,ncpu_s,numprocs)
      do k=izs,ize
         do j=iys,iye
         do i=1,nnx
            r2(i,j,k)   = r2(i,j,k) + fntd(i,j,k)
         enddo
         enddo
      enddo
      do k=izs,ize
         call strain_23(sij(1,iys,1),k)
         do j=iys,iye
         do i=1,nnx
            fac       = 2.0*gm(i,j,k,1)*vis_m(i,j,k)
c           fntd(i,j,k) = fac*sij(i,j,1) - upfac*vf(i,j,k)*w(i,j,k)
            fntd(i,j,k) = tauij(i,j,5,2) - upfac*vf(i,j,k)*u(i,j,k)
         enddo
         enddo
      enddo
      call yd_mpi(fntd(1,iys,izs),trigx(1,2),yk(1),
     +           nnx,nny,ixs,ixe,ix_s,ix_e,
     +           iys,iye,iy_s,iy_e,izs,ize,myid,ncpu_s,numprocs)
c
c --------- add a constant to r3 to account for hydrostatic pressure
c           and for periodic sidewalls. we have r3/J therefore the 
c           constant to be added  = - <J*r3/J>/J
c
      do k=1,nnz
         r3_sum(k) = 0.0
      enddo
      do k=izs,ize
         do j=iys,iye
         do i=1,nnx
            r3(i,j,k) = r3(i,j,k) + fntd(i,j,k)
            r3_sum(k) = r3_sum(k) + r3(i,j,k)*gm(i,j,k,4)
         enddo
         enddo
         r3_sum(k) = r3_sum(k)*fnxy
      enddo
c
      call mpi_sum_z(r3_sum,i_root,myid,nnz,1)
c
c ------- make sure <r3/J> = 0 and set r3 = 0 at top
c
      do k=izs,ize
         if(k .eq. nnz) then
            do j=iys,iye
            do i=1,nnx
               r3(i,j,k) = 0.0
            enddo
            enddo
         else
            do j=iys,iye
            do i=1,nnx
               r3(i,j,k) = r3(i,j,k) - r3_sum(k)*gm(i,j,k,1)
            enddo
            enddo
         endif
      enddo
c
c --------- leave with (r1,r2,r3)/J
c
      return
      end
      subroutine strain_u(sij_u,k)
c
c ---------- get strain matrix at the upper face at the k-level
c
c        strain definitions
c
c        ux   = uxi  + uzet*gm_x
c        uy   = ueta + uzet*gm_y
c        uz   = uzet*gm_z
c        vx   = vxi  + vzet*gm_x
c        vy   = veta + vzet*gm_y
c        vz   = vzet*gm_z
c        wx   = wxi  + wzet*gm_x
c        wy   = weta + wzet*gm_y
c        wz   = wzet*gm_z
c
      use pars
      use fields
      use fftwk
      use con_data
      use con_stats
      real sij_u(nnx,iys:iye,6)
c
      km1  = k - 1
      kp1  = k + 1
      w1   = weit(k)
      w1m  = weitm(k)
      w2   = weit(km1)
      w2m  = weitm(km1)
c
c -------- at upper face
c
      do j=iys,iye
      do i=1,nnx
         uzet  = (u(i,j,kp1) - u(i,j,k))*dzu_i(kp1) 
         vzet  = (v(i,j,kp1) - v(i,j,k))*dzu_i(kp1) 
         wzet  = (w(i,j,kp1) - w(i,j,k))*dzu_i(kp1) 
         uxi   = w1*ux(i,j,kp1) + w1m*ux(i,j,k)
         vxi   = w1*vx(i,j,kp1) + w1m*vx(i,j,k)
         wxi   = w1*wx(i,j,kp1) + w1m*wx(i,j,k)
         ueta  = w1*uy(i,j,kp1) + w1m*uy(i,j,k)
         veta  = w1*vy(i,j,kp1) + w1m*vy(i,j,k)
         weta  = w1*wy(i,j,kp1) + w1m*wy(i,j,k)
         gm_x  = w1*gm(i,j,kp1,2) + w1m*gm(i,j,k,2)
         gm_y  = w1*gm(i,j,kp1,3) + w1m*gm(i,j,k,3)
         gm_z  = w1*gm(i,j,kp1,4) +  w1m*gm(i,j,k,4)
         sij_u(i,j,1) = uxi  + uzet*gm_x
         sij_u(i,j,2) = 0.5*(ueta + uzet*gm_y + vxi  + vzet*gm_x)
         sij_u(i,j,3) = 0.5*(uzet*gm_z + wxi  + wzet*gm_x)
         sij_u(i,j,4) = veta + vzet*gm_y
         sij_u(i,j,5) = 0.5*(vzet*gm_z + weta + wzet*gm_y)
         sij_u(i,j,6) = wzet*gm_z
      enddo
      enddo
c
      return
      end
      subroutine strain_c_dns(sij_c,k)
c
c ---------- get strain matrix at the cell center 
c ---------- for DNS just don't treak k = 1 any different
c
c        strain definitions
c
c        ux   = uxi  + uzet*gm_x
c        uy   = ueta + uzet*gm_y
c        uz   = uzet*gm_z
c        vx   = vxi  + vzet*gm_x
c        vy   = veta + vzet*gm_y
c        vz   = vzet*gm_z
c        wx   = wxi  + wzet*gm_x
c        wy   = weta + wzet*gm_y
c        wz   = wzet*gm_z
c
      use pars
      use fields
      use fftwk
      use con_data
      use con_stats
      real sij_c(nnx,iys:iye,6)
c
      km1  = k - 1
      kp1  = k + 1
      w1   = weit(k)
      w1m  = weitm(k)
      w2   = weit(km1)
      w2m  = weitm(km1)
c
!      if(k == 1) then
!c
!c ------- vertical gradients at upper face
!Cnew      now computed at cell centers using surface bcs
!c
!      do j=iys,iye
!      do i=1,nnx
!         uzet  = (u(i,j,kp1) - u(i,j,k))*dzu_i(kp1)
!         vzet  = (v(i,j,kp1) - v(i,j,k))*dzu_i(kp1)
!         wzet  = (w(i,j,kp1) - w(i,j,k))*dzu_i(kp1)
!         gm_x  = gm(i,j,k,2)
!         gm_y  = gm(i,j,k,3)
!         gm_z  = gm(i,j,k,4)
!         sij_c(i,j,1) = ux(i,j,k)  + uzet*gm_x
!         sij_c(i,j,2) = 0.5*(uy(i,j,k) + uzet*gm_y + 
!     +                       vx(i,j,k)  + vzet*gm_x)
!         sij_c(i,j,3) = 0.5*(uzet*gm_z + wx(i,j,k)  + wzet*gm_x)
!         sij_c(i,j,4) = vy(i,j,k) + vzet*gm_y
!         sij_c(i,j,5) = 0.5*(vzet*gm_z + wy(i,j,k) + wzet*gm_y)
!         sij_c(i,j,6) = wzet*gm_z
!      enddo
!      enddo
!
!      else
c
c -------- at cell center
c
      do j=iys,iye
      do i=1,nnx
         uup   = w1*u(i,j,kp1) + w1m*u(i,j,k)
         ulo   = w2*u(i,j,k) + w2m*u(i,j,km1)
         uzet  = (uup - ulo)*dzw_i(k) 
         vup   = w1*v(i,j,kp1) + w1m*v(i,j,k)
         vlo   = w2*v(i,j,k) + w2m*v(i,j,km1)
         vzet  = (vup - vlo)*dzw_i(k) 
         wup   = w1*w(i,j,kp1) + w1m*w(i,j,k)
         wlo   = w2*w(i,j,k) + w2m*w(i,j,km1)
         wzet  = (wup - wlo)*dzw_i(k) 
         gm_x  = gm(i,j,k,2)
         gm_y  = gm(i,j,k,3)
         gm_z  = gm(i,j,k,4)
         sij_c(i,j,1) = ux(i,j,k)  + uzet*gm_x
         sij_c(i,j,2) = 0.5*(uy(i,j,k) + uzet*gm_y + 
     +                       vx(i,j,k)  + vzet*gm_x)
         sij_c(i,j,3) = 0.5*(uzet*gm_z + wx(i,j,k)  + wzet*gm_x)
         sij_c(i,j,4) = vy(i,j,k) + vzet*gm_y
         sij_c(i,j,5) = 0.5*(vzet*gm_z + wy(i,j,k) + wzet*gm_y)
         sij_c(i,j,6) = wzet*gm_z
      enddo
      enddo
c
!      endif
c
      return
      end
      subroutine strain_c(sij_c,k)
c
c ---------- get strain matrix at the cell center 
c            special if at first level off the wall
c
c        strain definitions
c
c        ux   = uxi  + uzet*gm_x
c        uy   = ueta + uzet*gm_y
c        uz   = uzet*gm_z
c        vx   = vxi  + vzet*gm_x
c        vy   = veta + vzet*gm_y
c        vz   = vzet*gm_z
c        wx   = wxi  + wzet*gm_x
c        wy   = weta + wzet*gm_y
c        wz   = wzet*gm_z
c
      use pars
      use fields
      use fftwk
      use con_data
      use con_stats
      real sij_c(nnx,iys:iye,6)
c
      km1  = k - 1
      kp1  = k + 1
      w1   = weit(k)
      w1m  = weitm(k)
      w2   = weit(km1)
      w2m  = weitm(km1)
c
      if(k == 1) then
c
c ------- vertical gradients at upper face
Cnew      now computed at cell centers using surface bcs
c
      do j=iys,iye
      do i=1,nnx
         uzet  = (u(i,j,kp1) - u(i,j,k))*dzu_i(kp1)
         vzet  = (v(i,j,kp1) - v(i,j,k))*dzu_i(kp1)
         wzet  = (w(i,j,kp1) - w(i,j,k))*dzu_i(kp1)
         gm_x  = gm(i,j,k,2)
         gm_y  = gm(i,j,k,3)
         gm_z  = gm(i,j,k,4)
         sij_c(i,j,1) = ux(i,j,k)  + uzet*gm_x
         sij_c(i,j,2) = 0.5*(uy(i,j,k) + uzet*gm_y + 
     +                       vx(i,j,k)  + vzet*gm_x)
         sij_c(i,j,3) = 0.5*(uzet*gm_z + wx(i,j,k)  + wzet*gm_x)
         sij_c(i,j,4) = vy(i,j,k) + vzet*gm_y
         sij_c(i,j,5) = 0.5*(vzet*gm_z + wy(i,j,k) + wzet*gm_y)
         sij_c(i,j,6) = wzet*gm_z
      enddo
      enddo

      else
c
c -------- at cell center
c
      do j=iys,iye
      do i=1,nnx
         uup   = w1*u(i,j,kp1) + w1m*u(i,j,k)
         ulo   = w2*u(i,j,k) + w2m*u(i,j,km1)
         uzet  = (uup - ulo)*dzw_i(k) 
         vup   = w1*v(i,j,kp1) + w1m*v(i,j,k)
         vlo   = w2*v(i,j,k) + w2m*v(i,j,km1)
         vzet  = (vup - vlo)*dzw_i(k) 
         wup   = w1*w(i,j,kp1) + w1m*w(i,j,k)
         wlo   = w2*w(i,j,k) + w2m*w(i,j,km1)
         wzet  = (wup - wlo)*dzw_i(k) 
         gm_x  = gm(i,j,k,2)
         gm_y  = gm(i,j,k,3)
         gm_z  = gm(i,j,k,4)
         sij_c(i,j,1) = ux(i,j,k)  + uzet*gm_x
         sij_c(i,j,2) = 0.5*(uy(i,j,k) + uzet*gm_y + 
     +                       vx(i,j,k)  + vzet*gm_x)
         sij_c(i,j,3) = 0.5*(uzet*gm_z + wx(i,j,k)  + wzet*gm_x)
         sij_c(i,j,4) = vy(i,j,k) + vzet*gm_y
         sij_c(i,j,5) = 0.5*(vzet*gm_z + wy(i,j,k) + wzet*gm_y)
         sij_c(i,j,6) = wzet*gm_z
      enddo
      enddo
c
      endif
c
      return
      end
      subroutine strain_12_dns(sij_y,k)
c
c ---------- get strain s12
c            for special evaluation of eta derivatives
c            using matrix transpose
c
c        strain definitions
c
c        ux   = uxi  + uzet*gm_x
c        uy   = ueta + uzet*gm_y
c        uz   = uzet*gm_z
c        vx   = vxi  + vzet*gm_x
c        vy   = veta + vzet*gm_y
c        vz   = vzet*gm_z
c        wx   = wxi  + wzet*gm_x
c        wy   = weta + wzet*gm_y
c        wz   = wzet*gm_z
c
      use pars
      use fields
      use fftwk
      use con_data
      use con_stats
      real sij_y(nnx,iys:iye)
c
      km1  = k - 1
      kp1  = k + 1
      w1   = weit(k)
      w1m  = weitm(k)
      w2   = weit(km1)
      w2m  = weitm(km1)
c
!      if(k == 1) then
!c
!c ------ at upper face
!c
!      do j=iys,iye
!      do i=1,nnx
!         uzet       = (u(i,j,kp1) - u(i,j,k))*dzu_i(kp1)
!         vzet       = (v(i,j,kp1) - v(i,j,k))*dzu_i(kp1)
!         vxi        = w1*vx(i,j,kp1) + w1m*vx(i,j,k)
!         ueta       = w1*uy(i,j,kp1) + w1m*uy(i,j,k)
!         gm_x       = w1*gm(i,j,kp1,2) + w1m*gm(i,j,k,2)
!         gm_y       = w1*gm(i,j,kp1,3) + w1m*gm(i,j,k,3)
!         sij_y(i,j) = 0.5*(ueta + uzet*gm_y + vxi  + vzet*gm_x)
!      enddo
!      enddo
!c
!      else
c
c -------- at cell center
c
      do j=iys,iye
      do i=1,nnx
         uup   = w1*u(i,j,kp1) + w1m*u(i,j,k)
         ulo   = w2*u(i,j,k) + w2m*u(i,j,km1)
         uzet  = (uup - ulo)*dzw_i(k) 
         vup   = w1*v(i,j,kp1) + w1m*v(i,j,k)
         vlo   = w2*v(i,j,k) + w2m*v(i,j,km1)
         vzet  = (vup - vlo)*dzw_i(k) 
         sij_y(i,j) = 0.5*(uy(i,j,k) + uzet*gm(i,j,k,3) + 
     +                     vx(i,j,k) + vzet*gm(i,j,k,2))
      enddo
      enddo
c
!      endif
c
      return
      end
      subroutine strain_12(sij_y,k)
c
c ---------- get strain s12
c            for special evaluation of eta derivatives
c            using matrix transpose
c
c        strain definitions
c
c        ux   = uxi  + uzet*gm_x
c        uy   = ueta + uzet*gm_y
c        uz   = uzet*gm_z
c        vx   = vxi  + vzet*gm_x
c        vy   = veta + vzet*gm_y
c        vz   = vzet*gm_z
c        wx   = wxi  + wzet*gm_x
c        wy   = weta + wzet*gm_y
c        wz   = wzet*gm_z
c
      use pars
      use fields
      use fftwk
      use con_data
      use con_stats
      real sij_y(nnx,iys:iye)
c
      km1  = k - 1
      kp1  = k + 1
      w1   = weit(k)
      w1m  = weitm(k)
      w2   = weit(km1)
      w2m  = weitm(km1)
c
      if(k == 1) then
c
c ------ at upper face
c
      do j=iys,iye
      do i=1,nnx
         uzet       = (u(i,j,kp1) - u(i,j,k))*dzu_i(kp1)
         vzet       = (v(i,j,kp1) - v(i,j,k))*dzu_i(kp1)
         vxi        = w1*vx(i,j,kp1) + w1m*vx(i,j,k)
         ueta       = w1*uy(i,j,kp1) + w1m*uy(i,j,k)
         gm_x       = w1*gm(i,j,kp1,2) + w1m*gm(i,j,k,2)
         gm_y       = w1*gm(i,j,kp1,3) + w1m*gm(i,j,k,3)
         sij_y(i,j) = 0.5*(ueta + uzet*gm_y + vxi  + vzet*gm_x)
      enddo
      enddo
c
      else
c
c -------- at cell center
c
      do j=iys,iye
      do i=1,nnx
         uup   = w1*u(i,j,kp1) + w1m*u(i,j,k)
         ulo   = w2*u(i,j,k) + w2m*u(i,j,km1)
         uzet  = (uup - ulo)*dzw_i(k) 
         vup   = w1*v(i,j,kp1) + w1m*v(i,j,k)
         vlo   = w2*v(i,j,k) + w2m*v(i,j,km1)
         vzet  = (vup - vlo)*dzw_i(k) 
         sij_y(i,j) = 0.5*(uy(i,j,k) + uzet*gm(i,j,k,3) + 
     +                     vx(i,j,k) + vzet*gm(i,j,k,2))
      enddo
      enddo
c
      endif
c
      return
      end
      subroutine strain_22_dns(sij_y,k)
c
c ---------- get strain s22 at cell center
c            for special evaluation of eta derivatives
c            using matrix transpose
c
c        strain definitions
c
c        ux   = uxi  + uzet*gm_x
c        uy   = ueta + uzet*gm_y
c        uz   = uzet*gm_z
c        vx   = vxi  + vzet*gm_x
c        vy   = veta + vzet*gm_y
c        vz   = vzet*gm_z
c        wx   = wxi  + wzet*gm_x
c        wy   = weta + wzet*gm_y
c        wz   = wzet*gm_z
c
      use pars
      use fields
      use fftwk
      use con_data
      use con_stats
      real sij_y(nnx,iys:iye)
c
      km1  = k - 1
      kp1  = k + 1
      w1   = weit(k)
      w1m  = weitm(k)
      w2   = weit(km1)
      w2m  = weitm(km1)
c
!      if(k == 1) then
!c
!c -------at upper face
!c
!      do j=iys,iye
!      do i=1,nnx
!         vzet       = (v(i,j,kp1) - v(i,j,k))*dzu_i(kp1)
!         veta       = w1*vy(i,j,kp1) + w1m*vy(i,j,k)
!         gm_y       = w1*gm(i,j,kp1,3) + w1m*gm(i,j,k,3)
!         sij_y(i,j) = veta + vzet*gm_y
!      enddo
!      enddo
!      else
c
c -------- at cell center
c
      do j=iys,iye
      do i=1,nnx
         vup   = w1*v(i,j,kp1) + w1m*v(i,j,k)
         vlo   = w2*v(i,j,k) + w2m*v(i,j,km1)
         vzet  = (vup - vlo)*dzw_i(k) 
         sij_y(i,j) = vy(i,j,k) + vzet*gm(i,j,k,3)
      enddo
      enddo
c
!      endif
c
      return
      end
      subroutine strain_22(sij_y,k)
c
c ---------- get strain s22 at cell center
c            for special evaluation of eta derivatives
c            using matrix transpose
c
c        strain definitions
c
c        ux   = uxi  + uzet*gm_x
c        uy   = ueta + uzet*gm_y
c        uz   = uzet*gm_z
c        vx   = vxi  + vzet*gm_x
c        vy   = veta + vzet*gm_y
c        vz   = vzet*gm_z
c        wx   = wxi  + wzet*gm_x
c        wy   = weta + wzet*gm_y
c        wz   = wzet*gm_z
c
      use pars
      use fields
      use fftwk
      use con_data
      use con_stats
      real sij_y(nnx,iys:iye)
c
      km1  = k - 1
      kp1  = k + 1
      w1   = weit(k)
      w1m  = weitm(k)
      w2   = weit(km1)
      w2m  = weitm(km1)
c
      if(k == 1) then
c
c -------at upper face
c
      do j=iys,iye
      do i=1,nnx
         vzet       = (v(i,j,kp1) - v(i,j,k))*dzu_i(kp1)
         veta       = w1*vy(i,j,kp1) + w1m*vy(i,j,k)
         gm_y       = w1*gm(i,j,kp1,3) + w1m*gm(i,j,k,3)
         sij_y(i,j) = veta + vzet*gm_y
      enddo
      enddo
      else
c
c -------- at cell center
c
      do j=iys,iye
      do i=1,nnx
         vup   = w1*v(i,j,kp1) + w1m*v(i,j,k)
         vlo   = w2*v(i,j,k) + w2m*v(i,j,km1)
         vzet  = (vup - vlo)*dzw_i(k) 
         sij_y(i,j) = vy(i,j,k) + vzet*gm(i,j,k,3)
      enddo
      enddo
c
      endif
c
      return
      end
      subroutine strain_23_dns(sij_y,k)
c
c ---------- get strain s23 at cell center
c            for special evaluation of eta derivatives
c            using matrix transpose
c
c        strain definitions
c
c        ux   = uxi  + uzet*gm_x
c        uy   = ueta + uzet*gm_y
c        uz   = uzet*gm_z
c        vx   = vxi  + vzet*gm_x
c        vy   = veta + vzet*gm_y
c        vz   = vzet*gm_z
c        wx   = wxi  + wzet*gm_x
c        wy   = weta + wzet*gm_y
c        wz   = wzet*gm_z
c
      use pars
      use fields
      use fftwk
      use con_data
      use con_stats
      real sij_y(nnx,iys:iye)
c
      km1  = k - 1
      kp1  = k + 1
      w1   = weit(k)
      w1m  = weitm(k)
      w2   = weit(km1)
      w2m  = weitm(km1)
c
!      if(k == 1) then
!c
!c -------- at upper face
!c
!      do j=iys,iye
!      do i=1,nnx
!         vzet       = (v(i,j,kp1) - v(i,j,k))*dzu_i(kp1)
!         wzet       = (w(i,j,kp1) - w(i,j,k))*dzu_i(kp1)
!         weta       = w1*wy(i,j,kp1) + w1m*wy(i,j,k)
!         gm_y       = w1*gm(i,j,kp1,3) + w1m*gm(i,j,k,3)
!         gm_z       = w1*gm(i,j,kp1,4) +  w1m*gm(i,j,k,4)
!         sij_y(i,j) = 0.5*(vzet*gm_z + weta + wzet*gm_y)
!      enddo
!      enddo
!      else
c
c -------- at cell center
c
      do j=iys,iye
      do i=1,nnx
         vup   = w1*v(i,j,kp1) + w1m*v(i,j,k)
         vlo   = w2*v(i,j,k) + w2m*v(i,j,km1)
         vzet  = (vup - vlo)*dzw_i(k) 
         wup   = w1*w(i,j,kp1) + w1m*w(i,j,k)
         wlo   = w2*w(i,j,k) + w2m*w(i,j,km1)
         wzet  = (wup - wlo)*dzw_i(k) 
         sij_y(i,j) = 0.5*(vzet*gm(i,j,k,4) + 
     +                     wy(i,j,k) + wzet*gm(i,j,k,3))
      enddo
      enddo
c
!      endif
c
      return
      end
      subroutine strain_23(sij_y,k)
c
c ---------- get strain s23 at cell center
c            for special evaluation of eta derivatives
c            using matrix transpose
c
c        strain definitions
c
c        ux   = uxi  + uzet*gm_x
c        uy   = ueta + uzet*gm_y
c        uz   = uzet*gm_z
c        vx   = vxi  + vzet*gm_x
c        vy   = veta + vzet*gm_y
c        vz   = vzet*gm_z
c        wx   = wxi  + wzet*gm_x
c        wy   = weta + wzet*gm_y
c        wz   = wzet*gm_z
c
      use pars
      use fields
      use fftwk
      use con_data
      use con_stats
      real sij_y(nnx,iys:iye)
c
      km1  = k - 1
      kp1  = k + 1
      w1   = weit(k)
      w1m  = weitm(k)
      w2   = weit(km1)
      w2m  = weitm(km1)
c
      if(k == 1) then
c
c -------- at upper face
c
      do j=iys,iye
      do i=1,nnx
         vzet       = (v(i,j,kp1) - v(i,j,k))*dzu_i(kp1)
         wzet       = (w(i,j,kp1) - w(i,j,k))*dzu_i(kp1)
         weta       = w1*wy(i,j,kp1) + w1m*wy(i,j,k)
         gm_y       = w1*gm(i,j,kp1,3) + w1m*gm(i,j,k,3)
         gm_z       = w1*gm(i,j,kp1,4) +  w1m*gm(i,j,k,4)
         sij_y(i,j) = 0.5*(vzet*gm_z + weta + wzet*gm_y)
      enddo
      enddo
      else
c
c -------- at cell center
c
      do j=iys,iye
      do i=1,nnx
         vup   = w1*v(i,j,kp1) + w1m*v(i,j,k)
         vlo   = w2*v(i,j,k) + w2m*v(i,j,km1)
         vzet  = (vup - vlo)*dzw_i(k) 
         wup   = w1*w(i,j,kp1) + w1m*w(i,j,k)
         wlo   = w2*w(i,j,k) + w2m*w(i,j,km1)
         wzet  = (wup - wlo)*dzw_i(k) 
         sij_y(i,j) = 0.5*(vzet*gm(i,j,k,4) + 
     +                     wy(i,j,k) + wzet*gm(i,j,k,3))
      enddo
      enddo
c
      endif
c
      return
      end
      subroutine rhs_scl_dns(istep,iscl)
c
c ------ get right hand side of scalar equation (iscl)
c        monotone scalar fluxes only in z
c        for pencil size (nnx, iys:iye, izs:ize) 
c        care is taken so that if monotone is on then
c        conservative horizontal flux form is used!
c        uses flux conservation form for advection always
c
      use pars
      use fields
      use fftwk
      use con_data
      use con_stats
c
      real fnt1(nnx,iys:iye), fntd(nnx,iys:iye,izs:ize)
      real tx(nnx,iys:iye,izs-1:ize+1), ty(nnx,iys:iye,izs-1:ize+1)
      real flux_u(nnx,iys:iye), flux_l(nnx,iys:iye)
      real tflx(nnx,iys:iye,3,2), scl_g(nnx,iys:iye,3)
      real sfc_flx
c
c --------- set sign for ocean simulations that use monotone
c
      sgn = 1.0
      if(iocean .eq. 1) sgn = -1.0
      if(iupwnd .eq. 1) then
         upfac = 1.0
      else
         upfac = 0.5
      endif
      sfc_flx = 0.0
c
c --------- get x & y derivatives for [izs-1:ize+1]
c
      do k=izs-1,ize+1
         do j=iys,iye
         do i=1,nnx
            tx(i,j,k) = t(i,j,iscl,k)
            ty(i,j,k) = t(i,j,iscl,k)
         enddo
         enddo
         call xderivp(tx(1,iys,k),trigx(1,1),xk(1),nnx,iys,iye)
      enddo
      call yd_mpi(ty(1,iys,izs-1),trigx(1,2),yk(1),
     +           nnx,nny,ixs,ixe,ix_s,ix_e,
     +           iys,iye,iy_s,iy_e,izs-1,ize+1,myid,ncpu_s,numprocs)
c
c -------- SGS term tflx(.,.,1) + resolved flux at cell center
c
      do k=izs,ize
         kp1 = k + 1
         km1 = k - 1
!         if(k .eq. 1) then
!            call grads_u(scl_g,k,tx,ty,iscl)
!            do j=iys,iye
!            do i=1,nnx
!               gm_u  = weit(k)*gm(i,j,kp1,1) + weitm(k)*gm(i,j,k,1)
!               gm_l  = weit(km1)*gm(i,j,k,1) + weitm(km1)*gm(i,j,km1,1)
!               fac   = weit(k)*vis_s(i,j,kp1) + weitm(k)*vis_s(i,j,k)
!               tflx(i,j,1,1) = 0.5*(fac*scl_g(i,j,1)*gm_u -
!     +                               t1tbc(i,j,iscl)*gm_l)
!               tflx(i,j,2,1) = 0.5*(fac*scl_g(i,j,2)*gm_u -
!     +                               t2tbc(i,j,iscl)*gm_l)
!               fnt1(i,j)     = tflx(i,j,1,1) - 
!     +                         upfac*uf(i,j,k)*t(i,j,iscl,k)
!               fntd(i,j,k)   = tflx(i,j,2,1) - 
!     +                         upfac*vf(i,j,k)*t(i,j,iscl,k)
!            enddo
!            enddo
!         else
            !call grads_c(scl_g,k,tx,ty,iscl)
            call grads_c_dns(scl_g,k,tx,ty,iscl)
            do j=iys,iye
            do i=1,nnx
               tflx(i,j,1,1) = vis_s(i,j,k)*scl_g(i,j,1)*gm(i,j,k,1)
               tflx(i,j,2,1) = vis_s(i,j,k)*scl_g(i,j,2)*gm(i,j,k,1)
               fnt1(i,j)     = tflx(i,j,1,1) - 
     +                         upfac*uf(i,j,k)*t(i,j,iscl,k)
               fntd(i,j,k)   = tflx(i,j,2,1) - 
     +                         upfac*vf(i,j,k)*t(i,j,iscl,k)
            enddo
            enddo
!         endif
         call xderivp(fnt1(1,iys),trigx(1,1),xk(1),nnx,iys,iye)
         do j=iys,iye
         do i=1,nnx
            r4(i,j,iscl,k) = fnt1(i,j)
         enddo
         enddo
c
c -------- save SGS fluxes for printout
c
         if(istep .eq. 1) then
            utsb(k,iscl) = 0.0
            vtsb(k,iscl) = 0.0
            do j=iys,iye
            do i=1,nnx
               utsb(k,iscl) = utsb(k,iscl) - tflx(i,j,1,1)
               vtsb(k,iscl) = vtsb(k,iscl) - tflx(i,j,2,1)
            enddo
            enddo
            utsb(k,iscl) = utsb(k,iscl)*fnxy
            vtsb(k,iscl) = vtsb(k,iscl)*fnxy
         endif
      enddo
c
c ---------- SGS fluxes tflx(.,.,2) that depend on
c            y-derivative at cell centers
c
      call yd_mpi(fntd(1,iys,izs),trigx(1,2),yk(1),
     +           nnx,nny,ixs,ixe,ix_s,ix_e,
     +           iys,iye,iy_s,iy_e,izs,ize,myid,ncpu_s,numprocs)
      do k=izs,ize
         do j=iys,iye
         do i=1,nnx
            r4(i,j,iscl,k) = r4(i,j,iscl,k) + fntd(i,j,k)
         enddo
         enddo
      enddo
c
c ------- resolved advection for skew symmetric form
c         for no monotone
c
      if(iupwnd .ne. 1) then
c
      do k=izs,ize
         do j=iys,iye
         do i=1,nnx
            r4(i,j,iscl,k) = r4(i,j,iscl,k) - 
     +            upfac*(uf(i,j,k)*tx(i,j,k) + vf(i,j,k)*ty(i,j,k))
         enddo
         enddo
      enddo
      endif ! end of iupwnd check for horizontal advection
c
c ----------- SGS z-contributions
c
!      if(izs .eq. 1) then
!         do j=iys,iye
!         do i=1,nnx
!            tflx(i,j,1,2) = -t1tbc(i,j,iscl)
!            tflx(i,j,2,2) = -t2tbc(i,j,iscl)
!            tflx(i,j,3,2) = -t3tbc(i,j,iscl)
!         enddo
!         enddo
!      else
         call grads_u(scl_g,izs-1,tx,ty,iscl)
         do n=1,3
         do j=iys,iye
         do i=1,nnx
            fac   = weit(izs-1)*vis_s(i,j,izs) +
     +              weitm(izs-1)*vis_s(i,j,izs-1)
            tflx(i,j,n,2) = fac*scl_g(i,j,n)
         enddo
         enddo
         enddo
!      endif
      do k=izs,ize
         kp1 = k + 1
         km1 = k - 1
         do n=1,3
         do j=iys,iye
         do i=1,nnx
            tflx(i,j,n,1) = tflx(i,j,n,2)
         enddo
         enddo
         enddo
         call grads_u(scl_g,k,tx,ty,iscl)
         do n=1,3
         do j=iys,iye
         do i=1,nnx
            fac   = weit(k)*vis_s(i,j,kp1) + weitm(k)*vis_s(i,j,k)
            tflx(i,j,n,2) = fac*scl_g(i,j,n)
         enddo
         enddo
         enddo
         do j=iys,iye
         do i=1,nnx
            gm_xu      = weit(k)*gm(i,j,kp1,1)*gm(i,j,kp1,2) +
     +                   weitm(k)*gm(i,j,k,1)*gm(i,j,k,2)
            gm_xl      = weit(km1)*gm(i,j,k,1)*gm(i,j,k,2) +
     +                   weitm(km1)*gm(i,j,km1,1)*gm(i,j,km1,2)
            gm_yu      = weit(k)*gm(i,j,kp1,1)*gm(i,j,kp1,3) +
     +                   weitm(k)*gm(i,j,k,1)*gm(i,j,k,3)
            gm_yl      = weit(km1)*gm(i,j,k,1)*gm(i,j,k,3) +
     +                   weitm(km1)*gm(i,j,km1,1)*gm(i,j,km1,3)
            tflx_up    = tflx(i,j,1,2)*gm_xu + tflx(i,j,2,2)*gm_yu +
     +                   tflx(i,j,3,2)
            tflx_lo    = tflx(i,j,1,1)*gm_xl + tflx(i,j,2,1)*gm_yl +
     +                   tflx(i,j,3,1)
            r4(i,j,iscl,k) = r4(i,j,iscl,k) + 
     +                       (tflx_up - tflx_lo)*dzw_i(k)
            if (k==1) then
            sfc_flx = sfc_flx + tflx_lo
            end if
         enddo
         enddo
c
c -------- save SGS fluxes for printout, gather sums on exit
c
         if(istep .eq. 1) then
            wtsb(k,iscl) = 0.0
            do j=iys,iye
            do i=1,nnx
               wtsb(k,iscl) = wtsb(k,iscl) - tflx(i,j,3,2)
            enddo
            enddo
            wtsb(k,iscl) = wtsb(k,iscl)*fnxy
         endif

      !As an aside, compute the values uwsfc and vwsfc for output:
      if (k==1 .and. isfc==1) then
         call mpi_sum_xy(sfc_flx,myid,iss,ise,1)
         wtsfc(iscl) = sfc_flx
      end if

c
c ---------- end z loop
c
      enddo
c
c ---------- resolved vertical advection
c
      if(iupwnd .ne. 1) then
c
c --------- skew symmetric advective form for
c           vertical flux = 0.5(wf*dt/dz + d/dz(wf*t))
c           no grid speed
c
      do k=izs,ize
         km1 = k - 1
         kp1 = k + 1
         do j=iys,iye
         do i=1,nnx
            tzm     = (t(i,j,iscl,k) - t(i,j,iscl,km1))*dzu_i(k)
            tz      = (t(i,j,iscl,kp1) - t(i,j,iscl,k))*dzu_i(kp1)
            theta_u = weitm(k)*t(i,j,iscl,k) +
     +                weit(k)*t(i,j,iscl,kp1)
            theta_l = weit(km1)*t(i,j,iscl,k) +
     +                weitm(km1)*t(i,j,iscl,km1)
            t_adv   = 0.5*(wf(i,j,k)*theta_u - 
     +                     wf(i,j,km1)*theta_l)*dzw_i(k) +
     +                0.25*(wf(i,j,k)*tz + wf(i,j,km1)*tzm)
            r4(i,j,iscl,k) = r4(i,j,iscl,k) - t_adv
         enddo
         enddo
      enddo
c
      else
c
c ----------- z-direction special with monotone
c
      do k=izs,ize
         km2 = k - 2
         km1 = k - 1
         kp1 = k + 1
         kp2 = k + 2
         if(k .eq. 1) then
              do j=iys,iye
              do i=1,nnx
                 wflx_l      = wf(i,j,km1) - gm(i,j,km1,5)
                 wflx_u      = wf(i,j,k)   - gm(i,j,k,5)
                 flux_l(i,j) = sgn*0.5*wflx_l*
     +                         (t(i,j,iscl,km1)+t(i,j,iscl,k))
                 flux_u(i,j) = 
     +           amax1(sgn*wflx_u,0.)*(t(i,j,iscl,k) +
     +           rlim(t(i,j,iscl,kp1),t(i,j,iscl,k),
     +                t(i,j,iscl,km1))) +
     +           amin1(sgn*wflx_u,0.)*(t(i,j,iscl,kp1) +
     +           rlim(t(i,j,iscl,k),t(i,j,iscl,kp1),
     +                t(i,j,iscl,kp2)))
              enddo
              enddo
         else if(k .eq. nnz) then
              do j=iys,iye
              do i=1,nnx
                 wflx_l      = wf(i,j,km1) - gm(i,j,km1,5)
                 wflx_u      = wf(i,j,k) - gm(i,j,k,5)
                 flux_u(i,j) = sgn*0.5*wflx_u*
     +                        (t(i,j,iscl,kp1)+t(i,j,iscl,k))
                 flux_l(i,j) = 
     +           amax1(sgn*wflx_l,0.)*(t(i,j,iscl,km1) +
     +           rlim(t(i,j,iscl,k),t(i,j,iscl,km1),
     +                t(i,j,iscl,km2))) +
     +           amin1(sgn*wflx_l,0.)*(t(i,j,iscl,k) +
     +           rlim(t(i,j,iscl,km1),t(i,j,iscl,k),
     +                t(i,j,iscl,kp1)))
              enddo
              enddo
         else
              do j=iys,iye
              do i=1,nnx
                 wflx_l      = wf(i,j,km1) - gm(i,j,km1,5)
                 wflx_u      = wf(i,j,k) - gm(i,j,k,5)
                 flux_u(i,j) = 
     +           amax1(sgn*wflx_u,0.)*(t(i,j,iscl,k) +
     +           rlim(t(i,j,iscl,kp1),t(i,j,iscl,k),
     +                t(i,j,iscl,km1))) +
     +           amin1(sgn*wflx_u,0.)*(t(i,j,iscl,kp1) +
     +           rlim(t(i,j,iscl,k),t(i,j,iscl,kp1),
     +                t(i,j,iscl,kp2)))
                 flux_l(i,j) = 
     +           amax1(sgn*wflx_l,0.)*(t(i,j,iscl,km1) +
     +           rlim(t(i,j,iscl,k),t(i,j,iscl,km1),
     +                t(i,j,iscl,km2))) +
     +           amin1(sgn*wflx_l,0.)*(t(i,j,iscl,k) +
     +           rlim(t(i,j,iscl,km1),t(i,j,iscl,k),
     +                t(i,j,iscl,kp1)))
              enddo
              enddo
         endif
c
c ---------- sum vertical monotone flux
c
         do j=iys,iye
         do i=1,nnx
            r4(i,j,iscl,k) = r4(i,j,iscl,k)
     +          - sgn*(flux_u(i,j) - flux_l(i,j))*dzw_i(k)
         enddo
         enddo
c
c ---------- end z loop
c
      enddo
c
c -------- end monotone if block
c
      endif
c
      return
      end
      subroutine rhs_scl(istep,iscl)
c
c ------ get right hand side of scalar equation (iscl)
c        monotone scalar fluxes only in z
c        for pencil size (nnx, iys:iye, izs:ize) 
c        care is taken so that if monotone is on then
c        conservative horizontal flux form is used!
c        uses flux conservation form for advection always
c
      use pars
      use fields
      use fftwk
      use con_data
      use con_stats
c
      real fnt1(nnx,iys:iye), fntd(nnx,iys:iye,izs:ize)
      real tx(nnx,iys:iye,izs-1:ize+1), ty(nnx,iys:iye,izs-1:ize+1)
      real flux_u(nnx,iys:iye), flux_l(nnx,iys:iye)
      real tflx(nnx,iys:iye,3,2), scl_g(nnx,iys:iye,3)
c
c --------- set sign for ocean simulations that use monotone
c
      sgn = 1.0
      if(iocean .eq. 1) sgn = -1.0
      if(iupwnd .eq. 1) then
         upfac = 1.0
      else
         upfac = 0.5
      endif
c
c --------- get x & y derivatives for [izs-1:ize+1]
c
      do k=izs-1,ize+1
         do j=iys,iye
         do i=1,nnx
            tx(i,j,k) = t(i,j,iscl,k)
            ty(i,j,k) = t(i,j,iscl,k)
         enddo
         enddo
         call xderivp(tx(1,iys,k),trigx(1,1),xk(1),nnx,iys,iye)
      enddo
      call yd_mpi(ty(1,iys,izs-1),trigx(1,2),yk(1),
     +           nnx,nny,ixs,ixe,ix_s,ix_e,
     +           iys,iye,iy_s,iy_e,izs-1,ize+1,myid,ncpu_s,numprocs)
c
c -------- SGS term tflx(.,.,1) + resolved flux at cell center
c          special treatment of first grid point off the wall,
c          average upper cell and boundary value to get cell
c          center value.
c
      do k=izs,ize
         kp1 = k + 1
         km1 = k - 1
         if(k .eq. 1) then
            call grads_u(scl_g,k,tx,ty,iscl)
            do j=iys,iye
            do i=1,nnx
               gm_u  = weit(k)*gm(i,j,kp1,1) + weitm(k)*gm(i,j,k,1)
               gm_l  = weit(km1)*gm(i,j,k,1) + weitm(km1)*gm(i,j,km1,1)
               fac   = weit(k)*vis_s(i,j,kp1) + weitm(k)*vis_s(i,j,k)
               tflx(i,j,1,1) = 0.5*(fac*scl_g(i,j,1)*gm_u -
     +                               t1tbc(i,j,iscl)*gm_l)
               tflx(i,j,2,1) = 0.5*(fac*scl_g(i,j,2)*gm_u -
     +                               t2tbc(i,j,iscl)*gm_l)
               fnt1(i,j)     = tflx(i,j,1,1) - 
     +                         upfac*uf(i,j,k)*t(i,j,iscl,k)
               fntd(i,j,k)   = tflx(i,j,2,1) - 
     +                         upfac*vf(i,j,k)*t(i,j,iscl,k)
            enddo
            enddo
         else
            call grads_c(scl_g,k,tx,ty,iscl)
            do j=iys,iye
            do i=1,nnx
               tflx(i,j,1,1) = vis_s(i,j,k)*scl_g(i,j,1)*gm(i,j,k,1)
               tflx(i,j,2,1) = vis_s(i,j,k)*scl_g(i,j,2)*gm(i,j,k,1)
               fnt1(i,j)     = tflx(i,j,1,1) - 
     +                         upfac*uf(i,j,k)*t(i,j,iscl,k)
               fntd(i,j,k)   = tflx(i,j,2,1) - 
     +                         upfac*vf(i,j,k)*t(i,j,iscl,k)
            enddo
            enddo
         endif
         call xderivp(fnt1(1,iys),trigx(1,1),xk(1),nnx,iys,iye)
         do j=iys,iye
         do i=1,nnx
            r4(i,j,iscl,k) = fnt1(i,j)
         enddo
         enddo
c
c -------- save SGS fluxes for printout
c
         if(istep .eq. 1) then
            utsb(k,iscl) = 0.0
            vtsb(k,iscl) = 0.0
            do j=iys,iye
            do i=1,nnx
               utsb(k,iscl) = utsb(k,iscl) - tflx(i,j,1,1)
               vtsb(k,iscl) = vtsb(k,iscl) - tflx(i,j,2,1)
            enddo
            enddo
            utsb(k,iscl) = utsb(k,iscl)*fnxy
            vtsb(k,iscl) = vtsb(k,iscl)*fnxy
         endif
      enddo
c
c ---------- SGS fluxes tflx(.,.,2) that depend on
c            y-derivative at cell centers
c
      call yd_mpi(fntd(1,iys,izs),trigx(1,2),yk(1),
     +           nnx,nny,ixs,ixe,ix_s,ix_e,
     +           iys,iye,iy_s,iy_e,izs,ize,myid,ncpu_s,numprocs)
      do k=izs,ize
         do j=iys,iye
         do i=1,nnx
            r4(i,j,iscl,k) = r4(i,j,iscl,k) + fntd(i,j,k)
         enddo
         enddo
      enddo
c
c ------- resolved advection for skew symmetric form
c         for no monotone
c
      if(iupwnd .ne. 1) then
c
      do k=izs,ize
         do j=iys,iye
         do i=1,nnx
            r4(i,j,iscl,k) = r4(i,j,iscl,k) - 
     +            upfac*(uf(i,j,k)*tx(i,j,k) + vf(i,j,k)*ty(i,j,k))
         enddo
         enddo
      enddo
      endif ! end of iupwnd check for horizontal advection
c
c ----------- SGS z-contributions
c
      if(izs .eq. 1) then
         do j=iys,iye
         do i=1,nnx
            tflx(i,j,1,2) = -t1tbc(i,j,iscl)
            tflx(i,j,2,2) = -t2tbc(i,j,iscl)
            tflx(i,j,3,2) = -t3tbc(i,j,iscl)
         enddo
         enddo
      else
         call grads_u(scl_g,izs-1,tx,ty,iscl)
         do n=1,3
         do j=iys,iye
         do i=1,nnx
            fac   = weit(izs-1)*vis_s(i,j,izs) +
     +              weitm(izs-1)*vis_s(i,j,izs-1)
            tflx(i,j,n,2) = fac*scl_g(i,j,n)
         enddo
         enddo
         enddo
      endif
      do k=izs,ize
         kp1 = k + 1
         km1 = k - 1
         do n=1,3
         do j=iys,iye
         do i=1,nnx
            tflx(i,j,n,1) = tflx(i,j,n,2)
         enddo
         enddo
         enddo
         call grads_u(scl_g,k,tx,ty,iscl)
         do n=1,3
         do j=iys,iye
         do i=1,nnx
            fac   = weit(k)*vis_s(i,j,kp1) + weitm(k)*vis_s(i,j,k)
            tflx(i,j,n,2) = fac*scl_g(i,j,n)
         enddo
         enddo
         enddo
         do j=iys,iye
         do i=1,nnx
            gm_xu      = weit(k)*gm(i,j,kp1,1)*gm(i,j,kp1,2) +
     +                   weitm(k)*gm(i,j,k,1)*gm(i,j,k,2)
            gm_xl      = weit(km1)*gm(i,j,k,1)*gm(i,j,k,2) +
     +                   weitm(km1)*gm(i,j,km1,1)*gm(i,j,km1,2)
            gm_yu      = weit(k)*gm(i,j,kp1,1)*gm(i,j,kp1,3) +
     +                   weitm(k)*gm(i,j,k,1)*gm(i,j,k,3)
            gm_yl      = weit(km1)*gm(i,j,k,1)*gm(i,j,k,3) +
     +                   weitm(km1)*gm(i,j,km1,1)*gm(i,j,km1,3)
            tflx_up    = tflx(i,j,1,2)*gm_xu + tflx(i,j,2,2)*gm_yu +
     +                   tflx(i,j,3,2)
            tflx_lo    = tflx(i,j,1,1)*gm_xl + tflx(i,j,2,1)*gm_yl +
     +                   tflx(i,j,3,1)
            r4(i,j,iscl,k) = r4(i,j,iscl,k) + 
     +                       (tflx_up - tflx_lo)*dzw_i(k)
         enddo
         enddo
c
c -------- save SGS fluxes for printout, gather sums on exit
c
         if(istep .eq. 1) then
            wtsb(k,iscl) = 0.0
            do j=iys,iye
            do i=1,nnx
               wtsb(k,iscl) = wtsb(k,iscl) - tflx(i,j,3,2)
            enddo
            enddo
            wtsb(k,iscl) = wtsb(k,iscl)*fnxy
         endif
c
c ---------- end z loop
c
      enddo
c
c ---------- resolved vertical advection
c
      if(iupwnd .ne. 1) then
c
c --------- skew symmetric advective form for
c           vertical flux = 0.5(wf*dt/dz + d/dz(wf*t))
c           no grid speed
c
      do k=izs,ize
         km1 = k - 1
         kp1 = k + 1
         do j=iys,iye
         do i=1,nnx
            tzm     = (t(i,j,iscl,k) - t(i,j,iscl,km1))*dzu_i(k)
            tz      = (t(i,j,iscl,kp1) - t(i,j,iscl,k))*dzu_i(kp1)
            theta_u = weitm(k)*t(i,j,iscl,k) +
     +                weit(k)*t(i,j,iscl,kp1)
            theta_l = weit(km1)*t(i,j,iscl,k) +
     +                weitm(km1)*t(i,j,iscl,km1)
            t_adv   = 0.5*(wf(i,j,k)*theta_u - 
     +                     wf(i,j,km1)*theta_l)*dzw_i(k) +
     +                0.25*(wf(i,j,k)*tz + wf(i,j,km1)*tzm)
            r4(i,j,iscl,k) = r4(i,j,iscl,k) - t_adv
         enddo
         enddo
      enddo
c
      else
c
c ----------- z-direction special with monotone
c
      do k=izs,ize
         km2 = k - 2
         km1 = k - 1
         kp1 = k + 1
         kp2 = k + 2
         if(k .eq. 1) then
              do j=iys,iye
              do i=1,nnx
                 wflx_l      = wf(i,j,km1) - gm(i,j,km1,5)
                 wflx_u      = wf(i,j,k)   - gm(i,j,k,5)
                 flux_l(i,j) = sgn*0.5*wflx_l*
     +                         (t(i,j,iscl,km1)+t(i,j,iscl,k))
                 flux_u(i,j) = 
     +           amax1(sgn*wflx_u,0.)*(t(i,j,iscl,k) +
     +           rlim(t(i,j,iscl,kp1),t(i,j,iscl,k),
     +                t(i,j,iscl,km1))) +
     +           amin1(sgn*wflx_u,0.)*(t(i,j,iscl,kp1) +
     +           rlim(t(i,j,iscl,k),t(i,j,iscl,kp1),
     +                t(i,j,iscl,kp2)))
              enddo
              enddo
         else if(k .eq. nnz) then
              do j=iys,iye
              do i=1,nnx
                 wflx_l      = wf(i,j,km1) - gm(i,j,km1,5)
                 wflx_u      = wf(i,j,k) - gm(i,j,k,5)
                 flux_u(i,j) = sgn*0.5*wflx_u*
     +                        (t(i,j,iscl,kp1)+t(i,j,iscl,k))
                 flux_l(i,j) = 
     +           amax1(sgn*wflx_l,0.)*(t(i,j,iscl,km1) +
     +           rlim(t(i,j,iscl,k),t(i,j,iscl,km1),
     +                t(i,j,iscl,km2))) +
     +           amin1(sgn*wflx_l,0.)*(t(i,j,iscl,k) +
     +           rlim(t(i,j,iscl,km1),t(i,j,iscl,k),
     +                t(i,j,iscl,kp1)))
              enddo
              enddo
         else
              do j=iys,iye
              do i=1,nnx
                 wflx_l      = wf(i,j,km1) - gm(i,j,km1,5)
                 wflx_u      = wf(i,j,k) - gm(i,j,k,5)
                 flux_u(i,j) = 
     +           amax1(sgn*wflx_u,0.)*(t(i,j,iscl,k) +
     +           rlim(t(i,j,iscl,kp1),t(i,j,iscl,k),
     +                t(i,j,iscl,km1))) +
     +           amin1(sgn*wflx_u,0.)*(t(i,j,iscl,kp1) +
     +           rlim(t(i,j,iscl,k),t(i,j,iscl,kp1),
     +                t(i,j,iscl,kp2)))
                 flux_l(i,j) = 
     +           amax1(sgn*wflx_l,0.)*(t(i,j,iscl,km1) +
     +           rlim(t(i,j,iscl,k),t(i,j,iscl,km1),
     +                t(i,j,iscl,km2))) +
     +           amin1(sgn*wflx_l,0.)*(t(i,j,iscl,k) +
     +           rlim(t(i,j,iscl,km1),t(i,j,iscl,k),
     +                t(i,j,iscl,kp1)))
              enddo
              enddo
         endif
c
c ---------- sum vertical monotone flux
c
         do j=iys,iye
         do i=1,nnx
            r4(i,j,iscl,k) = r4(i,j,iscl,k)
     +          - sgn*(flux_u(i,j) - flux_l(i,j))*dzw_i(k)
         enddo
         enddo
c
c ---------- end z loop
c
      enddo
c
c -------- end monotone if block
c
      endif
c
      return
      end
      subroutine rhs_scl_old(istep,iscl)
c
c ------ get right hand side of scalar equation (iscl)
c        monotone scalar fluxes only in z
c        for pencil size (nnx, iys:iye, izs:ize) 
c        care is taken so that if monotone is on then
c        conservative horizontal flux form is used!
c        uses flux conservation form for advection always
c
      use pars
      use fields
      use fftwk
      use con_data
      use con_stats
c
      real fnt1(nnx,iys:iye), fntd(nnx,iys:iye,izs:ize)
      real tx(nnx,iys:iye,izs-1:ize+1), ty(nnx,iys:iye,izs-1:ize+1)
      real flux_u(nnx,iys:iye), flux_l(nnx,iys:iye)
      real tflx(nnx,iys:iye,3,2), scl_g(nnx,iys:iye,3)
c
c --------- set sign for ocean simulations that use monotone
c
      sgn = 1.0
      if(iocean .eq. 1) sgn = -1.0
      if(iupwnd .eq. 1) then
         upfac = 1.0
      else
         upfac = 0.5
      endif
c
c --------- get x & y derivatives for [izs-1:ize+1]
c
      do k=izs-1,ize+1
         do j=iys,iye
         do i=1,nnx
            tx(i,j,k) = t(i,j,iscl,k)
            ty(i,j,k) = t(i,j,iscl,k)
         enddo
         enddo
         call xderivp(tx(1,iys,k),trigx(1,1),xk(1),nnx,iys,iye)
      enddo
      call yd_mpi(ty(1,iys,izs-1),trigx(1,2),yk(1),
     +           nnx,nny,ixs,ixe,ix_s,ix_e,
     +           iys,iye,iy_s,iy_e,izs-1,ize+1,myid,ncpu_s,numprocs)
c
c -------- SGS term tflx(.,.,1) + resolved flux at cell center
c
      do k=izs,ize
         call grads_c(scl_g,k,tx,ty,iscl)
         do j=iys,iye
         do i=1,nnx
            tflx(i,j,1,1) = vis_s(i,j,k)*scl_g(i,j,1) 
            tflx(i,j,2,1) = vis_s(i,j,k)*scl_g(i,j,2) 
            fnt1(i,j)     = gm(i,j,k,1)*tflx(i,j,1,1) - 
     +                      upfac*uf(i,j,k)*t(i,j,iscl,k)
            fntd(i,j,k)   = gm(i,j,k,1)*tflx(i,j,2,1) - 
     +                      upfac*vf(i,j,k)*t(i,j,iscl,k)
         enddo
         enddo
         call xderivp(fnt1(1,iys),trigx(1,1),xk(1),nnx,iys,iye)
         do j=iys,iye
         do i=1,nnx
            r4(i,j,iscl,k) = fnt1(i,j)
         enddo
         enddo
c
c -------- save SGS fluxes for printout
c
         if(istep .eq. 1) then
            utsb(k,iscl) = 0.0
            vtsb(k,iscl) = 0.0
            do j=iys,iye
            do i=1,nnx
               utsb(k,iscl) = utsb(k,iscl) - tflx(i,j,1,1)
               vtsb(k,iscl) = vtsb(k,iscl) - tflx(i,j,2,1)
            enddo
            enddo
            utsb(k,iscl) = utsb(k,iscl)*fnxy
            vtsb(k,iscl) = vtsb(k,iscl)*fnxy
         endif
      enddo
c
c ---------- SGS fluxes tflx(.,.,2) that depend on
c            y-derivative at cell centers
c
      call yd_mpi(fntd(1,iys,izs),trigx(1,2),yk(1),
     +           nnx,nny,ixs,ixe,ix_s,ix_e,
     +           iys,iye,iy_s,iy_e,izs,ize,myid,ncpu_s,numprocs)
      do k=izs,ize
         do j=iys,iye
         do i=1,nnx
            r4(i,j,iscl,k) = r4(i,j,iscl,k) + fntd(i,j,k)
         enddo
         enddo
      enddo
c
c ------- resolved advection for skew symmetric form
c         for no monotone
c
      if(iupwnd .ne. 1) then
c
      do k=izs,ize
         do j=iys,iye
         do i=1,nnx
            r4(i,j,iscl,k) = r4(i,j,iscl,k) - 
     +            upfac*(uf(i,j,k)*tx(i,j,k) + vf(i,j,k)*ty(i,j,k))
         enddo
         enddo
      enddo
      endif
c
c ----------- SGS z-contributions
c
      if(izs .eq. 1) then
         do j=iys,iye
         do i=1,nnx
            tflx(i,j,1,2) = -t1tbc(i,j,iscl)
            tflx(i,j,2,2) = -t2tbc(i,j,iscl)
            tflx(i,j,3,2) = -t3tbc(i,j,iscl)
         enddo
         enddo
      else
         call grads_u(scl_g,izs-1,tx,ty,iscl)
         do n=1,3
         do j=iys,iye
         do i=1,nnx
            fac   = weit(izs-1)*vis_s(i,j,izs) +
     +              weitm(izs-1)*vis_s(i,j,izs-1)
            tflx(i,j,n,2) = fac*scl_g(i,j,n)
         enddo
         enddo
         enddo
      endif
      do k=izs,ize
         kp1 = k + 1
         km1 = k - 1
         do n=1,3
         do j=iys,iye
         do i=1,nnx
            tflx(i,j,n,1) = tflx(i,j,n,2)
         enddo
         enddo
         enddo
         call grads_u(scl_g,k,tx,ty,iscl)
         do n=1,3
         do j=iys,iye
         do i=1,nnx
            fac   = weit(k)*vis_s(i,j,kp1) + weitm(k)*vis_s(i,j,k)
            tflx(i,j,n,2) = fac*scl_g(i,j,n)
         enddo
         enddo
         enddo
         do j=iys,iye
         do i=1,nnx
            gm_xu      = weit(k)*gm(i,j,kp1,1)*gm(i,j,kp1,2) +
     +                   weitm(k)*gm(i,j,k,1)*gm(i,j,k,2)
            gm_xl      = weit(km1)*gm(i,j,k,1)*gm(i,j,k,2) +
     +                   weitm(km1)*gm(i,j,km1,1)*gm(i,j,km1,2)
            gm_yu      = weit(k)*gm(i,j,kp1,1)*gm(i,j,kp1,3) +
     +                   weitm(k)*gm(i,j,k,1)*gm(i,j,k,3)
            gm_yl      = weit(km1)*gm(i,j,k,1)*gm(i,j,k,3) +
     +                   weitm(km1)*gm(i,j,km1,1)*gm(i,j,km1,3)
            tflx_up    = tflx(i,j,1,2)*gm_xu + tflx(i,j,2,2)*gm_yu +
     +                   tflx(i,j,3,2)
            tflx_lo    = tflx(i,j,1,1)*gm_xl + tflx(i,j,2,1)*gm_yl +
     +                   tflx(i,j,3,1)
            r4(i,j,iscl,k) = r4(i,j,iscl,k) + 
     +                       (tflx_up - tflx_lo)*dzw_i(k)
         enddo
         enddo
c
c -------- save SGS fluxes for printout, gather sums on exit
c
         if(istep .eq. 1) then
            wtsb(k,iscl) = 0.0
            do j=iys,iye
            do i=1,nnx
               wtsb(k,iscl) = wtsb(k,iscl) - tflx(i,j,3,2)
            enddo
            enddo
            wtsb(k,iscl) = wtsb(k,iscl)*fnxy
         endif
c
c ---------- end z loop
c
      enddo
c
c ---------- resolved vertical advection
c
      if(iupwnd .ne. 1) then
c
c --------- skew symmetric advective form for
c           vertical flux = 0.5(wf*dt/dz + d/dz(wf*t))
c           no grid speed
c
      do k=izs,ize
         km1 = k - 1
         kp1 = k + 1
         do j=iys,iye
         do i=1,nnx
            tzm     = (t(i,j,iscl,k) - t(i,j,iscl,km1))*dzu_i(k)
            tz      = (t(i,j,iscl,kp1) - t(i,j,iscl,k))*dzu_i(kp1)
            theta_u = weitm(k)*t(i,j,iscl,k) +
     +                weit(k)*t(i,j,iscl,kp1)
            theta_l = weit(km1)*t(i,j,iscl,k) +
     +                weitm(km1)*t(i,j,iscl,km1)
            t_adv   = 0.5*(wf(i,j,k)*theta_u - 
     +                     wf(i,j,km1)*theta_l)*dzw_i(k) +
     +                0.25*(wf(i,j,k)*tz + wf(i,j,km1)*tzm)
            r4(i,j,iscl,k) = r4(i,j,iscl,k) - t_adv
         enddo
         enddo
      enddo
c
      else
c
c ----------- z-direction special with monotone
c
      do k=izs,ize
         km2 = k - 2
         km1 = k - 1
         kp1 = k + 1
         kp2 = k + 2
         if(k .eq. 1) then
              do j=iys,iye
              do i=1,nnx
                 wflx_l      = wf(i,j,km1) - gm(i,j,km1,5)
                 wflx_u      = wf(i,j,k)   - gm(i,j,k,5)
                 flux_l(i,j) = sgn*0.5*wflx_l*
     +                         (t(i,j,iscl,km1)+t(i,j,iscl,k))
                 flux_u(i,j) = 
     +           amax1(sgn*wflx_u,0.)*(t(i,j,iscl,k) +
     +           rlim(t(i,j,iscl,kp1),t(i,j,iscl,k),
     +                t(i,j,iscl,km1))) +
     +           amin1(sgn*wflx_u,0.)*(t(i,j,iscl,kp1) +
     +           rlim(t(i,j,iscl,k),t(i,j,iscl,kp1),
     +                t(i,j,iscl,kp2)))
              enddo
              enddo
         else if(k .eq. nnz) then
              do j=iys,iye
              do i=1,nnx
                 wflx_l      = wf(i,j,km1) - gm(i,j,km1,5)
                 wflx_u      = wf(i,j,k) - gm(i,j,k,5)
                 flux_u(i,j) = sgn*0.5*wflx_u*
     +                        (t(i,j,iscl,kp1)+t(i,j,iscl,k))
                 flux_l(i,j) = 
     +           amax1(sgn*wflx_l,0.)*(t(i,j,iscl,km1) +
     +           rlim(t(i,j,iscl,k),t(i,j,iscl,km1),
     +                t(i,j,iscl,km2))) +
     +           amin1(sgn*wflx_l,0.)*(t(i,j,iscl,k) +
     +           rlim(t(i,j,iscl,km1),t(i,j,iscl,k),
     +                t(i,j,iscl,kp1)))
              enddo
              enddo
         else
              do j=iys,iye
              do i=1,nnx
                 wflx_l      = wf(i,j,km1) - gm(i,j,km1,5)
                 wflx_u      = wf(i,j,k) - gm(i,j,k,5)
                 flux_u(i,j) = 
     +           amax1(sgn*wflx_u,0.)*(t(i,j,iscl,k) +
     +           rlim(t(i,j,iscl,kp1),t(i,j,iscl,k),
     +                t(i,j,iscl,km1))) +
     +           amin1(sgn*wflx_u,0.)*(t(i,j,iscl,kp1) +
     +           rlim(t(i,j,iscl,k),t(i,j,iscl,kp1),
     +                t(i,j,iscl,kp2)))
                 flux_l(i,j) = 
     +           amax1(sgn*wflx_l,0.)*(t(i,j,iscl,km1) +
     +           rlim(t(i,j,iscl,k),t(i,j,iscl,km1),
     +                t(i,j,iscl,km2))) +
     +           amin1(sgn*wflx_l,0.)*(t(i,j,iscl,k) +
     +           rlim(t(i,j,iscl,km1),t(i,j,iscl,k),
     +                t(i,j,iscl,kp1)))
              enddo
              enddo
         endif
c
c ---------- sum vertical monotone flux
c
         do j=iys,iye
         do i=1,nnx
            r4(i,j,iscl,k) = r4(i,j,iscl,k)
     +          - sgn*(flux_u(i,j) - flux_l(i,j))*dzw_i(k)
         enddo
         enddo
c
c ---------- end z loop
c
      enddo
c
c -------- end monotone if block
c
      endif
c
      return
      end
      subroutine grads_u(scl_u,k,tx,ty,iscl)
c
c ---------- get scalar gradient at upper face at the k-level
c
c        gradient definitions
c
c        tx   = txi  + tzet*gm_x
c        ty   = teta + tzet*gm_y
c        tz   = tzet*gm_z
c
      use pars
      use fields
      use fftwk
      use con_data
      use con_stats
      real scl_u(nnx,iys:iye,3)
      real tx(nnx,iys:iye,izs-1:ize+1), ty(nnx,iys:iye,izs-1:ize+1)
c
      km1  = k - 1
      kp1  = k + 1
      w1   = weit(k)
      w1m  = weitm(k)
      w2   = weit(km1)
      w2m  = weitm(km1)
c
c -------- at upper face
c
      do j=iys,iye
      do i=1,nnx
         tzet  = (t(i,j,iscl,kp1) - t(i,j,iscl,k))*dzu_i(kp1) 
         txi   = w1*tx(i,j,kp1) + w1m*tx(i,j,k)
         teta  = w1*ty(i,j,kp1) + w1m*ty(i,j,k)
         gm_x  = w1*gm(i,j,kp1,2) + w1m*gm(i,j,k,2)
         gm_y  = w1*gm(i,j,kp1,3) + w1m*gm(i,j,k,3)
         gm_z  = w1*gm(i,j,kp1,4) +  w1m*gm(i,j,k,4)
         scl_u(i,j,1) = txi  + tzet*gm_x
         scl_u(i,j,2) = teta + tzet*gm_y
         scl_u(i,j,3) = tzet*gm_z
      enddo
      enddo
c
      return
      end
      subroutine grads_c_dns(scl_c,k,tx,ty,iscl)
c
c ---------- get scalar gradient at the cell center 
c
c        gradient definitions
c
c        tx   = txi  + tzet*gm_x
c        ty   = teta + tzet*gm_y
c        tz   = tzet*gm_z
c
      use pars
      use fields
      use fftwk
      use con_data
      use con_stats
      real scl_c(nnx,iys:iye,3)
      real tx(nnx,iys:iye,izs-1:ize+1), ty(nnx,iys:iye,izs-1:ize+1)
c
      km1  = k - 1
      kp1  = k + 1
      w1   = weit(k)
      w1m  = weitm(k)
      w2   = weit(km1)
      w2m  = weitm(km1)
c
      if(k == 1) then
c
      do j=iys,iye
      do i=1,nnx
         tzet  = (t(i,j,iscl,kp1) - t(i,j,iscl,k))*dzu_i(kp1)
         scl_c(i,j,1) = tx(i,j,k) + tzet*gm(i,j,k,2)
         scl_c(i,j,2) = ty(i,j,k) + tzet*gm(i,j,k,3)
         scl_c(i,j,3) = tzet*gm(i,j,k,4)
      enddo
      enddo
      else
c
c -------- at cell center
c
      do j=iys,iye
      do i=1,nnx
         tup   = w1*t(i,j,iscl,kp1) + w1m*t(i,j,iscl,k)
         tlo   = w2*t(i,j,iscl,k) + w2m*t(i,j,iscl,km1)
         tzet  = (tup - tlo)*dzw_i(k) 
         scl_c(i,j,1) = tx(i,j,k) + tzet*gm(i,j,k,2)
         scl_c(i,j,2) = ty(i,j,k) + tzet*gm(i,j,k,3)
         scl_c(i,j,3) = tzet*gm(i,j,k,4)
      enddo
      enddo
c
      endif
c
      return
      end
      subroutine grads_c(scl_c,k,tx,ty,iscl)
c
c ---------- get scalar gradient at the cell center 
c
c        gradient definitions
c
c        tx   = txi  + tzet*gm_x
c        ty   = teta + tzet*gm_y
c        tz   = tzet*gm_z
c
      use pars
      use fields
      use fftwk
      use con_data
      use con_stats
      real scl_c(nnx,iys:iye,3)
      real tx(nnx,iys:iye,izs-1:ize+1), ty(nnx,iys:iye,izs-1:ize+1)
c
      km1  = k - 1
      kp1  = k + 1
      w1   = weit(k)
      w1m  = weitm(k)
      w2   = weit(km1)
      w2m  = weitm(km1)
c
      if(k == 1) then
c
      do j=iys,iye
      do i=1,nnx
         tzet  = (t(i,j,iscl,kp1) - t(i,j,iscl,k))*dzu_i(kp1)
         scl_c(i,j,1) = tx(i,j,k) + tzet*gm(i,j,k,2)
         scl_c(i,j,2) = ty(i,j,k) + tzet*gm(i,j,k,3)
         scl_c(i,j,3) = tzet*gm(i,j,k,4)
      enddo
      enddo
      else
c
c -------- at cell center
c
      do j=iys,iye
      do i=1,nnx
         tup   = w1*t(i,j,iscl,kp1) + w1m*t(i,j,iscl,k)
         tlo   = w2*t(i,j,iscl,k) + w2m*t(i,j,iscl,km1)
         tzet  = (tup - tlo)*dzw_i(k) 
         scl_c(i,j,1) = tx(i,j,k) + tzet*gm(i,j,k,2)
         scl_c(i,j,2) = ty(i,j,k) + tzet*gm(i,j,k,3)
         scl_c(i,j,3) = tzet*gm(i,j,k,4)
      enddo
      enddo
c
      endif
c
      return
      end
      subroutine dns_vis
      use particles
      use pars
      use fields
      implicit none

!     In DNS mode, just set the molecular viscosity (and scalar diffusivities)
!     Also, to make the rest of code work, set the rhs of e equation to 0

      !Both for air at the moment:
      vis_m = muf
      !Use Prantdl number for thermal diffusivity:
      vis_s = muf/Pra

      r5 = 0.0
      e = 0.0

      end
      subroutine tke_vis(istep)
c
c ------ get viscosity using deardorff tke model with
c        stability correction. fixes for surface layer. 
c        get rhs of e-equation/J. field variables are
c        (u,v,w,e,theta) all at cell center. get viscosity
c        at cell center also.
c        "length scale" based on the volume in physical space
c
c        volume = gm(.,.,.,1)*d_zeta*d_eta*d_xi 
c        (fletcher, vol2 1988, p. 51)
c
      use pars
      use fields
      use fftwk
      use con_data
      use con_stats
c
      real ex(nnx,iys:iye,izs-1:ize+1), ey(nnx,iys:iye,izs-1:ize+1)
      real fnt1(nnx,iys:iye), fntd(nnx,iys:iye,izs:ize)
      real dissp(nnx,iys:iye), alk(nnx,iys:iye), sij(nnx,iys:iye,6)
      real eflx(nnx,iys:iye,3,2), e_g(nnx,iys:iye,3)
      real rj3(nnx,iys:iye)
c
c -------- see par statments for setting k_stab
c
      do k=max(izs-1,1),min(nnz,ize+1)
c
      kp1  = k + 1
      km1  = k - 1
      w1   = weit(k)
      w1m  = weitm(k)
      w2   = weit(km1)
      w2m  = weitm(km1)
      dslk = dsl_z(k)
c
      do j=iys,iye
      do i=1,nnx
         rj3(i,j) = gm(i,j,k,1)**pow3
      enddo
      enddo
c
      if(k .gt. 0) dslk  = amin1(dsl_z(k),vk*abs(z(k))/csmag)
      almin = almin_c*dsl_z(k)
      if(k .eq. 0 .or. k .eq. nnz+1) then
         dfack = 1.0
      else
         dfack = dfac(k)
      endif
c     if(ivis .eq. 1 .and. k .le. nmatch) then
c
      if(k .le. k_stab) then
c
c --------------- no stability corrected length scales
c
         do j=iys,iye
         do i=1,nnx
            alk(i,j) = dslk*rj3(i,j)
         end do
         end do
      else
         do j=iys,iye
         do i=1,nnx
            alk(i,j) = dslk*rj3(i,j)
            tup  = w1*t(i,j,1,kp1) + w1m*t(i,j,1,k)
            tlo  = w2*t(i,j,1,k) + w2m*t(i,j,1,km1)
            stab = gm(i,j,k,4)*batag*(tup - tlo)*dzw_i(k)
            if(stab .gt. stabmin) then
              als = stab_c*sqrt(e(i,j,k)/stab)
              alk(i,j) = amin1(dslk,als)*rj3(i,j)
            endif
            alk(i,j)  = amax1(almin*rj3(i,j),alk(i,j))
         enddo
         enddo
      endif
      do j=iys,iye
      do i=1,nnx
         vis_m(i,j,k) = ck*alk(i,j)*sqrt(e(i,j,k))*dfack
         vis_s(i,j,k) = (1.0 + 2.0*alk(i,j)/(dslk*rj3(i,j)))*
     +                  vis_m(i,j,k)
      enddo
      enddo
c
c -------------- special case at bottom and top
c
      if(k == 1) then
         do j=iys,iye
         do i=1,nnx
            vis_m(i,j,km1) = vis_m(i,j,k)
            vis_s(i,j,km1) = vis_s(i,j,k)
         enddo
         enddo
      elseif(k == nnz) then
         do j=iys,iye
         do i=1,nnx
            vis_m(i,j,kp1) = vis_m(i,j,k)
            vis_s(i,j,kp1) = vis_s(i,j,k)
         enddo
         enddo
      endif
c
      if(k .ge. izs .and. k .le. ize) then
c
c -------- to avoid storing length scale get dissipation
c          and shear production with cell centered strains
c          special at lower boundary
c
      call strain_c(sij,k)
      if(k .eq. 1) then
         do j=iys,iye
         do i=1,nnx
            fac       = 2.0*(weit(k)*vis_m(i,j,k+1) + 
     +                       weitm(k)*vis_m(i,j,k))
            tau11_s11 = 0.5*(fac*sij(i,j,1) - t11bc(i,j))*sij(i,j,1)
            tau12_s12 = 0.5*(fac*sij(i,j,2) - t12bc(i,j))*sij(i,j,2)
            tau13_s13 = 0.5*(fac*sij(i,j,3) - t13bc(i,j))*sij(i,j,3)
            tau22_s22 = 0.5*(fac*sij(i,j,4) - t22bc(i,j))*sij(i,j,4)
            tau23_s23 = 0.5*(fac*sij(i,j,5) - t23bc(i,j))*sij(i,j,5)
            tau33_s33 = 0.5*(fac*sij(i,j,6) - t33bc(i,j))*sij(i,j,6)
            fnt1(i,j) = tau11_s11 + tau22_s22 + tau33_s33 +
     +                  2.0*(tau12_s12 + tau13_s13 + tau23_s23)
         enddo
         enddo
      else
         do j=iys,iye
         do i=1,nnx
            fnt1(i,j)  = 2.0*vis_m(i,j,k)*(
     +            sij(i,j,1)**2 + sij(i,j,4)**2 + sij(i,j,6)**2 + 
     +            2.0*(sij(i,j,2)**2 + sij(i,j,3)**2 + sij(i,j,5)**2))
         enddo
         enddo
      endif
c
      do j=iys,iye
      do i=1,nnx
         dissp(i,j) = (0.19 + 0.74*alk(i,j)/(dslk*rj3(i,j)))*
     +                 e(i,j,k)*sqrt(e(i,j,k))/alk(i,j)
         r5(i,j,k) = (fnt1(i,j) - dissp(i,j))*gm(i,j,k,1)
      enddo
      enddo
c
      if(istep .eq. 1) then
         t_diss(k) = 0.0
         shrz(k)   = 0.0
         triz(k)   = 0.0
         do j=iys,iye
         do i=1,nnx
            t_diss(k) = t_diss(k) + dissp(i,j)
            shrz(k)   = shrz(k) + fnt1(i,j)
         enddo
         enddo
         t_diss(k) = t_diss(k)*fnxy
         shrz(k)   = shrz(k)*fnxy
      endif
c
      endif   ! endif for k = [izs,ize]
c
c -------------- end z loop
c
      enddo
c
c -------------- if special 2 part surface layer model is on
c                get "mean" viscosity
CHECK 2-part for curvy?
c
c     do k=izs-1,ize
c        km1         = k - 1
c        kp1         = k + 1
c        vis_mean(k) = 0.0
c        if(ivis .eq. 1 .and. k .le. nmatch) then
c           if(k .le. 1) then
c             vis_mean(k) = xksurf
c           else
c             stravg = sqrt((u_mn(kp1)-u_mn(k))**2 + 
c    +              (v_mn(kp1)-v_mn(k))**2)*abs(dzu_i(kp1))
c             vis_mean(k) = xksurf*viscon*stravg
c           endif
c        endif
c     enddo
c
c --------- get x & y derivatives for [izs-1:ize+1]
c
      do k=izs-1,ize+1
         do j=iys,iye
         do i=1,nnx
            ex(i,j,k) = e(i,j,k)
            ey(i,j,k) = e(i,j,k)
         enddo
         enddo
         call xderivp(ex(1,iys,k),trigx(1,1),xk(1),nnx,iys,iye)
      enddo
      call yd_mpi(ey(1,iys,izs-1),trigx(1,2),yk(1),
     +           nnx,nny,ixs,ixe,ix_s,ix_e,
     +           iys,iye,iy_s,iy_e,izs-1,ize+1,myid,ncpu_s,numprocs)
c
c -------- diffusion term eflx(.,.,1) + resolved flux at cell center
c
      do k=izs,ize
         call grd_e_c(e_g,k,ex,ey)
         do j=iys,iye
         do i=1,nnx
            eflx(i,j,1,1) = 2.0*vis_m(i,j,k)*e_g(i,j,1)
            eflx(i,j,2,1) = 2.0*vis_m(i,j,k)*e_g(i,j,2)
            fnt1(i,j)     = gm(i,j,k,1)*eflx(i,j,1,1) -
     +                      uf(i,j,k)*e(i,j,k)
            fntd(i,j,k)   = gm(i,j,k,1)*eflx(i,j,2,1) -
     +                      vf(i,j,k)*e(i,j,k)
         enddo
         enddo
         call xderivp(fnt1(1,iys),trigx(1,1),xk(1),nnx,iys,iye)
         do j=iys,iye
         do i=1,nnx
            r5(i,j,k) = r5(i,j,k) + fnt1(i,j)
         enddo
         enddo
      enddo
c
c -------- diffusion term eflx(.,.,2) + resolved flux at cell center
c
      call yd_mpi(fntd(1,iys,izs),trigx(1,2),yk(1),
     +           nnx,nny,ixs,ixe,ix_s,ix_e,
     +           iys,iye,iy_s,iy_e,izs,ize,myid,ncpu_s,numprocs)
      do k=izs,ize
         do j=iys,iye
         do i=1,nnx
            r5(i,j,k) = r5(i,j,k) + fntd(i,j,k)
         enddo
         enddo
      enddo
c
c --------- z-diffusion term + resolved vertical flux
c           no divergence of flux at first gridpoint
c
      k   = izs
      km1 = izs - 1
      kp1 = izs + 1
      if(izs .eq. 1) then
         do j=iys,iye
         do i=1,nnx
            e(i,j,km1)  = e(i,j,k)
            ex(i,j,km1) = ex(i,j,k)
            ey(i,j,km1) = ey(i,j,k)
         enddo
         enddo
      endif
      call grd_e_u(e_g,k,ex,ey)
      do n=1,3
      do j=iys,iye
      do i=1,nnx
         fac   = weit(k)*vis_m(i,j,kp1) +
     +              weitm(k)*vis_m(i,j,k)
         eflx(i,j,n,2) = 2.0*fac*e_g(i,j,n)
      enddo
      enddo
      enddo
c
      do k=izs,ize
         kp1 = k + 1
         km1 = k - 1
         do n=1,3
         do j=iys,iye
         do i=1,nnx
            eflx(i,j,n,1) = eflx(i,j,n,2)
         enddo
         enddo
         enddo
         call grd_e_u(e_g,k,ex,ey)
         do n=1,3
         do j=iys,iye
         do i=1,nnx
            fac   = weit(k)*vis_m(i,j,kp1) + weitm(k)*vis_m(i,j,k)
            eflx(i,j,n,2) = 2.0*fac*e_g(i,j,n)
         enddo
         enddo
         enddo
         do j=iys,iye
         do i=1,nnx
            gm_xu     = weit(k)*gm(i,j,kp1,1)*gm(i,j,kp1,2) +
     +                  weitm(k)*gm(i,j,k,1)*gm(i,j,k,2)
            gm_xl     = weit(km1)*gm(i,j,k,1)*gm(i,j,k,2) +
     +                  weitm(km1)*gm(i,j,km1,1)*gm(i,j,km1,2)
            gm_yu     = weit(k)*gm(i,j,kp1,1)*gm(i,j,kp1,3) +
     +                  weitm(k)*gm(i,j,k,1)*gm(i,j,k,3)
            gm_yl     = weit(km1)*gm(i,j,k,1)*gm(i,j,k,3) +
     +                  weitm(km1)*gm(i,j,km1,1)*gm(i,j,km1,3)
            eflx_up   = eflx(i,j,1,2)*gm_xu + eflx(i,j,2,2)*gm_yu +
     +                  eflx(i,j,3,2)
            eflx_lo   = eflx(i,j,1,1)*gm_xl + eflx(i,j,2,1)*gm_yl +
     +                  eflx(i,j,3,1)
            r5(i,j,k) = r5(i,j,k) + (eflx_up - eflx_lo)*dzw_i(k)
         enddo
         enddo
c
c ---------- resolved vertical advection, flux form
c            plus grid speed
c
         do j=iys,iye
         do i=1,nnx
            e_u       = weitm(k)*e(i,j,k) + weit(k)*e(i,j,kp1)
            e_l       = weit(km1)*e(i,j,k) + weitm(km1)*e(i,j,km1)
            wflx_u    = wf(i,j,k) - gm(i,j,k,5)
            wflx_l    = wf(i,j,km1) - gm(i,j,km1,5)
            e_adv     = (wflx_u*e_u - wflx_l*e_l)*dzw_i(k)
            r5(i,j,k) = r5(i,j,k) - e_adv
         enddo
         enddo
c
c --------- get buoyancy term/J in sgs e equation 
c
      if(k .eq. 1) then
         do j=iys,iye
         do i=1,nnx
            fac   = weit(k)*vis_s(i,j,kp1) + weitm(k)*vis_s(i,j,k)
            tzet  = (t(i,j,1,kp1) - t(i,j,1,k))*dzu_i(kp1)
            r5(i,j,k) = r5(i,j,k) - fac*tzet*batag*gm(i,j,k,1)
         enddo
         enddo
      else
         do j=iys,iye
         do i=1,nnx
            tup   = weit(k)*t(i,j,1,kp1) + weitm(k)*t(i,j,1,k)
            tlo   = weit(km1)*t(i,j,1,k) + weitm(km1)*t(i,j,1,km1)
            tzet  = (tup - tlo)*dzw_i(k)
            r5(i,j,k) = r5(i,j,k) - vis_s(i,j,k)*tzet*batag*gm(i,j,k,1)
         enddo
         enddo
      endif
c
c -------- end z loop
c
      enddo
c
c ------------- 9/1989 add ihflt=1 option--mean shear does not generate sgs tke
c
c     uxymm=0.
c     uxymp=0.
c     vxymm=0.
c     vxymp=0.
c     if(ivis .eq. 1 .and. k .le. nmatch) then
c        uxymm = u_mn(k)
c        uxymp = u_mn(kp1)
c        vxymm = v_mn(k)
c        vxymp = v_mn(kp1)
c     endif
c
c -------------- end z loop
c
c     enddo
c
c -------------- leave with r5/J
c
      return
      end
      subroutine tke_vis_old(istep)
c
c ------ get viscosity using deardorff tke model with
c        stability correction. fixes for surface layer. 
c        get rhs of e-equation/J. field variables are
c        (u,v,w,e,theta) all at cell center. get viscosity
c        at cell center also.
c        "length scale" based on the volume in physical space
c
c        volume = gm(.,.,.,1)*d_zeta*d_eta*d_xi 
c        (fletcher, vol2 1988, p. 51)
c
      use pars
      use fields
      use fftwk
      use con_data
      use con_stats
c
      real ex(nnx,iys:iye,izs-1:ize+1), ey(nnx,iys:iye,izs-1:ize+1)
      real fnt1(nnx,iys:iye), fntd(nnx,iys:iye,izs:ize)
      real dissp(nnx,iys:iye), alk(nnx,iys:iye), sij(nnx,iys:iye,6)
      real eflx(nnx,iys:iye,3,2), e_g(nnx,iys:iye,3)
c
      do k=max(izs-1,1),min(nnz,ize+1)
c
      kp1  = k + 1
      km1  = k - 1
      w1   = weit(k)
      w1m  = weitm(k)
      w2   = weit(km1)
      w2m  = weitm(km1)
      dslk = dsl_z(k)
      if(k .gt. 0) dslk  = amin1(dsl_z(k),vk*abs(z(k))/csmag)
      almin = almin_c*dsl_z(k)
      if(k .eq. 0 .or. k .eq. nnz+1) then
         dfack = 1.0
      else
         dfack = dfac(k)
      endif
c     if(ivis .eq. 1 .and. k .le. nmatch) then
c
CHECK FIX
c
      if(k .le. ((3*nnz)/6)) then
c
c --------------- no stability corrected length scales
c
         do j=iys,iye
         do i=1,nnx
            alk(i,j) = dslk*gm(i,j,k,1)
         end do
         end do
      else
         do j=iys,iye
         do i=1,nnx
            alk(i,j) = dslk*gm(i,j,k,1)
            tup  = w1*t(i,j,1,kp1) + w1m*t(i,j,1,k)
            tlo  = w2*t(i,j,1,k) + w2m*t(i,j,1,km1)
            stab = gm(i,j,k,4)*batag*(tup - tlo)*dzw_i(k)
            if(stab .gt. stabmin) then
              als = stab_c*sqrt(e(i,j,k)/stab)
              alk(i,j) = amin1(dslk,als)*gm(i,j,k,1)
            endif
            alk(i,j)  = amax1(almin,alk(i,j))
         enddo
         enddo
      endif
      do j=iys,iye
      do i=1,nnx
         vis_m(i,j,k) = ck*alk(i,j)*sqrt(e(i,j,k))*dfack
         vis_s(i,j,k) = (1.0 + 2.0*alk(i,j)/(dslk*gm(i,j,k,1)))*
     +                  vis_m(i,j,k)
      enddo
      enddo
c
c -------------- special case at bottom and top
c
      if(k == 1) then
         do j=iys,iye
         do i=1,nnx
            vis_m(i,j,km1) = vis_m(i,j,k)
            vis_s(i,j,km1) = vis_s(i,j,k)
         enddo
         enddo
      elseif(k == nnz) then
         do j=iys,iye
         do i=1,nnx
            vis_m(i,j,kp1) = vis_m(i,j,k)
            vis_s(i,j,kp1) = vis_s(i,j,k)
         enddo
         enddo
      endif
c
      if(k .ge. izs .and. k .le. ize) then
c
c -------- to avoid storing length scale get dissipation
c          and shear production with cell centered strains
c
      call strain_c(sij,k)
      do j=iys,iye
      do i=1,nnx
         dissp(i,j) = (0.19 + 0.74*alk(i,j)/(dslk*gm(i,j,k,1)))*
     +                 e(i,j,k)*sqrt(e(i,j,k))/alk(i,j)
         fnt1(i,j)  = 2.0*vis_m(i,j,k)*(
     +            sij(i,j,1)**2 + sij(i,j,4)**2 + sij(i,j,6)**2 + 
     +            2.0*(sij(i,j,2)**2 + sij(i,j,3)**2 + sij(i,j,5)**2))
         r5(i,j,k) = (fnt1(i,j) - dissp(i,j))*gm(i,j,k,1)
      enddo
      enddo
c
      if(istep .eq. 1) then
         t_diss(k) = 0.0
         shrz(k)   = 0.0
         triz(k)   = 0.0
         do j=iys,iye
         do i=1,nnx
            t_diss(k) = t_diss(k) + dissp(i,j)
            shrz(k)   = shrz(k) + fnt1(i,j)
         enddo
         enddo
         t_diss(k) = t_diss(k)*fnxy
         shrz(k)   = shrz(k)*fnxy
      endif
c
      endif   ! endif for k = [izs,ize]
c
c -------------- end z loop
c
      enddo
c
c -------------- if special 2 part surface layer model is on
c                get "mean" viscosity
CHECK 2-part for curvy?
c
c     do k=izs-1,ize
c        km1         = k - 1
c        kp1         = k + 1
c        vis_mean(k) = 0.0
c        if(ivis .eq. 1 .and. k .le. nmatch) then
c           if(k .le. 1) then
c             vis_mean(k) = xksurf
c           else
c             stravg = sqrt((u_mn(kp1)-u_mn(k))**2 + 
c    +              (v_mn(kp1)-v_mn(k))**2)*abs(dzu_i(kp1))
c             vis_mean(k) = xksurf*viscon*stravg
c           endif
c        endif
c     enddo
c
c --------- get x & y derivatives for [izs-1:ize+1]
c
      do k=izs-1,ize+1
         do j=iys,iye
         do i=1,nnx
            ex(i,j,k) = e(i,j,k)
            ey(i,j,k) = e(i,j,k)
         enddo
         enddo
         call xderivp(ex(1,iys,k),trigx(1,1),xk(1),nnx,iys,iye)
      enddo
      call yd_mpi(ey(1,iys,izs-1),trigx(1,2),yk(1),
     +           nnx,nny,ixs,ixe,ix_s,ix_e,
     +           iys,iye,iy_s,iy_e,izs-1,ize+1,myid,ncpu_s,numprocs)
c
c -------- diffusion term eflx(.,.,1) + resolved flux at cell center
c
      do k=izs,ize
         call grd_e_c(e_g,k,ex,ey)
         do j=iys,iye
         do i=1,nnx
            eflx(i,j,1,1) = 2.0*vis_m(i,j,k)*e_g(i,j,1)
            eflx(i,j,2,1) = 2.0*vis_m(i,j,k)*e_g(i,j,2)
            fnt1(i,j)     = gm(i,j,k,1)*eflx(i,j,1,1) -
     +                      uf(i,j,k)*e(i,j,k)
            fntd(i,j,k)   = gm(i,j,k,1)*eflx(i,j,2,1) -
     +                      vf(i,j,k)*e(i,j,k)
         enddo
         enddo
         call xderivp(fnt1(1,iys),trigx(1,1),xk(1),nnx,iys,iye)
         do j=iys,iye
         do i=1,nnx
            r5(i,j,k) = r5(i,j,k) + fnt1(i,j)
         enddo
         enddo
      enddo
c
c -------- diffusion term eflx(.,.,2) + resolved flux at cell center
c
      call yd_mpi(fntd(1,iys,izs),trigx(1,2),yk(1),
     +           nnx,nny,ixs,ixe,ix_s,ix_e,
     +           iys,iye,iy_s,iy_e,izs,ize,myid,ncpu_s,numprocs)
      do k=izs,ize
         do j=iys,iye
         do i=1,nnx
            r5(i,j,k) = r5(i,j,k) + fntd(i,j,k)
         enddo
         enddo
      enddo
c
c --------- z-diffusion term + resolved vertical flux
c           no divergence of flux at first gridpoint
c
      k   = izs
      km1 = izs - 1
      kp1 = izs + 1
      if(izs .eq. 1) then
         do j=iys,iye
         do i=1,nnx
            e(i,j,km1)  = e(i,j,k)
            ex(i,j,km1) = ex(i,j,k)
            ey(i,j,km1) = ey(i,j,k)
         enddo
         enddo
      endif
      call grd_e_u(e_g,k,ex,ey)
      do n=1,3
      do j=iys,iye
      do i=1,nnx
         fac   = weit(k)*vis_m(i,j,kp1) +
     +              weitm(k)*vis_m(i,j,k)
         eflx(i,j,n,2) = 2.0*fac*e_g(i,j,n)
      enddo
      enddo
      enddo
c
      do k=izs,ize
         kp1 = k + 1
         km1 = k - 1
         do n=1,3
         do j=iys,iye
         do i=1,nnx
            eflx(i,j,n,1) = eflx(i,j,n,2)
         enddo
         enddo
         enddo
         call grd_e_u(e_g,k,ex,ey)
         do n=1,3
         do j=iys,iye
         do i=1,nnx
            fac   = weit(k)*vis_m(i,j,kp1) + weitm(k)*vis_m(i,j,k)
            eflx(i,j,n,2) = 2.0*fac*e_g(i,j,n)
         enddo
         enddo
         enddo
         do j=iys,iye
         do i=1,nnx
            gm_xu     = weit(k)*gm(i,j,kp1,1)*gm(i,j,kp1,2) +
     +                  weitm(k)*gm(i,j,k,1)*gm(i,j,k,2)
            gm_xl     = weit(km1)*gm(i,j,k,1)*gm(i,j,k,2) +
     +                  weitm(km1)*gm(i,j,km1,1)*gm(i,j,km1,2)
            gm_yu     = weit(k)*gm(i,j,kp1,1)*gm(i,j,kp1,3) +
     +                  weitm(k)*gm(i,j,k,1)*gm(i,j,k,3)
            gm_yl     = weit(km1)*gm(i,j,k,1)*gm(i,j,k,3) +
     +                  weitm(km1)*gm(i,j,km1,1)*gm(i,j,km1,3)
            eflx_up   = eflx(i,j,1,2)*gm_xu + eflx(i,j,2,2)*gm_yu +
     +                  eflx(i,j,3,2)
            eflx_lo   = eflx(i,j,1,1)*gm_xl + eflx(i,j,2,1)*gm_yl +
     +                  eflx(i,j,3,1)
            r5(i,j,k) = r5(i,j,k) + (eflx_up - eflx_lo)*dzw_i(k)
         enddo
         enddo
c
c ---------- resolved vertical advection, flux form
c            plus grid speed
c
         do j=iys,iye
         do i=1,nnx
            e_u       = weitm(k)*e(i,j,k) + weit(k)*e(i,j,kp1)
            e_l       = weit(km1)*e(i,j,k) + weitm(km1)*e(i,j,km1)
            wflx_u    = wf(i,j,k) - gm(i,j,k,5)
            wflx_l    = wf(i,j,km1) - gm(i,j,km1,5)
            e_adv     = (wflx_u*e_u - wflx_l*e_l)*dzw_i(k)
            r5(i,j,k) = r5(i,j,k) - e_adv
         enddo
         enddo
c
c --------- get buoyancy term/J in sgs e equation 
c
      if(k .eq. 1) then
         do j=iys,iye
         do i=1,nnx
            fac   = weit(k)*vis_s(i,j,kp1) + weitm(k)*vis_s(i,j,k)
            tzet  = (t(i,j,1,kp1) - t(i,j,1,k))*dzu_i(kp1)
            r5(i,j,k) = r5(i,j,k) - fac*tzet*batag*gm(i,j,k,1)
         enddo
         enddo
      else
         do j=iys,iye
         do i=1,nnx
            tup   = weit(k)*t(i,j,1,kp1) + weitm(k)*t(i,j,1,k)
            tlo   = weit(km1)*t(i,j,1,k) + weitm(km1)*t(i,j,1,km1)
            tzet  = (tup - tlo)*dzw_i(k)
            r5(i,j,k) = r5(i,j,k) - vis_s(i,j,k)*tzet*batag*gm(i,j,k,1)
         enddo
         enddo
      endif
c
c -------- end z loop
c
      enddo
c
c ------------- 9/1989 add ihflt=1 option--mean shear does not generate sgs tke
c
c     uxymm=0.
c     uxymp=0.
c     vxymm=0.
c     vxymp=0.
c     if(ivis .eq. 1 .and. k .le. nmatch) then
c        uxymm = u_mn(k)
c        uxymp = u_mn(kp1)
c        vxymm = v_mn(k)
c        vxymp = v_mn(kp1)
c     endif
c
c -------------- end z loop
c
c     enddo
c
c -------------- leave with r5/J
c
      return
      end
      subroutine grd_e_u(scl_u,k,ex,ey)
c
c ---------- get scalar gradient at upper face at the k-level
c
c        gradient definitions
c
c        ex   = exi  + ezet*gm_x
c        ey   = eeta + ezet*gm_y
c        ez   = tzet*gm_z
c
      use pars
      use fields
      use fftwk
      use con_data
      use con_stats
      real scl_u(nnx,iys:iye,3)
      real ex(nnx,iys:iye,izs-1:ize+1), ey(nnx,iys:iye,izs-1:ize+1)
c
      km1  = k - 1
      kp1  = k + 1
      w1   = weit(k)
      w1m  = weitm(k)
      w2   = weit(km1)
      w2m  = weitm(km1)
c
c -------- at upper face
c
      do j=iys,iye
      do i=1,nnx
         ezet  = (e(i,j,kp1) - e(i,j,k))*dzu_i(kp1) 
         exi   = w1*ex(i,j,kp1) + w1m*ex(i,j,k)
         eeta  = w1*ey(i,j,kp1) + w1m*ey(i,j,k)
         gm_x  = w1*gm(i,j,kp1,2) + w1m*gm(i,j,k,2)
         gm_y  = w1*gm(i,j,kp1,3) + w1m*gm(i,j,k,3)
         gm_z  = w1*gm(i,j,kp1,4) +  w1m*gm(i,j,k,4)
         scl_u(i,j,1) = exi  + ezet*gm_x
         scl_u(i,j,2) = eeta + ezet*gm_y
         scl_u(i,j,3) = ezet*gm_z
      enddo
      enddo
c
      return
      end
      subroutine grd_e_c(scl_c,k,ex,ey)
c
c ---------- get scalar gradient at the cell center 
c
c        gradient definitions
c
c        ex   = exi  + ezet*gm_x
c        ey   = eeta + ezet*gm_y
c        ez   = ezet*gm_z
c
      use pars
      use fields
      use fftwk
      use con_data
      use con_stats
      real scl_c(nnx,iys:iye,3)
      real ex(nnx,iys:iye,izs-1:ize+1), ey(nnx,iys:iye,izs-1:ize+1)
c
      km1  = k - 1
      kp1  = k + 1
      w1   = weit(k)
      w1m  = weitm(k)
      w2   = weit(km1)
      w2m  = weitm(km1)
c
      if(k == 1) then
c
      do j=iys,iye
      do i=1,nnx
         ezet  = (e(i,j,kp1) - e(i,j,k))*dzu_i(kp1)
         scl_c(i,j,1) = ex(i,j,k) + ezet*gm(i,j,k,2)
         scl_c(i,j,2) = ey(i,j,k) + ezet*gm(i,j,k,3)
         scl_c(i,j,3) = ezet*gm(i,j,k,4)
      enddo
      enddo
      else
c
c -------- at cell center
c
      do j=iys,iye
      do i=1,nnx
         eup   = w1*e(i,j,kp1) + w1m*e(i,j,k)
         elo   = w2*e(i,j,k) + w2m*e(i,j,km1)
         ezet  = (eup - elo)*dzw_i(k) 
         scl_c(i,j,1) = ex(i,j,k) + ezet*gm(i,j,k,2)
         scl_c(i,j,2) = ey(i,j,k) + ezet*gm(i,j,k,3)
         scl_c(i,j,3) = ezet*gm(i,j,k,4)
      enddo
      enddo
c
      endif
c
      return
      end
      subroutine lower(it)
c
c ------ setup lower boundary condition for entire plane at (k = 1)
c        using either businger or large formulas with wind.
c        index f(.,.,2)  indicates lower. 
c
      use pars
      use fields
      use fftwk
      use con_data
      use con_stats
      real sfc_flx(2+nscl)
c
      k    = 1
      km1  = k - 1
      dz_i = dzu_i(k)
c
      do j=iys,iye
      do i=1,nnx
         ebc(i,j,2)  = amax1(e(i,j,k),sml_eg)
         wbc(i,j,2)  = 0.0
         pbc(i,j,2)  = 0.0
         pbc2(i,j,2) = 0.0
         wfbc(i,j,2) = 0.0
         ufbc(i,j,2) = 0.0
         vfbc(i,j,2) = 0.0
      enddo
      enddo
c
      if(iocean .eq. 1) then ! water surface layer
         call sufto(it)
         do j=iys,iye
         do i=1,nnx
            tau13m(i,j) = -au13m
            tau23m(i,j) = -au23m
         enddo
         enddo
         do iscl=1,nscl
           do j=iys,iye
           do i=1,nnx
              taut3m(i,j,iscl) = aut3m(iscl)
           enddo
           enddo
         enddo
c
      else  !   land surface layer
c
         call suft(it)
         fac = -utau**2/(windm*sqrt(u1xy**2 + v1xy**2))
         do j=iys,iye
         do i=1,nnx
            tau13m(i,j) = fac*(windm*(u(i,j,k)+ugal-u1xy)+
     +                     wind(i,j)*u1xy)
            tau23m(i,j) = fac*(windm*(v(i,j,k)-v1xy)+
     +                     wind(i,j)*v1xy)
         enddo
         enddo
         do iscl=1,nscl
            dnom3=t10xy(iscl)*windm
            if(dnom3 .ne. 0.) then
               dnom_i = 1.0/dnom3
               do j=iys,iye
               do i=1,nnx
                  taut3m(i,j,iscl) = aut3m(iscl)*
     +                 (windm*(t(i,j,iscl,k) - t1xy(iscl))+
     +                  wind(i,j)*(t1xy(iscl) - tsfcc(iscl)))*dnom_i
               enddo
               enddo
            else
               do j=iys,iye
               do i=1,nnx
                  taut3m(i,j,iscl) = aut3m(iscl)
               enddo
               enddo
            endif
         enddo
c
      endif ! end of surface layer type
c
      do j=iys,iye
      do i=1,nnx
         t11bc(i,j) = 0.0
         t12bc(i,j) = 0.0
         t13bc(i,j) = tau13m(i,j)
         t22bc(i,j) = 0.0
         t23bc(i,j) = tau23m(i,j)
         t33bc(i,j) = 0.0
      enddo
      enddo
c
c -------- partial sums of surface fluxes and mean scalar
c
      sfc_flx(1) = 0.0
      sfc_flx(2) = 0.0
      do j=iys,iye
      do i=1,nnx
         sfc_flx(1) = sfc_flx(1) + tau13m(i,j)
         sfc_flx(2) = sfc_flx(2) + tau23m(i,j)
      enddo
      enddo
      do iscl=1,nscl
         sfc_flx(2+iscl) = 0.0
         do j=iys,iye
         do i=1,nnx
            sfc_flx(2+iscl) = sfc_flx(2+iscl) + taut3m(i,j,iscl)
         enddo
         enddo
      enddo
c
      call mpi_sum_xy(sfc_flx,myid,iss,ise,(2+nscl))
      uwsfc = sfc_flx(1)*fnxy
      vwsfc = sfc_flx(2)*fnxy
      uusfc = 0.0
      uvsfc = 0.0
      vvsfc = 0.0
      wwsfc = 0.0
      do iscl=1,nscl
         wtsfc(iscl) = sfc_flx(2+iscl)*fnxy
      enddo
c     write(nprt,2345) uwsfc, vwsfc, wtsfc(nscl), tsfcc(nscl)
 2345 format(' in lower 2345 uwsfc = ',e15.6,' vwsfc = ',e15.6,
     +       ' wtsfc = ',e15.6,' tsfcc = ',e15.6)
c
      do j=iys,iye
      do i=1,nnx
         dudz       = 2.*(u(i,j,k) + ugal)*dz_i
         dvdz       = 2.*v(i,j,k)*dz_i
         ubc(i,j,2) = u(i,j,k) - dudz*dzu(k)
         vbc(i,j,2) = v(i,j,k) - dvdz*dzu(k)
      enddo
      enddo
      do iscl=1,nscl
         do j=iys,iye
         do i=1,nnx
            dtdz     = 2.*(t(i,j,iscl,k)-tsfcc(iscl))*dz_i
            tbc(i,j,iscl,2) = t(i,j,iscl,k) - dtdz*dzu(k)
         enddo
         enddo
      enddo
c
c ------------ initialize u, v, w, t derivatives are
c              computed in get_derv at km1
c              no need to call derivatives here since
c              wbc = 0, change for more general lower bc
c
      do j=iys,iye
      do i=1,nnx
         u(i,j,km1)  = ubc(i,j,2)
         v(i,j,km1)  = vbc(i,j,2)
         w(i,j,km1)  = wbc(i,j,2)
         r3(i,j,km1) =  0.0
         e(i,j,km1)  = ebc(i,j,2)
         wf(i,j,km1) = wfbc(i,j,2)
         uf(i,j,km1) = ufbc(i,j,2)
         vf(i,j,km1) = vfbc(i,j,2)
      enddo
      enddo
c
      do iscl=1,nscl
         do j=iys,iye
         do i=1,nnx
            t1tbc(i,j,iscl) = 0.0
            t2tbc(i,j,iscl) = 0.0
            t3tbc(i,j,iscl) = taut3m(i,j,iscl)
            t(i,j,iscl,km1) = tbc(i,j,iscl,2)
         enddo
         enddo
      enddo
c
      return
      end
      subroutine lower_free(it)
c
c --------------- setup lower boundary condition for free
c                 convection where each processor applies
c                 log-law at several (ix,iy) for k = 1.
c                 index f(.,.,2)  indicates lower
c
      use pars
      use fields
      use fftwk
      use con_data
      use con_stats
      include 'mpif.h'
c
      real u_level1(nnx,iys:iye,2+nscl), buf(2+2*nscl)
      real sbuf(2+2*nscl,mxs:mxe,iys:iye)
      real rbuf((2+2*nscl)*nnx*(iye+1-iys))
      integer istatus(mpi_status_size)
c
c -------------- broadcast level 1 data everywhere
c
      if(iss .eq. 0) then
         do iy=iys,iye
         do ix=1,nnx
            u_level1(ix,iy,1) = u(ix,iy,1)
            u_level1(ix,iy,2) = v(ix,iy,1)
         enddo
         enddo
         do iscl=1,nscl
         do iy=iys,iye
         do ix=1,nnx
            u_level1(ix,iy,2+iscl) = t(ix,iy,iscl,1)
         enddo
         enddo
         enddo
      endif
      num = nnx*(iye + 1 - iys)*(2+nscl)
c
c ------ send all of root data to other processors
c
      call mpi_send_root(u_level1(1,iys,1),
     +             num,myid,numprocs,ncpu_s)
c
c --------- every task gets their own fluxes and surface scalars
c
      call suft2(u_level1,it)
c
c --------- send surface scalars and momentum fluxes
c           back to root(s)
c
      if(numprocs .eq. 1) go to 999
c
      do iy=iys,iye
      do ix=mxs,mxe
         sbuf(1,ix,iy)  = tau13m(ix,iy)
         sbuf(2,ix,iy)  = tau23m(ix,iy)
      enddo
      enddo
      do iscl=1,nscl
      do iy=iys,iye
      do ix=mxs,mxe
         sbuf(2+iscl,ix,iy)      = taut3m(ix,iy,iscl)
         sbuf(2+nscl+iscl,ix,iy) = t_grnd(ix,iy,iscl)
      enddo
      enddo
      enddo
c
      irow_r = mod(myid,ncpu_s)
      if(myid .ge. ncpu_s) then
        num = (2+2*nscl)*(mxe+1-mxs)*(iye+1-iys)
        call mpi_send(sbuf(1,mxs,iys),num,mpi_real8,irow_r,1,
     +       mpi_comm_world,ierr)
      else
        do l=irow_r+ncpu_s,numprocs-1,ncpu_s
           num = (2+2*nscl)*(mx_e(l)+1-mx_s(l))*(iye+1-iys)
           call mpi_recv(rbuf(1),num,mpi_real8,l,1,
     +          mpi_comm_world,istatus,ierr)
c          call f_suft2(rbuf,maxnx,maxny,mx_s(l),mx_e(l),iys,iye,nscl,
           call f_suft2(rbuf,nnx,mx_s(l),mx_e(l),iys,iye,nscl,
     +                  tau13m,tau23m,taut3m,t_grnd)
        enddo
      endif
c
  999 continue
c
c ------------ only for root row = 0
c              get sums of surface conditions
c              and set surface boundary conditions
c
      if(iss .eq. 0) then
c
         buf(1) = 0.0
         buf(2) = 0.0
         do iy=iys,iye
         do ix=1,nnx
            buf(1) = buf(1) + tau13m(ix,iy)
            buf(2) = buf(2) + tau23m(ix,iy)
         enddo
         enddo
         do iscl=1,nscl
            buf(2+iscl)      = 0.
            buf(2+nscl+iscl) = 0.
            do iy=iys,iye
            do ix=1,nnx
               buf(2+iscl)      = buf(2+iscl) + taut3m(ix,iy,iscl)
               buf(2+nscl+iscl) = buf(2+nscl+iscl) + t_grnd(ix,iy,iscl)
            enddo
            enddo
         enddo
c
         call mpi_sum_xy(buf,myid,iss,ise,2+2*nscl)
         uwsfc = buf(1)*fnxy
         vwsfc = buf(2)*fnxy
         do iscl=1,nscl
            wtsfc(iscl) = buf(2+iscl)*fnxy
            tsfcc(iscl) = buf(2+nscl+iscl)*fnxy
         enddo
c
         do j=iys,iye
         do i=1,nnx
            t11bc(i,j) = 0.0
            t12bc(i,j) = 0.0
            t13bc(i,j) = tau13m(i,j)
            t22bc(i,j) = 0.0
            t23bc(i,j) = tau23m(i,j)
            t33bc(i,j) = 0.0
            t1tbc(i,j,1) = 0.0
            t2tbc(i,j,1) = 0.0
            t3tbc(i,j,1) = taut3m(i,j,1)
         enddo
         enddo
c
         iz   = 1
         izm1 = iz - 1
         dz_i = dzu_i(iz)
c
         do iy=iys,iye
         do ix=1,nnx
            ebc(ix,iy,2)=amax1(e(ix,iy,iz),sml_eg)
            wbc(ix,iy,2)= 0.0
            pbc(ix,iy,2) = 0.0
            pbc2(ix,iy,2) = 0.0
c
            wfbc(i,j,2)  = 0.0
            ufbc(i,j,2)  = 0.0
            vfbc(i,j,2)  = 0.0
         enddo
         enddo
c
         do iy=iys,iye
         do ix=1,nnx
            dudz     = 2.*u(ix,iy,iz)*dz_i
            dvdz     = 2.*v(ix,iy,iz)*dz_i
            ubc(ix,iy,2) = u(ix,iy,iz) - dudz*dzu(iz)
            vbc(ix,iy,2) = v(ix,iy,iz) - dvdz*dzu(iz)
         enddo
         enddo
         do iscl=1,nscl
            do iy=iys,iye
            do ix=1,nnx
               dtdz     = 2.*(t(ix,iy,iscl,iz)-tsfcc(iscl))*dz_i
               tbc(ix,iy,iscl,2) = t(ix,iy,iscl,iz) - dtdz*dzu(iz)
            enddo
            enddo
         enddo
c
c ------------ initialize u, v, w, t and derivatives at izm1
c
         do iy=iys,iye
         do ix=1,nnx
            u(ix,iy,izm1)  = ubc(ix,iy,2)
            v(ix,iy,izm1)  = vbc(ix,iy,2)
            w(ix,iy,izm1)  = wbc(ix,iy,2)
            r3(ix,iy,izm1) =  0.0
            e(ix,iy,izm1)  = ebc(ix,iy,2)
            ux(ix,iy,izm1) = 0.0
            uy(ix,iy,izm1) = 0.0
            vx(ix,iy,izm1) = 0.0
            vy(ix,iy,izm1) = 0.0
            wx(ix,iy,izm1) = wbc(ix,iy,2)
            wy(ix,iy,izm1) = wbc(ix,iy,2)
         enddo
         enddo
c
         do iscl=1,nscl
            do iy=iys,iye
            do ix=1,nnx
               t(ix,iy,iscl,izm1) = tbc(ix,iy,iscl,2)
            enddo
            enddo
         enddo
c
c ----- end of if block for root row
c
      endif
c
 7999 continue
c
      return
      end
      subroutine f_suft2(rbuf,nnx,mxs,mxe,iys,iye,nscl,
     +                  tau13m,tau23m,taut3m,t_grnd)
c
c ------ fill surface arrays on root processors
c
      real rbuf(2+2*nscl,mxs:mxe,iys:iye)
      real tau13m(nnx,iys:iye), tau23m(nnx,iys:iye),
     +     taut3m(nnx,iys:iye,nscl), t_grnd(nnx,iys:iye,nscl)
c
      do iy=iys,iye
      do ix=mxs,mxe
         tau13m(ix,iy) = rbuf(1,ix,iy)
         tau23m(ix,iy) = rbuf(2,ix,iy)
      enddo
      enddo
      do iscl=1,nscl
         do iy=iys,iye
         do ix=mxs,mxe
            taut3m(ix,iy,iscl) = rbuf(2+iscl,ix,iy)
            t_grnd(ix,iy,iscl) = rbuf(2+nscl+iscl,ix,iy)
         enddo
         enddo
      enddo
c
      return
      end
      subroutine lower_curvy(it,istage)
c
c --------- setup lower boundary condition for case
c           with curvy lower boundary. each processor
c           applies log-law at several (i,j) for k = 1
c
      use pars
      use fields
      use fftwk
      use con_data
      use con_stats
      include 'mpif.h'
c
c ------- set the number of variables to pass and
c         get back
c
      parameter (mvar= 9+3*nscl, jvar = 8+2*nscl)
      real u_level1(nnx,iys:iye,mvar), buf(jvar)
      real sbuf(jvar,mxs:mxe,iys:iye)
      real rbuf(jvar*nnx*(iye+1-iys))
      integer istatus(mpi_status_size)
c
      t_bndy = t_stage - t_zero
c
c        write(nprt, 1010) t_bndy, t_stage, t_zero
c1010    format(' 1010: lower curvy',/,
c    +          ' t_bndy = ',e15.6,
c    +          ' t_stage = ',e15.6,' t_zero = ',e15.6)
c
      if(i3d_surf .eq. 0) then
         call l_bndy(t_bndy)
      elseif(i3d_surf .eq. 1) then
         call get_surf(t_bndy)
      elseif(i3d_surf .eq. 2) then
         call get_surf_gabls(t_bndy)
      elseif(i3d_surf .eq. 3) then
         call get_surf_tank(t_bndy)
      endif
c
c     call dealias_grid_speed
c
c ----- broadcast level 1 data to processors above root
c
      k   = 1
      km1 = k - 1
c
      if(iss .eq. 0) then
         do j=iys,iye
         do i=1,nnx
c
c -------- subtract off surface movement when applying the drag law
c          plus the orbital velocity of the wave.
c          w at the boundary is close to grid speed. 
c          Note for iz_space = 4 grid speed is constant across
c          the first grid cell and thus z_t at w point = z_t at
c          the boundary. Can improve the surface estimate FIX
c          and couple it to the underlying water using the 
c          fuller definition
c
c           u_level1(i,j,1) = u(i,j,k)
c           u_level1(i,j,2) = v(i,j,k)
c           u_level1(i,j,3) = w(i,j,k)
c
            u_level1(i,j,1) = u(i,j,k) - u_orbit(i,j)
            u_level1(i,j,2) = v(i,j,k) - v_orbit(i,j)
c           u_level1(i,j,3) = w(i,j,k) - gm(i,j,km1,5)
            u_level1(i,j,3) = w(i,j,k) - w_orbit(i,j)
            u_level1(i,j,4) = gm(i,j,k,1)
            u_level1(i,j,5) = gm(i,j,k,2)
            u_level1(i,j,6) = gm(i,j,k,3)
            u_level1(i,j,7) = u_orbit(i,j)
            u_level1(i,j,8) = v_orbit(i,j)
            u_level1(i,j,9) = gm(i,j,km1,5)
         enddo
         enddo
c           j = iys
c           write(nprt,3002) t_bndy, dt, istage
c3002       format(' 3002 debug ',5x,/,
c    +             ' t bndy = ',e20.10,' dt = ',e15.6,' istage = ',i5)
c           write(nprt,3001) (i,bndy(i,j),gm(i,j,k,1),gm(i,j,km1,5),
c    +                        gm(i,j,k,5), w(i,j,k),u(i,j,k),
c    +                        u_orbit(i,j),u_level1(i,j,1),
c    +                        u_level1(i,j,3),i=1,nnx)
c3001  format(' i ',10x,' h ',10x,' 1/J',10x,' gm5 ',10x,' gm5',10x,
c    +        ' w ',10x,' u ',10x,' u orb ',10x,' du ',5x,' dw ',/,
c    +        (i5,9e15.6))
c
c          write(nprt,3003) (i,gm(i,j,km1,5),wf(i,j,km1), w(i,j,km1), 
c    +                          gm(i,j,k,5), wf(i,j,k), w(i,j,k), 
c    +                          gm(i,j,k+1,5), wf(i,j,k+1),w(i,j,k+1),
c    +                          i=1,nnx)
c3003  format(' 3003 debug',/,
c    +        ' i ',10x,' gm 5 0',10x,' wf 0 ',10x,' w 0',8x,
c    +                  ' gm5 1',10x,' wf 1 ',8x,' w 1 ',8x,
c    +        ' gm 5 2',10x,' wf 2 ',10x,' w 2',/,
c    +        (i5,9e15.6))
         do iscl=1,nscl
         do j=iys,iye
         do i=1,nnx
            u_level1(i,j,9+iscl)        = t3tbc(i,j,iscl)
            u_level1(i,j,9+nscl+iscl)   = t(i,j,iscl,k)
            u_level1(i,j,9+2*nscl+iscl) = t_grnd(i,j,iscl)
         enddo
         enddo
         enddo
      endif
c
      num = nnx*(iye + 1 - iys)*mvar
c
c ------ send all of root data to other processors
c
      call mpi_send_root(u_level1(1,iys,1),
     +             num,myid,numprocs,ncpu_s)
c
c --------- every task gets their own fluxes and surface scalars
c
      do j=iys,iye
      do i=1,nnx
         ustar(i,j)    = -999999.99
c        t_grnd(i,j,1) = -999999.99
      enddo
      enddo
c
      call drglaw_l(u_level1,mvar,it)
c
c     j = iys
c     write(nprt,8201) (i,t11bc(i,j),t12bc(i,j),t13bc(i,j),
c    +                  t22bc(i,j),t23bc(i,j),t33bc(i,j),
c    +                  ustar(i,j),i=1,nnx)
c8201 format(' 8201 debug tau',/,
c    +       ' i ',5x,' t11 ',5x,' t12 ',5x,' t13 ',5x,' t22',5x,
c    +       ' t23 ',5x,' t33',5x,' ustar ',/,(i5,7e15.6))
c
c --------- send surface scalars and momentum fluxes
c           back to root(s)
c
      if(numprocs .eq. 1) go to 999
c
      do j=iys,iye
      do i=mxs,mxe
         sbuf(1,i,j)  = t11bc(i,j)
         sbuf(2,i,j)  = t12bc(i,j)
         sbuf(3,i,j)  = t13bc(i,j)
         sbuf(4,i,j)  = t22bc(i,j)
         sbuf(5,i,j)  = t23bc(i,j)
         sbuf(6,i,j)  = t33bc(i,j)
         sbuf(7,i,j)  = ustar(i,j)
         sbuf(8,i,j)  = amol(i,j)
      enddo
      enddo
      do iscl=1,nscl
      do j=iys,iye
      do i=mxs,mxe
         sbuf(8+iscl,i,j)      = t3tbc(i,j,iscl)
         sbuf(8+nscl+iscl,i,j) = t_grnd(i,j,iscl)
      enddo
      enddo
      enddo
c
      irow_r = mod(myid,ncpu_s)
      if(myid .ge. ncpu_s) then
        num = jvar*(mxe+1-mxs)*(iye+1-iys)
        call mpi_send(sbuf(1,mxs,iys),num,mpi_real8,irow_r,1,
     +       mpi_comm_world,ierr)
      else
        do l=irow_r+ncpu_s,numprocs-1,ncpu_s
           num = jvar*(mx_e(l)+1-mx_s(l))*(iye+1-iys)
           call mpi_recv(rbuf(1),num,mpi_real8,l,1,
     +          mpi_comm_world,istatus,ierr)
           call f_suft_curvy(rbuf,nnx,mx_s(l),mx_e(l),
     +          iys,iye,nscl,jvar,t11bc,t12bc,t13bc,t22bc,
     +          t23bc,t33bc,ustar,t3tbc,t_grnd,amol)
        enddo
      endif
c
  999 continue
c
      if(iss .eq. 0) then
c
c     j = iys
c     write(nprt,7201) (i,t11bc(i,j),t12bc(i,j),t13bc(i,j),
c    +                  t22bc(i,j),t23bc(i,j),t33bc(i,j),
c    +                  ustar(i,j),i=1,nnx)
c7201 format(' 7201 debug tau',/,
c    +   ' i ',5x,' t11 ',5x,' t12 ',5x,' t13 ',5x,' t22',5x,
c    +   ' t23 ',5x,' t33',5x,' ustar ',/,(i5,7e15.6))
c     write(nprt,8202) (i, -gm(i,j,k,2)*gm(i,j,k,1), 
c    +                  u(i,j,k), u_orbit(i,j),
c    +                  w(i,j,k), w_orbit(i,j),
c    +                  (u(i,j,k) - u_orbit(i,j)),
c    +                  (w(i,j,k) - w_orbit(i,j)),
c    +                  t13bc(i,j), ustar(i,j)**2,z1b(i,j),
c    +                  i=1,nnx)
c8202 format(' 8202 debug surf',/,
c    +       ' i ',5x,' gm(2)',5x, 'u ',5x,' uorbit',
c    +       ' w ',5x,' worbit',5x,' du ',5x,' dw',5x,
c    +       ' t13bc ',5x,' u**2 ',5x,' z1b',/,
c    +       (i5,10e15.6))
c
c ------------ only for root row = 0
c              get sums of surface conditions
c              and set surface boundary conditions
c
c
         do i=1,jvar
            buf(i) = 0.0
         enddo
c
c ------- add SGS pieces that appear on rhs of [u,v,w] equations
c
         do j=iys,iye
         do i=1,nnx
            fac1   = gm(i,j,k,1)*gm(i,j,k,2)
            fac2   = gm(i,j,k,1)*gm(i,j,k,3)
            buf(1) = buf(1) + t11bc(i,j)
            buf(2) = buf(2) + t12bc(i,j)
            buf(3) = buf(3) + t13bc(i,j) + 
     +               fac1*t11bc(i,j) + fac2*t12bc(i,j)
            buf(4) = buf(4) + t22bc(i,j)
            buf(5) = buf(5) + t23bc(i,j) + 
     +               fac1*t12bc(i,j) + fac2*t22bc(i,j)
            buf(6) = buf(6) + t33bc(i,j) + 
     +               fac1*t13bc(i,j) + fac2*t23bc(i,j)
            buf(7) = buf(7) + ustar(i,j)**2
            buf(8) = buf(8) + amol(i,j)
         enddo
         enddo
         do iscl=1,nscl
            do j=iys,iye
            do i=1,nnx
               buf(8+iscl)      = buf(8+iscl) + t3tbc(i,j,iscl)
               buf(8+nscl+iscl) = buf(8+nscl+iscl) + 
     +                            t_grnd(i,j,iscl)
            enddo
            enddo
         enddo
c
         call mpi_sum_xy(buf,myid,iss,ise,jvar)
         uusfc   =  buf(1)*fnxy
         uvsfc   =  buf(2)*fnxy
         uwsfc   =  buf(3)*fnxy
         vvsfc   =  buf(4)*fnxy
         vwsfc   =  buf(5)*fnxy
         wwsfc   =  buf(6)*fnxy
         utau    =  sqrt(buf(7)*fnxy)
         amonin  =  buf(8)*fnxy
         utausv  = utau
         do iscl=1,nscl
            wtsfc(iscl) = buf(8+iscl)*fnxy
            tsfcc(iscl) = buf(8+nscl+iscl)*fnxy
         enddo
         if(ibuoy == 0 .or. wtsfc(1) == 0.) then
            zol = 0.0
         else
            zol = zz(1)/amonin
         endif
c
         dz_i = dzu_i(k)
c
         do j=iys,iye
         do i=1,nnx
            !ebc(i,j,2)  = amax1(e(i,j,k),sml_eg)
            ebc(i,j,2) = 0.0
            pbc(i,j,2)  = 0.0
            pbc2(i,j,2) = 0.0
c
            ubc(i,j,2)  = 2.0*u_orbit(i,j) - u(i,j,k)
            vbc(i,j,2)  = 2.0*v_orbit(i,j) - v(i,j,k)
c
Cnew ------ bc for vertical velocity
c
            wbc(i,j,2)  = 2.0*gm(i,j,km1,5) - w(i,j,k)
c
            ufbc(i,j,2)  = -uf(i,j,k)
            vfbc(i,j,2)  = -vf(i,j,k)
c 
c ------- no flow through the surface at t = t_stage
c
            wfbc(i,j,2)  = gm(i,j,km1,5)
         enddo
         enddo
c
         do iscl=1,nscl
            do j=iys,iye
            do i=1,nnx
               tbc(i,j,iscl,2) = 2.0*t_grnd(i,j,iscl) - t(i,j,iscl,k) 
            enddo
            enddo
         enddo
c
c ------------ initialize u, v, w, t and derivatives at km1
c
         do j=iys,iye
         do i=1,nnx
            u(i,j,km1)  = ubc(i,j,2)
            v(i,j,km1)  = vbc(i,j,2)
            w(i,j,km1)  = wbc(i,j,2)
            r3(i,j,km1) =  0.0
            e(i,j,km1)  = ebc(i,j,2)
            ux(i,j,km1) = 0.0
            uy(i,j,km1) = 0.0
            vx(i,j,km1) = 0.0
            vy(i,j,km1) = 0.0
            wx(i,j,km1) = wbc(i,j,2)
            wy(i,j,km1) = wbc(i,j,2)
c
            wf(i,j,km1) = wfbc(i,j,2)
            uf(i,j,km1) = ufbc(i,j,2)
            vf(i,j,km1) = vfbc(i,j,2)
         enddo
         enddo
c
         do iscl=1,nscl
            do j=iys,iye
            do i=1,nnx
               t(i,j,iscl,km1) = tbc(i,j,iscl,2)
            enddo
            enddo
         enddo
c
      endif ! end of if block for root row
c
      return
      end
      subroutine lower_curvy_dns(it,istage)
c
c --------- setup lower boundary condition for DNS
c           with curvy lower boundary.
c           This is no-slip for a moving wavy surface
c
      use pars
      use fields
      use fftwk
      use con_data
      use con_stats
      include 'mpif.h'
c
c ------- set the number of variables to pass and
c         get back
c
      parameter (mvar= 9+3*nscl, jvar = 8+2*nscl)
      real u_level1(nnx,iys:iye,mvar), buf(jvar)
      real sbuf(jvar,mxs:mxe,iys:iye)
      real rbuf(jvar*nnx*(iye+1-iys))
      integer istatus(mpi_status_size)
c
      t_bndy = t_stage - t_zero
c
c
      if(i3d_surf .eq. 0) then
         call l_bndy(t_bndy)
      elseif(i3d_surf .eq. 1) then
         call get_surf(t_bndy)
      elseif(i3d_surf .eq. 2) then
         call get_surf_gabls(t_bndy)
      elseif(i3d_surf .eq. 3) then
         call get_surf_tank(t_bndy)
      endif
c
c ----- broadcast level 1 data to processors above root
c
      k   = 1
      km1 = k - 1
c
c
      if(iss .eq. 0) then
c
c ------------ only for root row = 0
c              get sums of surface conditions
c              and set surface boundary conditions
c
c
         do i=1,jvar
            buf(i) = 0.0
         enddo
c
c ------- add SGS pieces that appear on rhs of [u,v,w] equations
c ------- DHR (3/17/15) I'm not sure if I should leave this, but I am
c
!         do j=iys,iye
!         do i=1,nnx
!            fac1   = gm(i,j,k,1)*gm(i,j,k,2)
!            fac2   = gm(i,j,k,1)*gm(i,j,k,3)
!            buf(1) = buf(1) + t11bc(i,j)
!            buf(2) = buf(2) + t12bc(i,j)
!            buf(3) = buf(3) + t13bc(i,j) + 
!     +               fac1*t11bc(i,j) + fac2*t12bc(i,j)
!            buf(4) = buf(4) + t22bc(i,j)
!            buf(5) = buf(5) + t23bc(i,j) + 
!     +               fac1*t12bc(i,j) + fac2*t22bc(i,j)
!            buf(6) = buf(6) + t33bc(i,j) + 
!     +               fac1*t13bc(i,j) + fac2*t23bc(i,j)
!            buf(7) = buf(7) + ustar(i,j)**2
!            buf(8) = buf(8) + amol(i,j)
!         enddo
!         enddo
!         do iscl=1,nscl
!            do j=iys,iye
!            do i=1,nnx
!               buf(8+iscl)      = buf(8+iscl) + t3tbc(i,j,iscl)
!               buf(8+nscl+iscl) = buf(8+nscl+iscl) + 
!     +                            t_grnd(i,j,iscl)
!            enddo
!            enddo
!         enddo
!c
!         call mpi_sum_xy(buf,myid,iss,ise,jvar)
!         uusfc   =  buf(1)*fnxy
!         uvsfc   =  buf(2)*fnxy
!         uwsfc   =  buf(3)*fnxy
!         vvsfc   =  buf(4)*fnxy
!         vwsfc   =  buf(5)*fnxy
!         wwsfc   =  buf(6)*fnxy
!         utau    =  sqrt(buf(7)*fnxy)
!         amonin  =  buf(8)*fnxy
!         utausv  = utau
!         do iscl=1,nscl
!            wtsfc(iscl) = buf(8+iscl)*fnxy
!            tsfcc(iscl) = buf(8+nscl+iscl)*fnxy
!         enddo
!         if(ibuoy == 0 .or. wtsfc(1) == 0.) then
!            zol = 0.0
!         else
!            zol = zz(1)/amonin
!         endif
c
         dz_i = dzu_i(k)
c
         do j=iys,iye
         do i=1,nnx
            ebc(i,j,2)  = amax1(e(i,j,k),sml_eg)
            pbc(i,j,2)  = 0.0
            pbc2(i,j,2) = 0.0
c
            ubc(i,j,2)  = 2.0*u_orbit(i,j) - u(i,j,k)
            vbc(i,j,2)  = 2.0*v_orbit(i,j) - v(i,j,k)
c
Cnew ------ bc for vertical velocity
c
            wbc(i,j,2)  = 2.0*gm(i,j,km1,5) - w(i,j,k)
c           wbc(i,j,2)  = -w(i,j,k)
c
            ufbc(i,j,2)  = -uf(i,j,k)
            vfbc(i,j,2)  = -vf(i,j,k)
c 
c ------- no flow through the surface at t = t_stage
c
            wfbc(i,j,2)  = gm(i,j,km1,5)
         enddo
         enddo
c
         do iscl=1,nscl
            do j=iys,iye
            do i=1,nnx
               if (isfc==1) then
                  tbc(i,j,iscl,2) = 2.0*Tbot(iscl) - t(i,j,iscl,k)
               end if
               if (isfc==0) then
                  tbc(i,j,iscl,2) = t(i,j,iscl,k) + 
     +           dzu(0)*wtsfc(1)/vis_s(i,j,k)
               end if
               !tbc(i,j,iscl,2) = 2.0*t_grnd(i,j,iscl) - t(i,j,iscl,k) 
            enddo
            enddo
         enddo
c
c ------------ initialize u, v, w, t and derivatives at km1
c
         do j=iys,iye
         do i=1,nnx
            u(i,j,km1)  = ubc(i,j,2)
            v(i,j,km1)  = vbc(i,j,2)
            w(i,j,km1)  = wbc(i,j,2)
            r3(i,j,km1) =  0.0
            e(i,j,km1)  = ebc(i,j,2)
            ux(i,j,km1) = 0.0
            uy(i,j,km1) = 0.0
            vx(i,j,km1) = 0.0
            vy(i,j,km1) = 0.0
            wx(i,j,km1) = wbc(i,j,2)
            wy(i,j,km1) = wbc(i,j,2)
c
            wf(i,j,km1) = wfbc(i,j,2)
            uf(i,j,km1) = ufbc(i,j,2)
            vf(i,j,km1) = vfbc(i,j,2)
         enddo
         enddo
c
         do iscl=1,nscl
            do j=iys,iye
            do i=1,nnx
               t(i,j,iscl,km1) = tbc(i,j,iscl,2)
            enddo
            enddo
         enddo
c
      endif ! end of if block for root row
c
      return
      end
      subroutine f_suft_curvy(rbuf,nnx,mxs,mxe,iys,iye,nscl,jvar,
     +     t11bc,t12bc,t13bc,t22bc,t23bc,t33bc,ustar,t3tbc,t_grnd,
     +     amol)
c
c ------ fill surface arrays on root processors
c
      real rbuf(jvar,mxs:mxe,iys:iye)
      real t11bc(nnx,iys:iye), t12bc(nnx,iys:iye),
     +     t13bc(nnx,iys:iye), t22bc(nnx,iys:iye),
     +     t23bc(nnx,iys:iye), t33bc(nnx,iys:iye),
     +     ustar(nnx,iys:iye), amol(nnx,iys:iye),
     +     t3tbc(nnx,iys:iye,nscl), t_grnd(nnx,iys:iye,nscl)
c
      do j=iys,iye
      do i=mxs,mxe
         t11bc(i,j)  =  rbuf(1,i,j)
         t12bc(i,j)  =  rbuf(2,i,j)
         t13bc(i,j)  =  rbuf(3,i,j)
         t22bc(i,j)  =  rbuf(4,i,j)
         t23bc(i,j)  =  rbuf(5,i,j)
         t33bc(i,j)  =  rbuf(6,i,j)
         ustar(i,j)  =  rbuf(7,i,j)
         amol(i,j)   = rbuf(8,i,j)
      enddo
      enddo
      do iscl=1,nscl
         do j=iys,iye
         do i=mxs,mxe
            t3tbc(i,j,iscl)  = rbuf(8+iscl,i,j)
            t_grnd(i,j,iscl) = rbuf(8+nscl+iscl,i,j)
         enddo
         enddo
      enddo
c
      return
      end
      subroutine drglaw_l(u_level1,mvar,it)
c
c --------- apply drag law across a set of gridpoints
c           with curvy lower boundary. each processor
c           applies log-law at several (i,j) for k = 1
c
c     u_level1(.,.,1)            =  u
c     u_level1(.,.,2)            =  v
c     u_level1(.,.,3)            =  w
c     u_level1(.,.,4)            =  gm(.,.,1,1)
c     u_level1(.,.,5)            =  gm(.,.,1,2)
c     u_level1(.,.,6)            =  gm(.,.,1,3)
c     u_level1(.,.,7)            =  u_orbit
c     u_level1(.,.,8)            =  v_orbit
c     u_level1(.,.,9)            =  surface grid speed
c     u_level1(.,.,9+iscl)       =  t3tbc(.,.,iscl)
c     u_level1(.,.,9+nscl+iscl)  =  t(.,.,iscl,1)
c     u_level1(.,.,9+2nscl+iscl) =  t_grnd(.,.,iscl)
c
      use pars
      use fields
      use fftwk
      use con_data
      use con_stats
c
      real u_level1(nnx,iys:iye,mvar)
      real aij(3,3), us(3), usn(3)
      real tlv1(nscl), qflux(nscl), tsurf(nscl)
c
c ------- get matrix of direction cosines for surface coordinate system
c         and compute surface fluxes for a set of gridpoints [mxs:mxe,iys:iye]
c
      do j=iys,iye
      do i=mxs,mxe
c 
c -------- vector aligned with \xi (t1)
c
         e1   = 1.0
         e3   = -u_level1(i,j,4)*u_level1(i,j,5)
         emag = sqrt(e1*e1 + e3*e3)
         e1   = e1/emag
         e3   = e3/emag
c 
c -------- vector aligned with \eta (t2)
c
         f2   = 1.0
         f3   = -u_level1(i,j,4)*u_level1(i,j,6)
         fmag = sqrt(f2*f2 + f3*f3)
         f2   = f2/fmag
         f3   = f3/fmag
c 
c -------- surface normal n
c
         g1   = -e3*f2
         g2   = -e1*f3
         g3   = e1*f2 
         gmag = sqrt(g1*g1 + g2*g2 + g3*g3)
         g1   = g1/gmag
         g2   = g2/gmag
         g3   = g3/gmag
c 
c -------- surface wind (2 vectors, us_1 and us_2)
c
         us1a      = u_level1(i,j,1)*e1 + u_level1(i,j,3)*e3
         us2a      = u_level1(i,j,2)*f2 + u_level1(i,j,3)*f3
         us(1)     = us1a*e1 
         us(2)     = us2a*f2
         us(3)     = us1a*e3 + us2a*f3
         wind(i,j) = sqrt(us(1)**2 + us(2)**2 + us(3)**2)
         usn(1)    = us(1)/wind(i,j)
         usn(2)    = us(2)/wind(i,j)
         usn(3)    = us(3)/wind(i,j)
c        d_wind    = sqrt((us(1) - u_level1(i,j,7))**2 +
c    +                    (us(2) - u_level1(i,j,8))**2 +
c    +                    (us(3) - u_level1(i,j,9))**2)
c
c -------- third dimension r = n cross us
c
         rb1   = g2*usn(3) - g3*usn(2)
         rb2   = g3*usn(1) - g1*usn(3)
         rb3   = g1*usn(2) - g2*usn(1)
         rbmag = sqrt(rb1**2 + rb2**2 + rb3**2)
         rb1   = rb1/rbmag
         rb2   = rb2/rbmag
         rb3   = rb3/rbmag
c
c -------- matrix of direction cosines
c
         aij(1,1) = usn(1)
         aij(1,2) = usn(2)
         aij(1,3) = usn(3)
         aij(2,1) = rb1
         aij(2,2) = rb2
         aij(2,3) = rb3
         aij(3,1) = g1
         aij(3,2) = g2
         aij(3,3) = g3
c
c --------- set simple scalar arrays
c           fix here if specified surface value
c
         do l=1,nscl
            qflux(l) = u_level1(i,j,9+l)
            tlv1(l)  = u_level1(i,j,9+nscl+l)
            tsurf(l) = u_level1(i,j,9+2*nscl+l)
         enddo
c
         zody = alog(z1b(i,j)/zo + 1.0)
         call mo(ibuoy,isfc,ismlt,vk,batag,zody,z1b(i,j),
     +           wind(i,j), ustar(i,j), nscl,
     +           tlv1(1), tsurf(1), qflux(1),
     +           zol, cd, ch, amol(i,j))
c
c ------------ build the momentum fluxes
c
         utau2      = -ustar(i,j)**2
         t11bc(i,j) = utau2*2.0*aij(1,1)*aij(3,1) 
         t12bc(i,j) = utau2*(aij(1,1)*aij(3,2) + 
     +                        aij(3,1)*aij(1,2))
         t13bc(i,j) = utau2*(aij(1,1)*aij(3,3) +  
     +                        aij(1,3)*aij(3,1))   
         t22bc(i,j) = utau2*2.0*aij(1,2)*aij(3,2) 
         t23bc(i,j) = utau2*(aij(1,2)*aij(3,3) +  
     +                        aij(1,3)*aij(3,2))   
         t33bc(i,j) = utau2*2.0*aij(1,3)*aij(3,3) 
c
         do iscl=1,nscl
            t1tbc(i,j,iscl)  = 0.0
            t2tbc(i,j,iscl)  = 0.0
            t3tbc(i,j,iscl)  = qflux(iscl)
            t_grnd(i,j,iscl) = tsurf(iscl)
         enddo
      enddo
      enddo
c
      return
      end
      subroutine mo(ibuoy,isfc,ismlt,vk,batag,zody,z1,
     +              wind,utau,nscl,t1xy,tsfcc,qstar,
     +              zeta,cd,ch,amonin)
c
c ---------- routine to find surface fluxes and values
c            using MO theory. Iterate for z/L
c
c            Gridpoints [mxs:mxe,iys:iye].
c
c    [assume:  z1 is constant, zody is constant, minimum wind ]
c
c            isfc = 1, then compute tstar and qstar given tsfcc
c                 = 0,   "     "    tsfcc given qstar
c
c    can add more scalars using definition below
c
      parameter (iter_mo = 30, zeta_min = -6.0, zeta_max = 3.0)
      parameter (wind_min = 0.00001)
      real t1xy(nscl), tsfcc(nscl), qstar(nscl)
c
      if(ismlt .eq. 1) then
          vk74in = 0.74/vk
      else
          vk74in = 1.0/vk
      endif
      batagk = batag*vk
c
      windm = amax1(wind_min,wind)
c
c ---------- limits for zeta
c
      zeta_mn = zeta_min
      zeta_mx = zeta_max
      if(isfc .eq. 0) then
         f_con = z1*batagk*qstar(1)/((windm*vk)**3)
      else
         d_theta = vk74in*(tsfcc(1) - t1xy(1))
         f_con   = z1*batagk*d_theta/((windm*vk)**2)
      endif
c
c --------- iteration for zeta
c
      do iter=1,iter_mo
         zeta_a = 0.5*(zeta_mn + zeta_mx)
         if(ismlt .eq. 1) then
             call busngr(zeta_a,phim,phis,psim,psis)
         else
             call fzol(zeta_a,phim,phis,psim,psis)
         endif
         u_fac = (zody - psim)
         if(isfc .eq. 0) then
            f_new =  zeta_a + f_con*u_fac**3
         else
            t_fac = 1.0/amax1((zody - psis),0.01)
            f_new =  zeta_a + f_con*u_fac*u_fac*t_fac
         endif
         if(f_new .lt. 0.0) then
            zeta_mn = zeta_a
         else
            zeta_mx = zeta_a
         endif
      enddo
c
c --------- check if neutral surface layer
c
      if(ibuoy == 0 .or. qstar(1) == 0.) then
          amonin   = 1000.
          zeta     = 0.0
          utau     = windm*vk/zody
          tsfcc(1) = t1xy(1)
      else
         dnom      = amax1((zody-psis),0.01)*vk74in
         utau      = windm*vk/(zody-psim)
         if(isfc == 0) then
            thstar = -qstar(1)/utau
            tsfcc(1)  = t1xy(1) - thstar*dnom
         else
            thstar = (t1xy(1) - tsfcc(1))/dnom
            qstar(1)  = -utau*thstar
         endif
         amonin = -utau**3/(batagk*qstar(1))
         zeta   = z1/amonin
      endif
      cd = utau**2/windm**2
      ch = 0.0
      dnom_ch = windm*(tsfcc(1) - t1xy(1))
      if(dnom_ch .ne. 0.) then
        ch = qstar(1)/dnom_ch
      endif
c
c ------ example of other scalars (specified surface value and source)
c
c     qstar(2) = qstar(1)*(t1xy(2) - tsfcc(2))/(t1xy(1) - tsfcc(1))
c
c     tsfcc(2) = t1xy(2) - qstar(2)*(t1xy(1) - tsfcc(1))/qstar(1)
c
      return
      end
      subroutine upper
c
c ---- set boundary condition on upper boundary iz=nnz
c      option for special radiation boundary condition
c                 index f(.,.,1)  indicates upper. 
c
      use pars
      use fields
      use fftwk
      use con_data
      use con_stats
      include 'mpif.h'
      integer istatus(mpi_status_size)
c
      iz   = nnz
      izm1 = iz - 1
      izm2 = iz - 2
      izp1 = iz + 1
      izp2 = iz + 2
c
c     call dealias_grid_speed
c
      if(ibcu .eq. -1) then ! channel flow type simulation
c
c --------- boundary conditions are gradient conditions
c
c            dudzbc = 0.0
c            dvdzbc = 0.0
c            dtdzbc = 0.0
c            wbc    = 0.0
c            dedzbc = 0.0
c
        do iy=iys,iye
        do ix=1,nnx
c
Cnew ------ bc for vertical velocity
c
           wbc(ix,iy,1) = 2.0*gm(ix,iy,iz,5) - w(ix,iy,iz)
c          wbc(ix,iy,1) = w(ix,iy,iz)
c          ebc(ix,iy,1) = 0.0
           ebc(ix,iy,1) = e(ix,iy,iz)
           ubc(ix,iy,1) = u(ix,iy,iz)
           vbc(ix,iy,1) = v(ix,iy,iz)
           pbc(ix,iy,1) = 0.0
           pbc2(ix,iy,1)= 0.0
           ufbc(ix,iy,1) = uf(ix,iy,iz)
           vfbc(ix,iy,1) = vf(ix,iy,iz)
c
c --------- upper boundary = grid speed 
c
           wfbc(ix,iy,1) = gm(ix,iy,iz,5)
        enddo
        enddo
        do iscl=1,nscl
c
c ---------- average scalar gradient
c
           dtdzf(iscl) = 0.0
        enddo
c
        call mpi_sum_xy(dtdzf,myid,iss,ise,nscl)
c
        do iscl=1,nscl
           do iy=iys,iye
           do ix=1,nnx
              tbc(ix,iy,iscl,1) = t(ix,iy,iscl,iz) + 
     +                            dtdzf(iscl)*dzu(nnzp1)
           enddo
           enddo
        enddo
c
      else if(ibcu .eq. 0) then
c
c --------- boundary conditions are gradient conditions
c
c            dudzbc = 0.0
c            dvdzbc = 0.0
c            dtdzbc = dtdzf
c            wbc    = 0.0
c            ebc    = 0.0
c
        do iy=iys,iye
        do ix=1,nnx
           wbc(ix,iy,1) = 2.0*gm(ix,iy,iz,5) - w(ix,iy,iz)
c          wbc(ix,iy,1) = w(ix,iy,iz)
           ebc(ix,iy,1) = 0.0
c          ebc(ix,iy,1) = e(ix,iy,iz)
           ubc(ix,iy,1) = u(ix,iy,iz)
           vbc(ix,iy,1) = v(ix,iy,iz)
           pbc(ix,iy,1) = 0.0
           pbc2(ix,iy,1)= 0.0
           ufbc(ix,iy,1) = uf(ix,iy,iz)
           vfbc(ix,iy,1) = vf(ix,iy,iz)
c
c --------- upper boundary = grid speed
c
           wfbc(ix,iy,1) = gm(ix,iy,iz,5)
        enddo
        enddo
        do iscl=1,nscl
c
c ---------- first get average scalar gradient
c
           dtdzf(iscl) = 0.0
           do iy=iys,iye
           do ix=1,nnx
              dtdzf(iscl) = dtdzf(iscl) + (t(ix,iy,iscl,nnz) -
     +                      t(ix,iy,iscl,nnz-1))*dzu_i(nnz)
           enddo
           enddo
           dtdzf(iscl) = dtdzf(iscl)*fnxy
        enddo
c
        call mpi_sum_xy(dtdzf,myid,iss,ise,nscl)
c
        do iscl=1,nscl
           do iy=iys,iye
           do ix=1,nnx
              tbc(ix,iy,iscl,1) = t(ix,iy,iscl,iz) + 
     +                            dtdzf(iscl)*dzu(nnzp1)
           enddo
           enddo
        enddo
      else if(ibcu .eq. 2) then
c
c --------- boundary conditions are Sullivan et al. (2000) Couette flow
c
        do iy=iys,iye
        do ix=1,nnx
           wbc(ix,iy,1) = 0.0
           ebc(ix,iy,1) = 0.0
           ubc(ix,iy,1) = 2.0*Uo-u(ix,iy,iz)
           vbc(ix,iy,1) = -v(ix,iy,iz)
           pbc(ix,iy,1) = 0.0
           pbc2(ix,iy,1)= 0.0
           ufbc(ix,iy,1) = Uo
           vfbc(ix,iy,1) = 0.0
c
c --------- upper boundary = grid speed
c
           wfbc(ix,iy,1) = gm(ix,iy,iz,5)
        enddo
        enddo
        do iscl=1,nscl
c
c ---------- first get average scalar gradient
c
           dtdzf(iscl) = 0.0
           do iy=iys,iye
           do ix=1,nnx
              dtdzf(iscl) = dtdzf(iscl) + (t(ix,iy,iscl,nnz) -
     +                      t(ix,iy,iscl,nnz-1))*dzu_i(nnz)
           enddo
           enddo
           dtdzf(iscl) = dtdzf(iscl)*fnxy
        enddo
c
        call mpi_sum_xy(dtdzf,myid,iss,ise,nscl)
c
        do iscl=1,nscl
           do iy=iys,iye
           do ix=1,nnx
              tbc(ix,iy,iscl,1) = t(ix,iy,iscl,iz) + 
     +                            dtdzf(iscl)*dzu(nnzp1)
           enddo
           enddo
        enddo
      else if(ibcu .eq. 1) then
c
c ------------- special if iradup boundary condition
c               get estimate of w from continuity and 
c               linearized relation for pressure
c
      xmeanp = 0.0
      grad_ug = ug(nnz) - ug((nnz-1))
      do iy=iys,iye
      do ix=1,nnx
         wfbc(ix,iy,1) = wf(ix,iy,izm1)-
     +                  (ux(ix,iy,iz) + vy(ix,iy,iz))*dzw(iz)
         pbc(ix,iy,1) = .5*(wf(ix,iy,izm1) + wfbc(ix,iy,1))
         ebc(ix,iy,1) = 0.0
         ubc(ix,iy,1) = u(ix,iy,iz) + grad_ug
         vbc(ix,iy,1) = v(ix,iy,iz)
         pbc2(ix,iy,1)=0.5*(u(ix,iy,iz)**2 + v(ix,iy,iz)**2) +
     +              0.25*(wf(ix,iy,izm1)**2 + wfbc(ix,iy,1)**2)
         xmeanp = xmeanp + pbc2(ix,iy,1)
c
c -------- FIX upper radiation boundary conditions
c
         ufbc(ix,iy,1) = ubc(ix,iy,1)
         vfbc(ix,iy,1) = vbc(ix,iy,1)
c        wfbc(ix,iy,1) = wbc(ix,iy,1)
         wbc(ix,iy,1)  = w(ix,iy,iz)
      enddo
      enddo
      call mpi_sum_xy(xmeanp,myid,iss,ise,1)
      do iscl=1,nscl
         do iy=iys,iye
         do ix=1,nnx
            tbc(ix,iy,iscl,1) = t(ix,iy,iscl,iz) + 
     +                          dtdzf(iscl)*dzu(nnzp1)
         enddo
         enddo
      enddo
      xmeanp = xmeanp*fnxy
      do iy=iys,iye
      do ix=1,nnx
         pbc2(ix,iy,1) = pbc2(ix,iy,1) - xmeanp
      enddo
      enddo
c
c ---------- end if block
c
      endif
c
      do iy=iys,iye
      do ix=1,nnx
         w(ix,iy,izp1)   = wbc(ix,iy,1)
         e(ix,iy,izp1)   = ebc(ix,iy,1)
c
         wf(ix,iy,iz)   = wfbc(ix,iy,1)
         uf(ix,iy,izp1) = ufbc(ix,iy,1)
         vf(ix,iy,izp1) = vfbc(ix,iy,1)
c
         u(ix,iy,izp1) = ubc(ix,iy,1)
         v(ix,iy,izp1) = vbc(ix,iy,1)
c ------------- note w and e nnz+1 values are not needed
c        w(ix,iy,izp1) = wbc(ix,iy,1)
c        e(ix,iy,izp1) = ebc(ix,iy,1)
         r3(ix,iy,izp1)= 0.0
         r5(ix,iy,izp1)= 0.0
c
c ---------- set derivatives at top of box (wx,wy not needed)
c            ux,uy,vx,vy are used in e production, but neglect
c            at top of box becuase of bc
c
         wx(ix,iy,izp1) = 0.0
         wy(ix,iy,izp1) = 0.0
         ux(ix,iy,izp1) = 0.0
         uy(ix,iy,izp1) = 0.0
         vx(ix,iy,izp1) = 0.0
         vy(ix,iy,izp1) = 0.0
      enddo
      enddo
      do iscl=1,nscl
         do iy=iys,iye
         do ix=1,nnx
            t(ix,iy,iscl,izp1) = tbc(ix,iy,iscl,1)
            t(ix,iy,iscl,izp2) = tbc(ix,iy,iscl,1)
         enddo
         enddo
      enddo
c
      return
      end
      subroutine upper_dns
c
c ---- set boundary condition on upper boundary iz=nnz
c ---- for DNS conditions (no-slip, molecular diffusion)
c ---- assumes the grid transformation has completely decayed
c
      use pars
      use fields
      use fftwk
      use con_data
      use con_stats
      include 'mpif.h'
      integer istatus(mpi_status_size)
c
      iz   = nnz
      izm1 = iz - 1
      izm2 = iz - 2
      izp1 = iz + 1
      izp2 = iz + 2


c
c --------- boundary conditions are Sullivan et al. (2000) Couette flow
c
        do iy=iys,iye
        do ix=1,nnx
           wbc(ix,iy,1) = 0.0
           ebc(ix,iy,1) = 0.0
           ubc(ix,iy,1) = 2.0*Uo-u(ix,iy,iz)
           vbc(ix,iy,1) = -v(ix,iy,iz)
           pbc(ix,iy,1) = 0.0
           pbc2(ix,iy,1)= 0.0
           ufbc(ix,iy,1) = Uo
           vfbc(ix,iy,1) = 0.0
c
c --------- upper boundary = grid speed
c
           wfbc(ix,iy,1) = gm(ix,iy,iz,5)
        enddo
        enddo

!Set the scalar boundary condition based on isfc:
! isfc = 0, specified surface heat flux (through qstar)
! isfc = 1, specified surface temperature (through tsfcc)

        do iscl=1,nscl
           do iy=iys,iye
           do ix=1,nnx
              if (isfc==1) then
              tbc(ix,iy,iscl,1) = 2.0*Ttop(iscl)-t(ix,iy,iscl,iz)
              end if
              if (isfc==0) then
              tbc(ix,iy,iscl,1) = t(ix,iy,iscl,iz) + 
     +           dzu(izp1)*wtsfc(iscl)/vis_s(ix,iy,izp1)
              end if
           enddo
           enddo
        enddo


      do iy=iys,iye
      do ix=1,nnx
         w(ix,iy,izp1)   = wbc(ix,iy,1)
         e(ix,iy,izp1)   = ebc(ix,iy,1)
c
         wf(ix,iy,iz)   = wfbc(ix,iy,1)
         uf(ix,iy,izp1) = ufbc(ix,iy,1)
         vf(ix,iy,izp1) = vfbc(ix,iy,1)
c
         u(ix,iy,izp1) = ubc(ix,iy,1)
         v(ix,iy,izp1) = vbc(ix,iy,1)
c ------------- note w and e nnz+1 values are not needed
c        w(ix,iy,izp1) = wbc(ix,iy,1)
c        e(ix,iy,izp1) = ebc(ix,iy,1)
         r3(ix,iy,izp1)= 0.0
         r5(ix,iy,izp1)= 0.0
c
c ---------- set derivatives at top of box (wx,wy not needed)
c            ux,uy,vx,vy are used in e production, but neglect
c            at top of box becuase of bc
c
         wx(ix,iy,izp1) = 0.0
         wy(ix,iy,izp1) = 0.0
         ux(ix,iy,izp1) = 0.0
         uy(ix,iy,izp1) = 0.0
         vx(ix,iy,izp1) = 0.0
         vy(ix,iy,izp1) = 0.0
      enddo
      enddo
      do iscl=1,nscl
         do iy=iys,iye
         do ix=1,nnx
            t(ix,iy,iscl,izp1) = tbc(ix,iy,iscl,1)
            t(ix,iy,iscl,izp2) = tbc(ix,iy,iscl,1)
         enddo
         enddo
      enddo
c
      return
      end
      subroutine psolver(istage)
c
c -------- solver poisson equation for the pressure
c
c          iflat == 0 ; no iteration flat bottom
c          iflat /= 0 ; iterate using diagonal preconditioner
c                       set max number of iterations ip_max 
c                       and convergence tolerance p_tol 
c          solve for fluctuating pressure then mean value.
c          array p(.,.,.) is p' array pm(.) is the mean value
c     
      use pars
      use fields
      use fftwk
      use con_data
      use con_stats
c
      call get_avg_j
c
      do k=izs-1,ize+1
         do j=iys,iye
         do i=1,nnx
            p(i,j,k) = 0.0
         enddo
         enddo
      enddo
c
c -------- special sequence for flat bottom
c
      if(iflat .eq. 0) then
         ip_iter = 0
         call build_rhs(ip_iter)
         call div_flux_vel
         call pressure
         call build_rhs(ip_iter)
      else
c
c ------- iteration sequence
c
         ip_iter = 0
    1    continue
            ip_iter = ip_iter + 1
            call build_rhs(ip_iter)
            call div_flux_vel
            call precon_p(ip_iter)
            call pressure
            call update_p(istage,ip_iter,ip_con)
         if(ip_iter .lt. ip_max .and. ip_con .eq. 0) go to 1
c
c -------- use last pressure iteration in flux velocity
c
         call build_rhs(ip_iter)
      endif
c
      return
      end
      subroutine build_rhs(ip_iter)
c
c ---------- build the rhs of the poisson equation
c            and update the flux velocities
c            use new time metrics. use wf equation to
c            get dp/dz at k = 0
c
      use pars
      use fields
      use fftwk
      use con_data
      use con_stats
      real fnt1(nnx,iys:iye,izs:ize+1), fnt2(nnx,iys:iye)
      real wf_sum(nnz)
      include 'mpif.h'
      integer istatus(mpi_status_size)
      real fs(nnx,iys:iye), fr(nnx,iys:iye)
c
c ------------ Send p to processor above the current myid.
c              to get p(.,.,izs-1)
c
      nb = myid - ncpu_s
      nt = myid + ncpu_s
      if(iss .eq. 0) then
         nb = mpi_proc_null
      endif
      if(ise .eq. numprocs-1) then
         nt = mpi_proc_null
      endif
      nsend = nnx*(iye + 1 - iys)
      nrecv = nsend
      do j=iys,iye
      do i=1,nnx
         fs(i,j) = p(i,j,ize)
      enddo
      enddo
c
      call mpi_sendrecv(
     +     fs(1,iys),nsend,mpi_real8,nt,2,
     +     fr(1,iys),nrecv,mpi_real8,nb,2,
     +     mpi_comm_world,istatus,ierr)
      if(iss .ne. 0) then
         do j=iys,iye
         do i=1,nnx
            p(i,j,izs-1) = fr(i,j)
         enddo
         enddo
      endif
c
      if(iss .eq. 0) then
c
c -------- flux velocity is set = grid speed at t = t_stage2
c          updated boundary speed at the next time step
c          picked to match future grid speed
c
         do j=iys,iye
         do i=1,nnx
            wf(i,j,izs-1) = wfbc(i,j,3)
         enddo
         enddo
      endif
c
c --------- get bottom ghost point for fluctuating pressure 
c
      if(izs == 1) then
c
      if(lpbc == 2) then
        k    = izs
        kp1  = k+1
        km1  = k-1
        gami = 1.0/dtgama
        if(ip_iter <= 1) then
          do j=iys,iye
          do i=1,nnx
             fnt1(i,j,k) = p(i,j,k)
             fnt2(i,j)   = fnt1(i,j,k)
          enddo
          enddo
        else
          do j=iys,iye
          do i=1,nnx
             fnt1(i,j,k) = 0.5*(p(i,j,k) + p_old(i,j,km1))
             fnt2(i,j)   = fnt1(i,j,k)
          enddo
          enddo
        endif
        call xderivp(fnt2(1,iys),trigx(1,1),xk(1),nnx,iys,iye)
        call yd_mpi(fnt1(1,iys,izs),trigx(1,2),yk(1),
     +            nnx,nny,ixs,ixe,ix_s,ix_e,
     +            iys,iye,iy_s,iy_e,izs,izs,myid,ncpu_s,numprocs)
        do j=iys,iye
        do i=1,nnx
            fac   = gm2(i,j,k,1)*(gm2(i,j,k,2)**2 + 
     +              gm2(i,j,k,3)**2 + gm2(i,j,k,4)**2)
            wbndy = (wfi(i,j,km1) - wf(i,j,km1))*gami
            facx  = gm2(i,j,k,1)*gm2(i,j,k,2)*fnt2(i,j)
            facy  = gm2(i,j,k,1)*gm2(i,j,k,3)*fnt1(i,j,k)
            p(i,j,km1) = p(i,j,k) - (wbndy - facx - facy)*dzu(k)/fac
        enddo
        enddo
c
      elseif(lpbc == 1) then
c
        w1 = -2.0*dzw(izs)/(dzw(izs) + dzw(izs+1))
        w2 = 1.0 - w1
        do j=iys,iye
        do i=1,nnx
           p(i,j,izs-1) = p(i,j,izs)*w2 + w1*p(i,j,izs+1)
        enddo
        enddo
c
      else
c
        do j=iys,iye
        do i=1,nnx
           p(i,j,izs-1) = p(i,j,izs)
        enddo
        enddo
      endif ! end of check for lpbc
c
      endif ! end of check for izs
c
      if(ize .eq. nnz) then
        do j=iys,iye
        do i=1,nnx
           p(i,j,ize+1) = p(i,j,ize)
        enddo
        enddo
      endif
c
c     if(izs .eq. 1)  then
c       k = 1
c       km1 = k - 1
c       kp1 = k + 1
c       j   = iys
c       write(nprt,8200) (i,p_old(i,j,km1), p(i,j,km1), 
c    +                    p_old(i,j,k), p(i,j,k),
c    +                    i = 1,5)
c8200   format(' build rhs',/,
c    +         ' i ',5x,' p old 0 ',5x,' p 0',5x,
c    +         ' p old 1 ',5x,' p 1',/,
c    +         (i5,4e15.6))
c     endif
c
c --------- save the last pressure iteration
c
      do k=izs-1,ize+1
         do j=iys,iye
         do i=1,nnx
            p_old(i,j,k) = p(i,j,k)
         enddo
         enddo
      enddo
c
      do k=izs,ize+1
         do j=iys,iye
         do i=1,nnx
            fnt1(i,j,k) = p_old(i,j,k)
         enddo
         enddo
         call xderivp(fnt1(1,iys,k),trigx(1,1),xk(1),nnx,iys,iye)
      enddo
c
      do k=izs,ize
         kp1   = k + 1
         km1   = k - 1
         do j=iys,iye
         do i=1,nnx
            pu_zeta   = weit(k)*p_old(i,j,kp1) + weitm(k)*p_old(i,j,k)
            pl_zeta   = weit(km1)*p_old(i,j,k) + 
     +                  weitm(km1)*p_old(i,j,km1)
            dpdz_c    = (pu_zeta - pl_zeta)*dzw_i(k)
            uf(i,j,k) = ufi(i,j,k) - dtgama*dpdz_c*
     +                  gm2(i,j,k,2)*gm2(i,j,k,1)
            vf(i,j,k) = vfi(i,j,k) - dtgama*dpdz_c*
     +                  gm2(i,j,k,3)*gm2(i,j,k,1)
            dpdz      = (p_old(i,j,kp1) - p_old(i,j,k))*dzu_i(kp1)
c
            facu      = gm2(i,j,kp1,1)*(gm2(i,j,kp1,2)**2 + 
     +                  gm2(i,j,kp1,3)**2 + gm2(i,j,kp1,4)**2)
            facl      = gm2(i,j,k,1)*(gm2(i,j,k,2)**2 + 
     +                  gm2(i,j,k,3)**2 + gm2(i,j,k,4)**2)
            wf(i,j,k) = wfi(i,j,k) - dtgama*(weit(k)*facu + 
     +                     weitm(k)*facl)*dpdz
         enddo
         enddo
         do j=iys,iye
         do i=1,nnx
            uf(i,j,k) = uf(i,j,k) - dtgama*fnt1(i,j,k)*gm2(i,j,k,1)
            facu      = gm2(i,j,kp1,1)*gm2(i,j,kp1,2)*fnt1(i,j,kp1)
            facl      = gm2(i,j,k,1)*gm2(i,j,k,2)*fnt1(i,j,k)
            wf(i,j,k) = wf(i,j,k) - dtgama*
     +                 (weit(k)*facu + weitm(k)*facl)
         enddo
         enddo
      enddo
c
c -------- get the y contributions
c
      do k=izs,ize+1
         do j=iys,iye
         do i=1,nnx
            fnt1(i,j,k) = p_old(i,j,k)
         enddo
         enddo
      enddo
      call yd_mpi(fnt1(1,iys,izs),trigx(1,2),yk(1),
     +            nnx,nny,ixs,ixe,ix_s,ix_e,
     +            iys,iye,iy_s,iy_e,izs,ize+1,myid,ncpu_s,numprocs)
c
      do k=izs,ize
         kp1 = k + 1
         km1 = k - 1
         do j=iys,iye
         do i=1,nnx
            vf(i,j,k) = vf(i,j,k) - dtgama*fnt1(i,j,k)*gm2(i,j,k,1)
            facu      = gm2(i,j,kp1,1)*gm2(i,j,kp1,3)*fnt1(i,j,kp1)
            facl      = gm2(i,j,k,1)*gm2(i,j,k,3)*fnt1(i,j,k)
            wf(i,j,k) = wf(i,j,k) - dtgama*
     +                  (weit(k)*facu + weitm(k)*facl)
         enddo
         enddo
      enddo
c
      if(ise .eq. numprocs-1) then
c
c -------- upper boundary speed at t = t_stage2
c
         do j=iys,iye
         do i=1,nnx
            wf(i,j,ize) = wfbc(i,j,4)
         enddo
         enddo
      endif
c
c ------------ make sure continuity is satisfied
c
      do k=1,nnz
         wf_sum(k) = 0.0
      enddo
      do k=izs,ize
         do j=iys,iye
         do i=1,nnx
            wf_sum(k) = wf_sum(k) + wf(i,j,k)
         enddo
         enddo
         wf_sum(k) = wf_sum(k)*fnxy
      enddo
c
c ---------- gather partial sums 
c
      call mpi_sum_z(wf_sum(1),i_root,myid,nnz,1)
c
      do k=izs,ize
         do j=iys,iye
         do i=1,nnx
            wf(i,j,k) = wf(i,j,k) - wf_sum(k)
         enddo
         enddo
      enddo
c
      return
      end
      subroutine div_flux_vel
c
c ----------- get the divergence of the flux velocity
c             and impose the boundary conditions on wf
c             new time metrics and weight for pressure
c
      use pars
      use fields
      use fftwk
      use con_data
      use con_stats
      include 'mpif.h'
      integer istatus(mpi_status_size)
c
      real fnt1(nnx,iys:iye,izs:ize)
      real fs(nnx,iys:iye), fr(nnx,iys:iye)
      real sum_div(1:nnz)
c
      gami = 1.0/dtgama
c
      do k=izs,ize
         do j=iys,iye
         do i=1,nnx
            fnt1(i,j,k) = uf(i,j,k)
         enddo
         enddo
         call xderivp(fnt1(1,iys,k),trigx(1,1),xk(1),nnx,iys,iye)
         do j=iys,iye
         do i=1,nnx
            p(i,j,k) = fnt1(i,j,k)
         enddo
         enddo
      enddo
      do k=izs,ize
         do j=iys,iye
         do i=1,nnx
            fnt1(i,j,k) = vf(i,j,k)
         enddo
         enddo
      enddo
      call yd_mpi(fnt1(1,iys,izs),trigx(1,2),yk(1),
     +            nnx,nny,ixs,ixe,ix_s,ix_e,
     +            iys,iye,iy_s,iy_e,izs,ize,myid,ncpu_s,numprocs)
c
c ------------ Send updated wf (from psolver)
c              to processor above the current myid.
c
      nb = myid - ncpu_s
      nt = myid + ncpu_s
      if(iss .eq. 0) then
         nb = mpi_proc_null
      endif
      if(ise .eq. numprocs-1) then
         nt = mpi_proc_null
      endif
      nsend = nnx*(iye + 1 - iys)
      nrecv = nsend
      do j=iys,iye
      do i=1,nnx
         fs(i,j) = wf(i,j,ize)
      enddo
      enddo
c
      call mpi_sendrecv(
     +     fs(1,iys),nsend,mpi_real8,nt,2,
     +     fr(1,iys),nrecv,mpi_real8,nb,2,
     +     mpi_comm_world,istatus,ierr)
      if(iss .ne. 0) then
         do j=iys,iye
         do i=1,nnx
            wf(i,j,izs-1) = fr(i,j)
         enddo
         enddo
      endif
c
      do k=izs,ize
         do j=iys,iye
         do i=1,nnx
            div_wf   = (wf(i,j,k) - wf(i,j,k-1))*dzw_i(k)
            p(i,j,k) = (p(i,j,k) + fnt1(i,j,k) + div_wf)*gami
         enddo
         enddo
      enddo
c
c debug -------
c
      do k=1,nnz
         sum_div(k) = 0.0
      enddo
      do k=izs,ize
         do j=iys,iye
         do i=1,nnx
            sum_div(k) = sum_div(k) + (p(i,j,k)/gami)**2
         enddo
         enddo
         sum_div(k) = sum_div(k)*fnxy
      enddo
c
c ---------- gather partial sums for rj_dif
c
      call mpi_sum_z(sum_div,i_root,myid,nnz,1)
c
c     write(nprt,9010) (k, sum_div(k),k=izs,ize)
c9010 format(' 9010 debug div flux ',/,
c    +       ' k ',5x,' div ',/,(i5,e20.10))
c
      return
      end
      subroutine get_avg_j
c
c ------- compute the average of (1/J,J) for use in preconditioner
c         metrics are at the new time
c
      use pars
      use fields
      use fftwk
      use con_data
      use con_stats
c
c --------- 1/J values stored at cell centers
c
      do k=0,nnz+1
         avg_j(k) = 0.0
      enddo
      do k=izs,ize
         do j=iys,iye
         do i=1,nnx
            avg_j(k) = avg_j(k) + gm2(i,j,k,1)
         enddo
         enddo
         avg_j(k) = avg_j(k)*fnxy
      enddo
c
c ---------- gather partial sums for avg_j
c
      call mpi_sum_z(avg_j(1),i_root,myid,nnz,1)
c
c ---------- J values stored at cell faces
c
      avg_j(0)     = avg_j(1)
      avg_j(nnz+1) = avg_j(nnz)
      do k=1,nnz
         fac        = avg_j(k+1)*weit(k) + avg_j(k)*weitm(k)
         avg_j_i(k) = 1.0/fac
      enddo
      avg_j_i(0)     = 1.0/avg_j(1)
      avg_j_i(nnz+1) = 1.0/avg_j(nnz)
c
c     write(nprt,1001) (k,avg_j(k),avg_j_i(k),k=0,nnz+1)
c1001 format(' 1000 get_avg_j ',/,
c    +       ' k ',5x,' avg j',5x,' avg j_i ',/,
c    +       (i5,2e15.6))
c
      return
      end
      subroutine precon_p(ip_iter)
c
c -------- evaluate the preconditioner at the last iteration
c          for p, p_old has last iteration 
c          new weight for pressure
c
      use pars
      use fields
      use fftwk
      use con_data
      use con_stats
c
      real fnt1(nnx,iys:iye,izs:ize)
c
      gami   = 1.0/dtgama
      relax  = accel(ip_iter)
      relax1 = 1.0 - relax
      relax1 = 1.0
c     write(nprt, 1017) ip_iter, relax
c1017 format(' 1017: precon ip_iter = ',i5,
c    +       ' relax = ',e15.6)
c
c ------- get x contribution
c
      do k=izs,ize
         do j=iys,iye
         do i=1,nnx
            fnt1(i,j,k) = p_old(i,j,k)
         enddo
         enddo
         call xdd(fnt1(1,iys,k),trigx(1,1),xkk(1),nnx,iys,iye)
         do j=iys,iye
         do i=1,nnx
            p(i,j,k) = fnt1(i,j,k)*avg_j(k)*relax1 + p(i,j,k)*relax
         enddo
         enddo
      enddo
c
c ------- get y contribution
c
      do k=izs,ize
         do j=iys,iye
         do i=1,nnx
            fnt1(i,j,k) = p_old(i,j,k)
         enddo
         enddo
      enddo
      call ydd_mpi(fnt1(1,iys,izs),trigx(1,2),ykk(1),
     +            nnx,nny,ixs,ixe,ix_s,ix_e,
     +            iys,iye,iy_s,iy_e,izs,ize,myid,ncpu_s,numprocs)
      do k=izs,ize
         do j=iys,iye
         do i=1,nnx
            p(i,j,k) = p(i,j,k) + fnt1(i,j,k)*avg_j(k)*relax1
         enddo
         enddo
      enddo
c
c ------- get z contribution
c         always use dp/dz = 0 for pre-conditioner
c         at izs=1
c
c
      do k=max(izs,2),ize
         kp1    = k + 1
         km1    = k - 1
         facu_i = avg_j_i(k)
         facl_i = avg_j_i(km1)
         do j=iys,iye
         do i=1,nnx
            dpdz_u = facu_i*(p_old(i,j,kp1) - p_old(i,j,k))*dzu_i(kp1)
            dpdz_l = facl_i*(p_old(i,j,k) - p_old(i,j,km1))*dzu_i(k)
            p(i,j,k) = p(i,j,k) + (dpdz_u - dpdz_l)*dzw_i(k)*relax1
         enddo
         enddo
      enddo
      if(izs == 1) then
         k      = izs
         kp1    = izs + 1
         facu_i = avg_j_i(k)
         do j=iys,iye
         do i=1,nnx
            dpdz_u   = facu_i*(p_old(i,j,kp1) - p_old(i,j,k))*dzu_i(kp1)
            p(i,j,k) = p(i,j,k) + dpdz_u*dzw_i(k)*relax1
         enddo
         enddo
      endif
c
c     if(izs .eq. 1)  then
c       k = 1
c       km1 = k - 1
c       kp1 = k + 1
c       j   = iys
c       write(nprt,8020) (i, p(i,j,km1), p(i,j,k), p(i,j,k+1), 
c    +                    i = 1,5)
c8020   format(' 8020 precon',/,
c    +         ' i ',5x,' p source  0 ',5x,' p 1',5x,
c    +         ' p 2',/,
c    +         (i5,3e15.6))
c     endif
c
      return
      end
      subroutine xdd(ax,trigx,xkk,nnx,iys,iye)
c
c -------- get multiple x second derivatives using fftpack routines
c          use fftpack storage a0, (a1,b1), (a2,b2),...,an
c          assumes that first wavenumber xk(1) = 0.0
c
c          assumes that wavenumbers are normalized by number of points
c
      real xkk(nnx), trigx(2*nnx+15), ax(nnx,iys:iye)
c
c     fn = 1.0/float(nnx)
      do iy=iys,iye
         call rfftf(nnx,ax(1,iy),trigx)
         ii = 1
         ax(1,iy) = 0.0
         ax(nnx,iy) = 0.0
         do ix=2,nnx-1,2
            ii          = ii + 1
            ax(ix,iy)   = -xkk(ii)*ax(ix,iy)
            ax(ix+1,iy) = -xkk(ii)*ax(ix+1,iy)
         enddo
         call rfftb(nnx,ax(1,iy),trigx)
      enddo
c
      return
      end
      subroutine ydd_mpi(ay,trigy,ykk,
     +           nx,ny,ixs,ixe,ix_s,ix_e,
     +           iys,iye,iy_s,iy_e,iz1,iz2,myid,ncpu,np)
c
c -------- get multiple y second derivatives using fftpack routines and mpi
c          use fftpack storage a_0, (a1,b1), (a2,b2), ...,
c          assumes that first wavenumber yk(1) = 0.0
c          wavenumbers are normalized by number of points, ny
c
      real ykk(ny), trigy(2*ny+15), ay(nx,iys:iye,iz1:iz2)
      real ayt(ny,ixs:ixe,iz1:iz2)
c
      integer ix_s(0:np-1), ix_e(0:np-1),
     +        iy_s(0:np-1), iy_e(0:np-1)
c
      call xtoy_trans(ay,ayt,nx,ny,ixs,ixe,ix_s,ix_e,
     +         iys,iye,iy_s,iy_e,iz1,iz2,myid,ncpu,np)
c
c     fn = 1.0/float(nny)
      do iz=iz1,iz2
         do ix=ixs,ixe
            call rfftf(ny,ayt(1,ix,iz),trigy)
            ii = 1
            ayt(1,ix,iz)  = 0.0
            ayt(ny,ix,iz) = 0.0
            do iy=2,ny-1,2
               ii              = ii + 1
               ayt(iy,ix,iz)   = -ykk(ii)*ayt(iy,ix,iz)
               ayt(iy+1,ix,iz) = -ykk(ii)*ayt(iy+1,ix,iz)
            enddo
            call rfftb(ny,ayt(1,ix,iz),trigy)
         enddo
      enddo
      call ytox_trans(ayt,ay,nx,ny,ixs,ixe,ix_s,ix_e,
     +         iys,iye,iy_s,iy_e,iz1,iz2,myid,ncpu,np)
c
      return
      end
      subroutine update_p(istage,ip_iter,ip_con)
c
c -------- check convergence and update p guess
c
      use pars
      use fields
      use fftwk
      use con_data
      use con_stats
      include 'mpif.h'
      integer istatus(mpi_status_size)
      data small_p /1.0e-10/
      save small_p
c
      pmax  = 0.0
      pdiff = 0.0
      do k=izs,ize
         p_temp  = abs(p(1,iys,k))
         pd_temp = abs(p(1,iys,k) - p_old(1,iys,k))
         do j=iys,iye
         do i=1,nnx
            p_temp  = amax1(abs(p(i,j,k)),p_temp)
            pd_temp = amax1(abs(p(i,j,k) - p_old(i,j,k)),pd_temp)
         enddo
         enddo
         pmax  = amax1(p_temp,pmax)
         pdiff = amax1(pd_temp,pdiff)
      enddo
      pmax      = amax1(pmax,small_p)
      ptest_loc = pdiff/pmax
c
      call mpi_allreduce(ptest_loc,ptest,1,mpi_real8,
     +     mpi_max,mpi_comm_world,ierror)
c
c     write(nprt,6000) ip_iter, pmax, ptest, ptol
c6000 format(' ip_iter = ',i5,' pmax = ',e15.6,
c    +       ' ptest = ',e15.6,' ptol = ',e15.6)
c
      ip_con = 0
      if(ptest .lt. ptol) ip_con = 1
      if(istage .eq. 1) then
         p_iter = float(ip_iter)
         p_err  = ptest
      endif
c
      return
      end
      subroutine comp2
c
c ------- add p gradients to rhs of (u,v,w). Use already defined p
c         at izs-1 and ize+1 to get (u,v,w). see build_rhs
c
c         multiplied by gm2 to get (u,v,w,e,theta) at the new time
c         pressure gradient is at new time and is weighted by dtgama          
c
c         included mean pressure in vertical gradients in sr. rhs_uvw
c
      use pars
      use fields
      use fftwk
      use con_data
      use con_stats
c
      real fnt1(nnx,iys:iye,izs:ize)
c
c ---------  ghost point pressure comes from build_rhs
c
c     if(izs .eq. 1) then
c       j = iys
c       k = 1
c       write(nprt,4001) (i,p(i,j,k-1), p(i,j,k), p(i,j,k+1),
c    +                    p(i,j,k+2),i=1,nnx)
c4001   format(' 4001 comp2 ',/,
c    +   ' i ',5x,' p km1 ',10x,' p k ',10x,' p kp1',10x,' p kp2',/,
c    +   (i5,4e15.6))
c     endif
c
      do k=izs,ize
         km1 = k - 1
         kp1 = k + 1
         do j=iys,iye
         do i=1,nnx
            fnt1(i,j,k) = p(i,j,k)*gm2(i,j,k,1)
         end do
         end do
         call xderivp(fnt1(1,iys,k),trigx(1,1),xk(1),nnx,iys,iye)
c
         do j=iys,iye
         do i=1,nnx
            p_kp1     = p(i,j,kp1)
            p_k       = p(i,j,k)
            p_km1     = p(i,j,km1)
c
c ------- u equation
c
            pu_zeta   = weit(k)*p_kp1*gm2(i,j,kp1,2)*
     +                  gm2(i,j,kp1,1) + 
     +                  weitm(k)*p_k*gm2(i,j,k,2)*gm2(i,j,k,1)
            pl_zeta   = weit(km1)*p_k*gm2(i,j,k,2)*gm2(i,j,k,1) + 
     +                  weitm(km1)*p_km1*gm2(i,j,km1,2)*
     +                  gm2(i,j,km1,1)
c
            dpdz_c    = (pu_zeta - pl_zeta)*dzw_i(k)
c
c --------  add pressure gradient to rhs
c
            r1(i,j,k) = r1(i,j,k) - (fnt1(i,j,k) + dpdz_c)
            u(i,j,k)  = (u(i,j,k) - dtgama*(fnt1(i,j,k) + dpdz_c))*
     +                  gm2(i,j,k,4)
c
c ------- w equation (use zeta_z/J = 1)
c
            pu_zeta   = weit(k)*p_kp1 + weitm(k)*p_k
            pl_zeta   = weit(km1)*p_k + weitm(km1)*p_km1
            dpdz_c    = (pu_zeta - pl_zeta)*dzw_i(k)
c
c -------- add pressure gradient to rhs
c
            r3(i,j,k) = r3(i,j,k) - dpdz_c
            w(i,j,k)  = (w(i,j,k) - dtgama*dpdz_c)*gm2(i,j,k,4)
c
c ------- e equation correct for Jacobian, result is e (not e/J)
c
            e(i,j,k) = e(i,j,k)*gm2(i,j,k,4)
         enddo
         enddo
      enddo
c
c ------ v equation
c
      do k=izs,ize
         do j=iys,iye
         do i=1,nnx
            fnt1(i,j,k) = p(i,j,k)*gm2(i,j,k,1)
         enddo
         enddo
      enddo
      call yd_mpi(fnt1(1,iys,izs),trigx(1,2),yk(1),
     +            nnx,nny,ixs,ixe,ix_s,ix_e,
     +            iys,iye,iy_s,iy_e,izs,ize,myid,ncpu_s,numprocs)
      do k=izs,ize
         kp1   = k + 1
         km1   = k - 1
         do j=iys,iye
         do i=1,nnx
            p_kp1     = p(i,j,kp1)
            p_k       = p(i,j,k)
            p_km1     = p(i,j,km1)
            pu_zeta   = weit(k)*p_kp1*gm2(i,j,kp1,3)*
     +                  gm2(i,j,kp1,1) + 
     +                  weitm(k)*p_k*gm2(i,j,k,3)*
     +                  gm2(i,j,k,1)
            pl_zeta   = weit(km1)*p_k*gm2(i,j,k,3)*
     +                  gm2(i,j,k,1) + 
     +                  weitm(km1)*p_km1*gm2(i,j,km1,3)*
     +                  gm2(i,j,km1,1)
            dpdz_c    = (pu_zeta - pl_zeta)*dzw_i(k)
c
c --------  add pressure gradient to rhs now
c
            r2(i,j,k) = r2(i,j,k) - (fnt1(i,j,k) + dpdz_c)
            v(i,j,k)  = (v(i,j,k) - dtgama*(fnt1(i,j,k) + dpdz_c))*
     +                  gm2(i,j,k,4)
         enddo
         enddo
      enddo
c
c ------------ scalar equations correct for J, result is theta (not theta/J)
c
      do k=izs,ize
         do l=1,nscl
         do j=iys,iye
         do i=1,nnx
            t(i,j,l,k) = t(i,j,l,k)*gm2(i,j,k,4)
         enddo
         enddo
         enddo
      enddo
c
      return
      end
      subroutine pressure
c
c -------- solve for fluctuating pressure using a matrix transpose
c          across mpi tasks and tridiagonal solver. 
c          The transposed array
c          is dimensioned (0:nnz+1). Values 
c          (0 & nnz+1) are not needed but are useful in the 
c          matrix transpose when we return (see send_ztox).
c          On exit p is defined at all [izs-1:ize+1].
c
      use pars
      use fields
      use fftwk
      use con_data
      use con_stats
      real pfft(nny,jxs:jxe,izs-1:ize+1)
      real pt(0:nnz+1,jxs:jxe,jys:jye)
      real ptopfft(nny,jxs:jxe,1:2)
      real psum(1:nnz)
      include 'mpif.h'
      integer istatus(mpi_status_size)
c
c ------------ Fourier analyze the right hand side
c              at all iz = izs,ize. results are in pfft
c
c
      call fft2d_mpi(p(1,iys,izs),pfft(1,jxs,izs),trigx(1,1),trigc,
     +           nnx,nny,jxs,jxe,jx_s,jx_e,iys,iye,iy_s,iy_e,
     +           izs,ize,myid,ncpu_s,numprocs,-2)
c
c ------------ Fourier analyze the radiation bc arrays
c
      if(ibcu .eq. 1) then
        call fft2d_mpi(ptop(1,iys,1),ptopfft(1,jxs,1),
     +           trigx(1,1),trigc,
     +           nnx,nny,jxs,jxe,jx_s,jx_e,iys,iye,iy_s,iy_e,
     +           1,2,myid,ncpu_s,numprocs,-2)
      endif
c
c ---------- transpose first and last index of array
c            the order of pfft is (y,x,z)
c
      call xtoz_trans(pfft,pt,nny,nnz,jys,jye,jy_s,jy_e,
     +                jxs,jxe,izs,ize,iz_s,iz_e,myid,ncpu_s,
     +                numprocs)
      call solve_trid(pt, ptopfft)
c
c ------------- transpose back
c
      call ztox_trans(pt,pfft,nny,nnz,jys,jye,jy_s,jy_e,
     +                jxs,jxe,izs,ize,iz_s,iz_e,myid,ncpu_s,
     +                numprocs)
c
      iz_ee = ize+1
      if(ise .eq. numprocs-1) then
         iz_ee = ize
      endif
c
c --------- inverse fft at all iz=izs,iz_ee to get p
c           see z indices
c
      call fft2d_mpi(p(1,iys,izs),pfft(1,jxs,izs),trigx(1,1),trigc,
     +           nnx,nny,jxs,jxe,jx_s,jx_e,iys,iye,iy_s,iy_e,
     +           izs,iz_ee,myid,ncpu_s,numprocs,2)
c
c -------- partial sums for pressure
c
      do iz=1,nnz
         psum(iz) = 0.0
      enddo
      do iz=izs,ize
         do iy=iys,iye
         do ix=1,nnx
            psum(iz) = psum(iz) + p(ix,iy,iz)
         enddo
         enddo
         psum(iz) = psum(iz)*fnxy
      enddo
      call mpi_sum_z(psum,i_root,myid,nnz,1)
c
      do iz=izs,iz_ee
c        psum(iz) = -psum(iz) + engz(iz) + c23*engsbz(iz)
         do iy=iys,iye
         do ix=1,nnx
            p(ix,iy,iz) = p(ix,iy,iz) - psum(iz)
         enddo
         enddo
      enddo
c
      return
      end
      subroutine solve_trid(pt, ptop)
c 
c --------- tridiagonal solver. odd order for ptop, ptop2
c           because of 2d-fft
c
      use pars
      use con_data
      use con_stats
c
      real ptop(nny,jxs:jxe,1:2)
      real pt(0:nnz+1,jxs:jxe,jys:jye)
      real aa(nnz,jxs:jxe),bb(nnz,jxs:jxe),
     +     dd(nnz,jxs:jxe),rh(nnz,jxs:jxe)
      real fac_u(nnz), fac_l(nnz), fac_a(nnz)
c
      do iz=1,nnz
         fac_u(iz) = avg_j_i(iz)/(dzw(iz)*dzu(iz+1))
         fac_l(iz) = avg_j_i(iz-1)/(dzw(iz)*dzu(iz))
         fac_a(iz) = fac_l(iz) + fac_u(iz)
      enddo
c
      do kp=jys,jye    
         do lp=jxs,jxe
         do iz=2,nnz-1
            bb(iz,lp)  = fac_l(iz)
            aa(iz,lp)  = fac_u(iz)
            dd(iz,lp)  = -xks(lp,kp)*avg_j(iz) - fac_a(iz)
            rh(iz,lp)  = pt(iz,lp,kp)
         enddo
         enddo
c
c --------------- lower boundary, fill exterior pressure (not used)
c
         do lp=jxs,jxe
            bb(1,lp)  = 1.0
            aa(1,lp)  = fac_u(1)
            dd(1,lp)  = -xks(lp,kp)*avg_j(1) - fac_u(1)
            rh(1,lp)  = pt(1,lp,kp)
            pt(0,lp,kp) = 0.0
         enddo
c
c --------------- upper boundary, fill exterior pressure (not used)
c
         if(ibcu .eq. 1) then
            do lp=jxs,jxe
              bb(nnz,lp) = 0.0
              aa(nnz,lp) = 0.0
              dd(nnz,lp) = 1.0
              rh(nnz,lp) = ptop(kp,lp,1)*wavexy(lp,kp) + ptop(kp,lp,2)
              pt(nnz+1,lp,kp) = 0.0
            enddo
         else
            do lp=jxs,jxe
               bb(nnz,lp) = fac_l(nnz)
               aa(nnz,lp) = 1.0
               dd(nnz,lp) = -xks(lp,kp)*avg_j(nnz) - fac_l(nnz)
               rh(nnz,lp) = pt(nnz,lp,kp)
               pt(nnz+1,lp,kp) = 0.0
            enddo
         endif
c
c ---------------- special situation for zeroth mode
c                  makes mean pressure = 0
c
         if(kp .eq. 1 .and. jxs .eq. 1) then
           do iz=1,nnz
              dd(iz,1) = 1.0
              rh(iz,1) = 0.0
              aa(iz,1) = 0.0
              bb(iz,1) = 0.0
              dd(iz,2) = 1.0
              rh(iz,2) = 0.0
              aa(iz,2) = 0.0
              bb(iz,2) = 0.0
           enddo
         endif
c
c --------------- solve system
c
         call tridv(bb,dd,aa,rh,nnz,jxs,jxe)
         do lp=jxs,jxe
         do iz=1,nnz
            pt(iz,lp,kp) = rh(iz,lp)
         enddo
         enddo
      enddo
c
      return
      end
      subroutine solve_mean_p(wf_sum,sum_fz)
c 
c --------- tridiagonal solver for mean pressure from wf equation
c           set ghost values of pm also
c
      use pars
      use con_data
      use con_stats
c
      real wf_sum(0:nnz), sum_fz(nnz)
      real aa(nnz),bb(nnz),dd(nnz),rh(nnz)
c
      gami = 1.0/dtgama
c     tiny = 1.0e-20
      tiny = 0.0
c
      do k=2,nnz-1
         fac_l  = sum_fz(k-1)*dzu_i(k) 
         fac_u  = sum_fz(k)*dzu_i(k+1)
         bb(k)  = fac_l
         aa(k)  = fac_u
         dd(k)  = -(fac_u + fac_l + tiny)
         rh(k)  = gami*(wf_sum(k) - wf_sum(k-1))
      enddo
c
c --------------- lower boundary, assume average wf at boundary = 0
c
      k       = 1
      fac_u   = sum_fz(k)*dzu_i(k+1)
      bb(k)   = 0.0
      aa(k)   = fac_u
      dd(k)   = -(fac_u + tiny)
      rh(k)   = gami*(wf_sum(k) - wf_sum(k-1))
c
c --------------- upper boundary, average wf at boundary = 0
c
      k       = nnz
      fac_l   = sum_fz(k-1)*dzu_i(k)
      bb(k)   = fac_l
      aa(k)   = 0.0
      dd(k)   = -(fac_l + tiny)
      rh(k)   = gami*(wf_sum(k) - wf_sum(k-1))
c
c --------------- solve system
c
      call trids(bb,dd,aa,rh,nnz)
      do k=1,nnz
         pm(k) = rh(k)
      enddo
c
      if(lpbc == 1) then
        k       = 1
        w1      = -2.0*dzw(k)/(dzw(k) + dzw(k+1))
        w2      = 1.0 - w1
        pm(k-1) = pm(k)*w2 + w1*pm(k+1)
      elseif(lpbc == 0) then
        k       = 1
        pm(k-1) = pm(k)
      endif
c
      pm(nnz+1) = pm(nnz)
c
      return
      end
      subroutine solve_mean_p_old(wf_sum,sum_fz)
c 
c --------- tridiagonal solver for mean pressure from wf equation
c           set ghost values of pm also
c
      use pars
      use con_data
      use con_stats
c
      real wf_sum(nnz), sum_fz(nnz)
      real aa(nnz),bb(nnz),dd(nnz),rh(nnz)
c
      gami = 1.0/dtgama
c     tiny = 1.0e-20
      tiny = 0.0
c
      do k=2,nnz-1
         fac_l  = sum_fz(k-1)/(dzw(k)*dzu(k))
         fac_u  = sum_fz(k)/(dzw(k)*dzu(k+1))
         bb(k)  = fac_l
         aa(k)  = fac_u
         dd(k)  = -(fac_u + fac_l + tiny)
         rh(k)  = gami*(wf_sum(k) - wf_sum(k-1))*dzw_i(k)
      enddo
c
c --------------- lower boundary, assume average wf at boundary = 0
c
      k       = 1
      fac_u   = sum_fz(k)/(dzw(k)*dzu(k+1))
      bb(k)   = 0.0
      aa(k)   = fac_u
      dd(k)   = -(fac_u + tiny)
      rh(k)   = gami*wf_sum(k)*dzw_i(k)
c
c --------------- upper boundary, average wf at boundary = 0
c
      k       = nnz
      fac_l   = sum_fz(k-1)/(dzw(k)*dzu(k))
      bb(k)   = fac_l
      aa(k)   = 0.0
      dd(k)   = -(fac_l + tiny)
      rh(k)   = -gami*wf_sum(k-1)*dzw_i(k)
c
c --------------- solve system
c
      call trids(bb,dd,aa,rh,nnz)
      do k=1,nnz
         pm(k) = rh(k)
      enddo
c
      if(lpbc == 1) then
        k       = 1
        w1      = -2.0*dzw(k)/(dzw(k) + dzw(k+1))
        w2      = 1.0 - w1
        pm(k-1) = pm(k)*w2 + w1*pm(k+1)
      elseif(lpbc == 0) then
        k       = 1
        pm(k-1) = pm(k)
      endif
c
      pm(nnz+1) = pm(nnz)
c
      return
      end
      subroutine trids(b,d,a,r,n)
c
c --- tridiagonal matrix solver with single vector
c
c --- input:   n   size of a,b,d and r
c              b   below diagonal elements (b(1) not used)
c              d   diagonal elements
c              a   above diagonal elements (a(n) not used)
c              r   right hand side
c
c --- output:  r   solution vector
c
      real b(n), d(n), a(n), r(n)
c
      if(n .le. 1 ) then
        r(1) = r(1)/d(1)
         go to 999
      endif
      d(1) = 1.0/d(1)
      do i=2,n
         fac = b(i)*d(i-1)
         d(i) = 1.0/(d(i) - fac*a(i-1))
         r(i) = r(i) - fac*r(i-1)
      enddo
      r(n) = r(n)*d(n)
      do i=n-1,1,-1
         r(i) = d(i)*(r(i) - a(i)*r(i+1))
      enddo
  999 continue
c
      return
      end
      subroutine tridv(b,d,a,r,n,j1,j2)
c
c --- tridiagonal matrix solver with multiple vectors
c     (note j and i loops are reversed from cray version)
c
c --- input:   n   size of a,b,d and r
c              b   below diagonal elements (b(1) not used)
c              d   diagonal elements
c              a   above diagonal elements (a(n) not used)
c              r   right hand side
c              j1:j2  range of input vectors
c
c --- output:  r   solution vector
c
      real b(n,j1:j2), d(n,j1:j2), a(n,j1:j2), r(n,j1:j2)
c
      if(n .le. 1 ) then
         do j=j1,j2
            r(1,j) = r(1,j)/d(1,j)
         enddo
         go to 999
      endif
      do j=j1,j2
         d(1,j) = 1.0/d(1,j)
      enddo
      do j=j1,j2
      do i=2,n
         fac = b(i,j)*d(i-1,j)
         d(i,j) = 1.0/(d(i,j) - fac*a(i-1,j))
         r(i,j) = r(i,j) - fac*r(i-1,j)
      enddo
      enddo
      do j=j1,j2
         r(n,j) = r(n,j)*d(n,j)
      enddo
      do j=j1,j2
      do i=n-1,1,-1
         r(i,j) = d(i,j)*(r(i,j) - a(i,j)*r(i+1,j))
      enddo
      enddo
  999 continue
c
      return
      end
      subroutine get_derv
c
c ------- get ux,uy,vx,vy at all z for this node
c         using parallel fft. can be improved (?)
c         by using exchange to send derivatives
c
      use pars
      use fields
      use fftwk
      use con_data
      use con_stats
c
      iz_ss = izs-1
      iz_ee = ize+1
      if(iss .eq. 0) then
         iz_ss = izs 
      endif
      if(ise .eq. numprocs-1) then
         iz_ee = ize
      endif
c
c ------- make sure <w> = 0
c
      do iz=izs-1,ize+1
         w_sum = 0.0
         do iy=iys,iye
         do ix=1,nnx
            w_sum = w_sum + w(ix,iy,iz)
         enddo
         enddo
         w_sum = w_sum*fnxy
         call mpi_sum_xy(w_sum,myid,iss,ise,1)
         do iy=iys,iye
         do ix=1,nnx
            w(ix,iy,iz) = w(ix,iy,iz) - w_sum
         enddo
         enddo
      enddo
c
      do iz=izs-1,ize+1
         do iy=iys,iye
         do ix=1,nnx
            ux(ix,iy,iz) = u(ix,iy,iz)
            vx(ix,iy,iz) = v(ix,iy,iz)
            wx(ix,iy,iz) = w(ix,iy,iz)
            uy(ix,iy,iz) = u(ix,iy,iz)
            vy(ix,iy,iz) = v(ix,iy,iz)
            wy(ix,iy,iz) = w(ix,iy,iz)
         enddo
         enddo
c        endif
         call xderivp(ux(1,iys,iz),trigx(1,1),xk(1),
     +                 nnx,iys,iye)
         call xderivp(vx(1,iys,iz),trigx(1,1),xk(1),
     +                 nnx,iys,iye)
         call xderivp(wx(1,iys,iz),trigx(1,1),xk(1),
     +                 nnx,iys,iye)
      enddo
c
c ---------- get y derivatives for (u,v,w)
c
      call yd_mpi(uy(1,iys,izs-1),trigx(1,2),yk(1),
     +           nnx,nny,ixs,ixe,ix_s,ix_e,
     +           iys,iye,iy_s,iy_e,izs-1,ize+1,myid,ncpu_s,numprocs)
      call yd_mpi(vy(1,iys,izs-1),trigx(1,2),yk(1),
     +           nnx,nny,ixs,ixe,ix_s,ix_e,
     +           iys,iye,iy_s,iy_e,izs-1,ize+1,myid,ncpu_s,numprocs)
      call yd_mpi(wy(1,iys,izs-1),trigx(1,2),yk(1),
     +           nnx,nny,ixs,ixe,ix_s,ix_e,
     +           iys,iye,iy_s,iy_e,izs-1,ize+1,myid,ncpu_s,numprocs)
c
      return
      end
      subroutine chk_div
c
      use pars
      use fields
      use fftwk
      use con_data
      use con_stats
      real fnt1(nnx,iys:iye,izs:ize+1), fnt2(nnx,iys:iye)
      real div_c(nnz)
c
      do iz=1,nnz
         div_c(iz) = 0.0
      enddo
        do k=izs,ize
           do j=iys,iye
           do i=1,nnx
              fnt1(i,j,k) = vf(i,j,k)
           enddo
           enddo
        enddo
        call yd_mpi(fnt1(1,iys,izs),trigx(1,2),yk(1),
     +              nnx,nny,ixs,ixe,ix_s,ix_e,
     +              iys,iye,iy_s,iy_e,izs,ize,myid,ncpu_s,numprocs)
        do k=izs,ize
           do j=iys,iye
           do i=1,nnx
              fnt2(i,j) = uf(i,j,k)
           enddo
           enddo
           call xderivp(fnt2(1,iys),trigx(1,1),xk(1),nnx,iys,iye)
           km1 = k - 1
           do j=iys,iye
           do i=1,nnx
              div_c(k) = div_c(k) + 
     +                  (fnt2(i,j) + fnt1(i,j,k) +
     +                  (wf(i,j,k) - wf(i,j,km1))*dzw_i(k))**2
           enddo
           enddo
           div_c(k) = div_c(k)*fnxy
        enddo
        call mpi_sum_z(div_c(1),i_root,myid,nnz,1)
c
      write(nprt,9010) (k, div_c(k),k=izs,ize)
 9010 format(' 9010 debug chk div',/,
     +       ' k ',5x,' div ',/,(i5,e20.10))
c
      return
      end
      subroutine get_means(istage)
c
c ------------ get means for all variables
c              for use in iso, surfvis, comp1, tke_stats.
c              simple average along coordinate lines 
c
      use pars
      use fields
      use fftwk
      use con_data
      use con_stats
      real fnt1(nnx,iys:iye,izs:ize+1), fnt2(nnx,iys:iye)
c
      do iz=0,nnz+1
         u_mn(iz)   = 0.0
         v_mn(iz)   = 0.0
         w_mn(iz)   = 0.0
         engz(iz)   = 0.0
         engsbz(iz) = 0.0
         divz(iz)   = 0.0
         pxym(iz)   = 0.0
      enddo
      do iscl=1,nscl
         do iz=0,nnz+1
            t_mn(iz,iscl) = 0.0
         enddo
      enddo
      iz_ee = ize
      if(ize .eq. nnz) iz_ee = nnzp1
      do iz=izs,iz_ee
         do iy=iys,iye
         do ix=1,nnx
            u_mn(iz) = u_mn(iz) + u(ix,iy,iz)
            v_mn(iz) = v_mn(iz) + v(ix,iy,iz)
            w_mn(iz) = w_mn(iz) + w(ix,iy,iz)
         enddo
         enddo
         u_mn(iz) = u_mn(iz)*fnxy
         v_mn(iz) = v_mn(iz)*fnxy
         w_mn(iz) = w_mn(iz)*fnxy
         do iscl=1,nscl
            t_mn(iz,iscl) = 0.0
            do iy=iys,iye
            do ix=1,nnx
               t_mn(iz,iscl) = t_mn(iz,iscl) + t(ix,iy,iscl,iz)
            enddo
            enddo
            t_mn(iz,iscl) = t_mn(iz,iscl)*fnxy
         enddo
      enddo
      call mpi_sum_z(u_mn(1),i_root,myid,nnzp1,1)
      call mpi_sum_z(v_mn(1),i_root,myid,nnzp1,1)
      call mpi_sum_z(w_mn(1),i_root,myid,nnzp1,1)
      do iscl=1,nscl
         call mpi_sum_z(t_mn(1,iscl),i_root,myid,nnzp1,1)
      enddo
c
c -------- set e to minimum value 
c
      do iz=izs-1,ize+1
         do iy=iys,iye
         do ix=1,nnx
            e(ix,iy,iz) = amax1(e(ix,iy,iz ),sml_eg)
         enddo
         enddo
      enddo
c
c ------- get terms which contribute to mean pressure
c         careful with the sum, get the mean p_star pressure
c         CHECK if rotational form of the equations correct pxym see flat code
c
      do iz=izs,ize
         izm1 = iz - 1
         do iy=iys,iye
         do ix=1,nnx
            q_temp     =  0.5*(u(ix,iy,iz)**2 +
     +                         v(ix,iy,iz)**2 +
     +                         w(ix,iy,iz)**2)
            engz(iz)   = engz(iz) + q_temp
            engsbz(iz) = engsbz(iz) + e(ix,iy,iz)
            pxym(iz)   = pxym(iz) + (p(ix,iy,iz) - c23*e(ix,iy,iz))
         enddo
         enddo
         engz(iz)   = engz(iz)*fnxy
         engsbz(iz) = engsbz(iz)*fnxy
         pxym(iz)   = pxym(iz)*fnxy
      enddo
      call mpi_sum_z(engz(1),i_root,myid,nnzp1,1)
      call mpi_sum_z(engsbz(1),i_root,myid,nnzp1,1)
      call mpi_sum_z(pxym(1),i_root,myid,nnz,1)
c
c ------------ save means and divergence for printout and compmn
c              all cpus have means over all z
c
      if(istage .eq. 1) then
        do k=izs,ize
           do j=iys,iye
           do i=1,nnx
              fnt1(i,j,k) = vf(i,j,k)
           enddo
           enddo
        enddo
        call yd_mpi(fnt1(1,iys,izs),trigx(1,2),yk(1),
     +              nnx,nny,ixs,ixe,ix_s,ix_e,
     +              iys,iye,iy_s,iy_e,izs,ize,myid,ncpu_s,numprocs)
        do k=izs,ize
           do j=iys,iye
           do i=1,nnx
              fnt2(i,j) = uf(i,j,k)
           enddo
           enddo
           call xderivp(fnt2(1,iys),trigx(1,1),xk(1),nnx,iys,iye)
           km1 = k - 1
           do j=iys,iye
           do i=1,nnx
              divz(k) = divz(k) + 
     +                  (fnt2(i,j) + fnt1(i,j,k) +
     +                  (wf(i,j,k) - wf(i,j,km1))*dzw_i(k))**2
           enddo
           enddo
           divz(k) = divz(k)*fnxy
        enddo
        call mpi_sum_z(divz(1),i_root,myid,nnz,1)
c
        do iz=1,nnz+1
           uxym(iz) = u_mn(iz)
           vxym(iz) = v_mn(iz)
           wxym(iz) = w_mn(iz)
        enddo
        do iscl=1,nscl
           do iz=1,nnz
              txym(iz,iscl) = t_mn(iz,iscl)
           enddo
        enddo
      endif
c
      return
      end
      subroutine spline(x,y,n,yp1,ypn,y2)
      integer n, nmax
      real yp1, ypn, x(n), y(n), y2(n)
      parameter (nmax=5000)
      integer i, k
      real p, qn, sig, un, u(nmax)
      if(yp1 .gt. .99e30) then
         y2(1) = 0.0
         u(1)  = 0.0
      else
         y2(1) = -0.5
         u(1) = (3./(x(2) - x(1)))*((y(2) - y(1))/(x(2) - x(1)) - yp1)
      endif
      do i=2,n-1
         sig = (x(i) - x(i-1))/(x(i+1) - x(i-1))
         p = sig*y2(i-1) + 2.0
         y2(i) = (sig - 1.0)/p
         u(i) = (6.0*((y(i+1) - y(i))/(x(i+1) - x(i)) - (y(i) - y(i-1))
     +          /(x(i) - x(i-1)))/(x(i+1) - x(i-1)) - sig*u(i-1))/p
      enddo
      if(ypn .gt. .99e+30) then
         qn = 0.0
         un = 0.0
      else
         qn = 0.5
         un = (3.0/(x(n) - x(n-1)))*
     +        (ypn - (y(n) - y(n-1))/(x(n) - x(n-1)))
      endif
      y2(n) = (un - qn*u(n-1))/(qn*y2(n-1) + 1.0)
      do k=n-1,1,-1
         y2(k) = y2(k)*y2(k+1) + u(k)
      enddo
c
      return
      end
      subroutine splint(xa,ya,y2a,n,x,y)
      integer n
      real x,y, xa(n), y2a(n), ya(n)
      integer k,khi,klo
      real a,b,h
      klo = 1
      khi = n
    1 continue
        if(khi - klo .gt. 1) then
           k = (khi + klo)/2
           if(xa(k) .gt. x) then
              khi = k
           else
              klo = k
           endif
           go to 1
      endif
      h = xa(khi) - xa(klo)
      a = (xa(khi) - x)/h
      b = (x - xa(klo))/h
      y = a*ya(klo) + b*ya(khi) +
     +    ((a**3 - a)*y2a(klo) + (b**3 - b)*y2a(khi))*(h**2)/6.0
c
      return
      end
      subroutine hx_deriv(ax_s,trigx,xk,nnx,ax)
c
c -------- get an x derivative saving the input. Use fftpack routines
c          with fftpack storage a0, (a1,b1), (a2,b2),...,an
c          assumes that first wavenumber xk(1) = 0.0
c
c          assumes that wavenumbers are normalized by number of points
c
      real xk(nnx), trigx(2*nnx+15), ax_s(nnx), ax(nnx)
c
      fn = 1.0/float(nnx)
      do i=1,nnx
         ax(i) = ax_s(i)*fn
      enddo
c
      call rfftf(nnx,ax(1),trigx)
c
      ii      = 1
      ax(1)   = 0.0
      ax(nnx) = 0.0
      do ix=2,nnx-1,2
         ii       = ii + 1
         temp     = ax(ix)
         ax(ix)   = -xk(ii)*ax(ix+1)
         ax(ix+1) = xk(ii)*temp
      enddo
      call rfftb(nnx,ax(1),trigx)
c
      return
      end
      subroutine gal_interp(f,trigx,nnx,xk,dx,fi)
c
c ---------- propagate array f forward in space by distance dx
c            input is fourier coefficients in fftpack order
c 
      real f(nnx), trigx(15+4*nnx), fi(nnx), xk(nnx)
c
      ncx = nnx/2 + 1
c
c --------- generate new coefficients
c
      cc    = 1.0
      ss    = 0.0
      fi(1) = f(1)*cc
      kk    = 1
      do i=2,nnx-1,2
         kk = kk + 1
         cc = cos(xk(kk)*dx)
         ss = sin(xk(kk)*dx)
         aa = f(i)
         bb = f(i+1)
         fi(i)   = aa*cc - bb*ss
         fi(i+1) = bb*cc + aa*ss
      enddo
      cc      = cos(xk(ncx)*dx)
      ss      = 0.0
      aa      = f(nnx)
      fi(nnx) = aa*cc
c
c --------- transform back to get function at correct x points
c
      call rfftb(nnx,fi(1),trigx)
c
      return
      end
      subroutine hdot_interp(f,trigx,nnx,xk,dx,cs,fi)
c
c ----------- get hdot assuming packet moves with speed cs
c
      real f(nnx), trigx(15+4*nnx), fi(nnx), xk(nnx)
c
      ncx = nnx/2 + 1
c
c --------- generate modified fourier coefficients
c
c     uu    = -cs
      uu    = cs
      fi(1) = 0.0
      kk    = 1
      do i=2,nnx-1,2
         kk = kk + 1
         uk = xk(kk)*uu
         cc = cos(xk(kk)*dx)
         ss = sin(xk(kk)*dx)
         aa = f(i)
         bb = f(i+1)
         fi(i)     = uk*(aa*ss + bb*cc)
         fi(i+1)   = uk*(bb*ss - aa*cc)
      enddo
      fi(nnx) = 0.0
c
c --------- transform back to get function at correct x points
c
      call rfftb(nnx,fi(1),trigx)
c
      return
      end
      subroutine xderivp(ax,trigx,xk,nnx,iys,iye)
c
c -------- get multiple x derivatives using fftpack routines
c          use fftpack storage a0, (a1,b1), (a2,b2),...,an
c          assumes that first wavenumber xk(1) = 0.0
c
c          assumes that wavenumbers are normalized by number of points
c
      real xk(nnx), trigx(2*nnx+15), ax(nnx,iys:iye)
c
c     fn = 1.0/float(nnx)
      do iy=iys,iye
         call rfftf(nnx,ax(1,iy),trigx)
         ii = 1
         ax(1,iy) = 0.0
         ax(nnx,iy) = 0.0
         do ix=2,nnx-1,2
            ii          = ii + 1
            temp        = ax(ix,iy)
            ax(ix,iy)   = -xk(ii)*ax(ix+1,iy)
            ax(ix+1,iy) = xk(ii)*temp
         enddo
         call rfftb(nnx,ax(1,iy),trigx)
      enddo
c
      return
      end
      subroutine fft2d_mpi(ax,at,trigx,trigc,nx,ny,
     +           jxs,jxe,jx_s,jx_e,iys,iye,iy_s,iy_e,
     +           iz1,iz2,myid,ncpu,np,isgn)
c
c -------- get 2d fft using fftpack routines and parallel mpi
c          use fftpack storage a0, (a1,b1), (a2,b2),...,
c
c         isgn = -1 do forward transform, get coefficients
c                   incoming array is ax(nx+2,iys:iye,iz1:iz2)
c                   outgoing array is ax(nx+2,iys:iye,iz1:iz2)
c
c         isgn = -2 do forward transform, get coefficients
c                   incoming array is ax(nx+2,iys:iye,iz1:iz2)
c                   outgoing array is at(ny,jxs:jxe,iz1:iz2)
c
c         isgn =  1 do inverse transform, move to physical space
c                   incoming array is ax(nx+2,iys:iye,iz1:iz2)
c                   outgoing array is ax(nx+2,iys:iye,iz1:iz2)
c
c         isgn =  2 do inverse transform, move to physical space
c                   incoming array is at(ny,jxs:jxe,iz1:iz2)
c                   outgoing array is ax(nx+2,iys:iye,iz1:iz2)
c
      real ax(nx+2,iys:iye,iz1:iz2), at(ny,jxs:jxe,iz1:iz2),
     +     trigx(2*nx+15), trigc(4*ny+15),
     +     a2d(2,ny), a_wrk(nx)
      integer jx_s(0:np-1), jx_e(0:np-1),
     +        iy_s(0:np-1), iy_e(0:np-1)
c
      nxp2 = nx + 2
      if(isgn .lt. 0) then
         fn   = 1.0/(float(nx)*float(ny))
c
c ------ 1d fft in x over [iys,iye] for all z
c
         do iz=iz1,iz2
            do iy=iys,iye
               do ix=1,nx
                  a_wrk(ix) = ax(ix,iy,iz)*fn
               enddo
               call rfftf(nx,a_wrk(1),trigx(1))
               ax(1,iy,iz) = a_wrk(1)
               ax(2,iy,iz) = 0.0
               do ix=2,nx
                  ax(ix+1,iy,iz) = a_wrk(ix)
               enddo
               ax(nx+2,iy,iz) = 0.0
            enddo
         enddo
         call xtoy_trans(ax,at,nxp2,ny,jxs,jxe,jx_s,jx_e,
     +        iys,iye,iy_s,iy_e,iz1,iz2,myid,ncpu,np)
c
c ------ 1d fft in y over [jxs,jxe] for all z
c
         do iz=iz1,iz2
            do ix=jxs,jxe,2
               do iy=1,ny
                  a2d(1,iy) = at(iy,ix,iz)
                  a2d(2,iy) = at(iy,ix+1,iz)
               enddo
               call cfftf(ny,a2d(1,1),trigc(1))
               do iy=1,ny
                  at(iy,ix,iz)   = a2d(1,iy)
                  at(iy,ix+1,iz) = a2d(2,iy)
               enddo
            enddo
         enddo
c
c ---- decide whether to transpose back or leave as is
c
         if(isgn .eq. -1) then
            call ytox_trans(at,ax,nxp2,ny,jxs,jxe,jx_s,jx_e,
     +           iys,iye,iy_s,iy_e,iz1,iz2,myid,ncpu,np)
         endif
c
      else
c
c ---- decide whether to first transpose or leave as is
c
         if(isgn .eq. 1) then
            call xtoy_trans(ax,at,nxp2,ny,jxs,jxe,jx_s,jx_e,
     +           iys,iye,iy_s,iy_e,iz1,iz2,myid,ncpu,np)
         endif
c
c ------ 1d fft in y over [jxs,jxe] for all z
c
         do iz=iz1,iz2
            do ix=jxs,jxe,2
               do iy=1,ny
                  a2d(1,iy) = at(iy,ix,iz)
                  a2d(2,iy) = at(iy,ix+1,iz)
               enddo
               call cfftb(ny,a2d(1,1),trigc(1))
               do iy=1,ny
                  at(iy,ix,iz)   = a2d(1,iy)
                  at(iy,ix+1,iz) = a2d(2,iy)
               enddo
            enddo
         enddo
         call ytox_trans(at,ax,nxp2,ny,jxs,jxe,jx_s,jx_e,
     +        iys,iye,iy_s,iy_e,iz1,iz2,myid,ncpu,np)
c
c ------  1d fft in x over [iys,iye] for all z
c
         do iz=iz1,iz2
            do iy=iys,iye
               a_wrk(1) = ax(1,iy,iz)
               do ix=2,nx
                  a_wrk(ix) = ax(ix+1,iy,iz)
               enddo
               call rfftb(nx,a_wrk(1),trigx(1))
               do ix=1,nx
                  ax(ix,iy,iz) = a_wrk(ix)
               enddo
            enddo
         enddo
      endif
c
      return
      end
      subroutine fft2d_cmplx_mpi(ax,at,trigx,trigy,nx,nx2,ny,
     +           i2xs,i2xe,i2x_s,i2x_e,iys,iye,iy_s,iy_e,
     +           iz1,iz2,myid,ncpu,np)
c
c -------- get 2d inverse fft using complex fftpack routines
c          move from fourier space to physical space. specifically
c          designed for flow over waves with full complex wave spectrum
c
      real trigx(4*nx+15), trigy(4*ny+15), ax(nx2,iys:iye,iz1:iz2)
      real a2d(2,ny), at(ny,i2xs:i2xe,iz1:iz2)
      integer i2x_s(0:np-1), i2x_e(0:np-1), iy_s(0:np-1), iy_e(0:np-1)
c
c --------- transform in x direction
c
      do k=iz1,iz2
      do j=iys,iye
         call cfftb(nx,ax(1,j,k),trigx(1))
      enddo
      enddo
c
c --------- transform in y direction
c
      call xtoy_trans(ax,at,nx2,ny,i2xs,i2xe,i2x_s,i2x_e,
     +         iys,iye,iy_s,iy_e,iz1,iz2,myid,ncpu,np)
c
      do k=iz1,iz2
      do i=i2xs,i2xe,2
         do j=1,ny
            a2d(1,j) = at(j,i,k)
            a2d(2,j) = at(j,i+1,k)
         enddo
         call cfftb(ny,a2d(1,1),trigy(1))
         do j=1,ny
            at(j,i,k)   = a2d(1,j)
            at(j,i+1,k) = a2d(2,j)
         enddo
      enddo
      enddo
c
      call ytox_trans(at,ax,nx2,ny,i2xs,i2xe,i2x_s,i2x_e,
     +         iys,iye,iy_s,iy_e,iz1,iz2,myid,ncpu,np)
c
c     do iy=1,ny
c        call cfftb(nx,ax(1,1,iy),trigx(1))
c     enddo
c
      return
      end
      subroutine yderiv(ay,trigy,yk,nnx,nny)
c
c -------- get multiple y derivatives using fftpack routines
c          use fftpack storage a_0, (a1,b1), (a2,b2), ...,
c          assumes that first wavenumber yk(1) = 0.0
c
c          assumes that wavenumbers are normalized by number of points
c
      real yk(nny), trigy(2*nny+15), ay(nnx,nny)
      real a_trans(nny)
c
c     fn = 1.0/float(nny)
      do ix=1,nnx
         do iy=1,nny
            a_trans(iy) = ay(ix,iy)
         enddo
         call rfftf(nny,a_trans(1),trigy)
         ii = 1
         a_trans(1)   = 0.0
         a_trans(nny) = 0.0
         do iy=2,nny-1,2
            ii            = ii + 1
            temp          = a_trans(iy)
            a_trans(iy)   = -yk(ii)*a_trans(iy+1)
            a_trans(iy+1) = yk(ii)*temp
         enddo
         call rfftb(nny,a_trans(1),trigy)
         do iy=1,nny
            ay(ix,iy) = a_trans(iy)
         enddo
      enddo
c
      return
      end
      subroutine yd_mpi(ay,trigy,yk,
     +           nx,ny,ixs,ixe,ix_s,ix_e,
     +           iys,iye,iy_s,iy_e,iz1,iz2,myid,ncpu,np)
c
c -------- get multiple y derivatives using fftpack routines and mpi
c          use fftpack storage a_0, (a1,b1), (a2,b2), ...,
c          assumes that first wavenumber yk(1) = 0.0
c          wavenumbers are normalized by number of points, ny
c
      real yk(ny), trigy(2*ny+15), ay(nx,iys:iye,iz1:iz2)
      real ayt(ny,ixs:ixe,iz1:iz2)
c
      integer ix_s(0:np-1), ix_e(0:np-1),
     +        iy_s(0:np-1), iy_e(0:np-1)
c
      call xtoy_trans(ay,ayt,nx,ny,ixs,ixe,ix_s,ix_e,
     +         iys,iye,iy_s,iy_e,iz1,iz2,myid,ncpu,np)
c
c     fn = 1.0/float(nny)
      do iz=iz1,iz2
         do ix=ixs,ixe
            call rfftf(ny,ayt(1,ix,iz),trigy)
            ii = 1
            ayt(1,ix,iz)  = 0.0
            ayt(ny,ix,iz) = 0.0
            do iy=2,ny-1,2
               ii              = ii + 1
               temp            = ayt(iy,ix,iz)
               ayt(iy,ix,iz)   = -yk(ii)*ayt(iy+1,ix,iz)
               ayt(iy+1,ix,iz) = yk(ii)*temp
            enddo
            call rfftb(ny,ayt(1,ix,iz),trigy)
         enddo
      enddo
      call ytox_trans(ayt,ay,nx,ny,ixs,ixe,ix_s,ix_e,
     +         iys,iye,iy_s,iy_e,iz1,iz2,myid,ncpu,np)
c
      return
      end
      function rlim(d1,d2,d3)
c
c ------------- Cees's kappa=1/3 scheme
c
      r = (d1-d2+1.e-100)/(d2-d3-1.e-100)
      rlim = (d2-d3)*amax1(0.,amin1(r,amin1(1./6.+1./3.*r,1.)))
c
c ------------- Cees's kappa=-1 scheme
c
c     r = (d1-d2+1.e-100)/(d2-d3-1.e-100)
c     rlim = (d2-d3)*amin1(abs(r),0.5)
c
c ------------- first order upwind
c
c     rlim = 0.0
c
c ------------- QUICK scheme
c
c     rlim = -0.25*d2 - 0.125*d3 + 0.375*d1
c
      return
      end
      function ran1(idum)
c
c ----------- stolen from numerical recipes,p. 271
c
      integer idum, ia, im, iq, ir, ntab, ndiv
      real ran1, am, eps, rnmx
      parameter (ia=16807,im=2147483647,am=1.0/im,iq=127773,ir=2836.0,
     +           ntab=32,ndiv=1+(im-1)/ntab,eps=1.2e-07,rnmx=1.0-eps)
      integer j, k, iv(ntab), iy
      save iv, iy
      data iv /ntab*0/, iy /0/
      if(idum .le. 0 .or. iy .eq. 0) then
         idum = max(-idum,1)
         do j=ntab+8,1,-1
            k = idum/iq
            idum = ia*(idum - k*iq) - ir*k
            if(idum .lt. 0) idum = idum + im
            if(j .le. ntab) iv(j) = idum
         enddo
         iy = iv(1)
      endif
      k     = idum/iq
      idum  = ia*(idum - k*iq) - ir*k
      if(idum .lt. 0) idum = idum + im
      j     = 1 + iy/ndiv
      iy    = iv(j)
      iv(j) = idum
      ran1  = min(am*iy, rnmx)
c
      return
      end
      function ranf()
      data inc /1/
      save inc, ix, ia, m, fm
      if(inc.eq.1) then
        inc = 2
        m = 2**20
        fm = float(m)
        ix = 566387
        ia = 2**10 + 3
      endif
      ix = mod(ia*ix,m)
      fx = float(ix)
      ranf = fx/fm
      return
      end
      subroutine stokesv
c
c ----------- get stokes drift velocity for assumed wavelength stokesw
c             and wave amplitude stokesa. Changed sign for z.
c
c
      use pars
      use con_data
      use con_stats
      include 'mpif.h'
c
      if(iocean .eq. 1) then
c
c ----------- compute stokes velocity for ocean pbls
c
c        stokesw = pi2/20.0
         stokesw = pi2/76.5
c        ak      = 0.04
         ak      = 0.00
c        stokesa = 1.0
         stokesa = ak/stokesw
         sigma = sqrt(abs(grav)*stokesw)
         stokess = sigma*stokesw*stokesa**2
         do iz=1,nnzp1
            stokes(iz) = stokess*exp(2.0*stokesw*zz(iz))
         enddo
         if(l_root) then
            write(6,6000) (iz,zz(iz),stokes(iz),iz=1,nnz)
 6000       format(' iz ',10x,' zz',10x,' stokes',/,(1x,i3,2e12.4))
         endif
c
      else
c
c ----------------- set stokes velocity = 0 for atmos. pbls 
c
         do iz=1,nnzp1
            stokes(iz) = 0.0
         enddo
         stokess = 0.0
         udrift = 0.0
         vdrift = 0.0
      endif
c
      return
      end
      subroutine busngr(zeta,phim,phis,psim,psis)
c
c ---- Businger's version of similarity theory
c
      data pih /1.57079633/
      save pih
c
      if(zeta .lt. 0.) then
         x=(1.0 - 15.0*zeta)**0.25
         phim = 1.0/x
         psim = 2.0*alog((1.0+x)/2.0) + alog((1.0+x*x)/2.0) - 
     +          2.0*atan(x)+pih
         if(psim.gt.2.0)psim=2.0
         y = sqrt(1.0-9.0*zeta)
         phis = 0.74/y
         psis = alog((1.0+y)/2.0)*2.0
      else if(zeta .gt. 0) then
         phim = 1.0 + 4.7*zeta
         phis = 0.74 + 4.7*zeta
         psim = -4.7*zeta
         psis = -4.7*zeta
      else
         phim = 1.0
         phis = 0.74
         psim = 0.0
         psis = 0.0
      endif
      return
      end
      subroutine fzol(zeta,phim,phis,psim,psis)
c        estimate the stability functions for momentum, m
c                                         and scalars,  c
c        from input of the stability parameter zeta = z/L

      data c1/5./
      data a3,b3,a4,b4/1.258,8.382,-28.862,98.9545/
      data zetam,zetas/-0.2,-1.0/
      save c1, a3, b3, a4, b4, zetam, zetas
c
      psimu(Y)  = 1.571 + 2.0*(alog(0.5*(1.0 + Y)) - atan(Y)) + 
     +            alog(0.5 + 0.5*Y**2)
      psisu(Y)  = 2.0*alog(0.5 + 0.5*Y)
      psicu(Y,G)= (1.0 - G)*alog(abs(Y - 1.0))
     +          + 0.5*(G + 2.0)*alog(abs(Y**2 + Y + 1.0))
     +          - (2.0*G + 1.0) / sqrt(3.0) * 
     +            atan((Y + 0.5)*2.0/sqrt(3.0))
      Xm(zol)   = (1.0 - 16.0*zol)**0.25
      Xs(zol)   = sqrt(1.0 - 16.0*zol)
      Xc(zol,f) =  abs(1.0 - f*zol)**(4.0/3.0)/(1.0 - f*zol)
c
      if(zeta.ge.0.0)       then
c                                          STABLE
      if(zeta.le.1.0) then
        phim = 1.0 + c1 * zeta
        psim = - c1 * zeta
        phis = phim
        psis = psim
                      else
c                                   use limiting form
        phim = c1 + zeta
        psim = (1.0 - c1)*(1.0 + alog(zeta) ) - zeta
        phis = phim
        psis = psim
                      endif

                            else
c                                         UNSTABLE
c                                                  momentum         
       if(zeta.ge.zetam) then
         phim = 1.0 / Xm(zeta)
         psim = psimu(Xm(zeta))
                         else
c                            use convective limit for momentum
         X = (1.0 - b3/a3 * zeta)**(1.0/3.0)

         fm = a3**(-1.0/3.0)
         phim = fm / Xc(zeta,b3/a3) 
         psim = psimu(Xm(zetam))
     *        + psicu(Xc(zeta,b3/a3),fm)
     *        - psicu(Xc(zetam,b3/a3),fm)
                         endif
      
c                                         UNSTABLE scalars
       if(zeta.ge.zetas) then
         phis = 1.0/Xs(zeta)
         psis = psisu(Xs(zeta))
                         else
c                              use convective limit for scalars
         fs =   abs(a4)**(-1.0/3.0)*abs(a4)/a4
         phis = (a4 - b4*zeta)**(-1.0/3.0)
         psis = psisu(Xs(zetas))
     *        + psicu(Xc(zeta,b4/a4),fs)
     *        - psicu(Xc(zetas,b4/a4),fs)
                         endif
               
                            endif
       return
       end
      subroutine suft(it)
c
c ---------- iterate for zeta = z/L using bisection method
c            either businger or large functions can be specified
c
c            isfc = 0, specified surface heat flux
c                 = 1, specified surface temperature
c
      use pars
      use fields
      use con_data
      use con_stats
      real buf(3+nscl)
      include 'mpif.h'
      integer istatus(mpi_status_size)
c
      parameter (iter_mo = 30, zeta_min = -6.0, zeta_max = 3.0)
c
c ---------- limiting value for wind
c
      ufree = 0.07*(abs(batag*qstar(1)*dzw(1)))**(1./3.)
c
c ---- save old utau
c
      utausv = utau
      utau2  = utau*utau
c
      iz   = 1
      izp1 = iz + 1
      izm1 = iz - 1
c
      buf(1)  = 0.0
      buf(2)  = 0.0
      buf(3)  = 0.0
      tol     = 0.01
      do iy=iys,iye
      do ix=1,nnx
         buf(1) = buf(1) + u(ix,iy,iz)
         buf(2) = buf(2) + v(ix,iy,iz)
         wind(ix,iy) = sqrt((u(ix,iy,iz)+ugal)**2
     +                    +v(ix,iy,iz)*v(ix,iy,iz))
         buf(3) = buf(3) + wind(ix,iy)
      enddo
      enddo
      do iscl=1,nscl
         buf(3+iscl) = 0.0
         do iy=iys,iye
         do ix=1,nnx
            buf(3+iscl) = buf(3+iscl) + t(ix,iy,iscl,iz)
         enddo
         enddo
      enddo
c
c -------- get x-y slab sums
c
      call mpi_sum_xy(buf,myid,iss,ise,(3+nscl))
      u1xy  = buf(1)*fnxy + ugal
      v1xy  = buf(2)*fnxy
      windm = buf(3)*fnxy
      do iscl=1,nscl
         t1xy(iscl) = buf(3+iscl)*fnxy
      enddo
      vsfc  = sqrt(u1xy*u1xy+v1xy*v1xy)
      windm = amax1(windm,ufree)
      vsfc  = amax1(vsfc,ufree)
c
c ---------- limits for zeta
c
      zeta_mn = zeta_min
      zeta_mx = zeta_max
      if(isfc .eq. 0) then
         f_con = z1*batag*vk*qstar(1)/((windm*vk)**3)
      else
         d_theta = vk74in*(tsfcc(1) - t1xy(1))
         f_con   = z1*batag*vk*d_theta/((windm*vk)**2)
      endif
c
c --------- iteration for zeta
c
      do iter=1,iter_mo
         zeta_a = 0.5*(zeta_mn + zeta_mx)
         if(ismlt .eq. 1) then
             call busngr(zeta_a,phim,phis,psim,psis)
         else
             call fzol(zeta_a,phim,phis,psim,psis)
         endif
         u_fac = (zody - psim)
         if(isfc .eq. 0) then
            f_new =  zeta_a + f_con*u_fac**3
         else
            t_fac = 1.0/(zody - psis)
            f_new =  zeta_a + f_con*u_fac*u_fac*t_fac
         endif
         if(f_new .lt. 0.0) then
            zeta_mn = zeta_a
         else
            zeta_mx = zeta_a
         endif
c
c ----------- iteration details
c
c        utau      = windm*vk/(zody-psim)
c        write(nprt,1000) iter, zeta_a, utau, phim, psim
c1000    format(' 1000 iter = ',i5,' zeta = ',e15.6,' u_* = ',e15.6,
c    +          ' phim = ',e15.6,' psim = ',e15.6)
      enddo
c
c --------- check if neutral surface layer
c
      if (ibuoy.eq.0 .or. qstar(1) .eq. 0.) then
          amonin    = 1000.
          zeta      = 0.0
          utau      = windm*vk/zody
          thstar(1) = 0.0
          t10xy(1)  = 0.0
          tsfcc(1)  = t1xy(1)
      else
         utau = windm*vk/(zody-psim)
         dnom = (zody-psis)*vk74in
         if(isfc .eq. 0) then
            thstar(1) = -qstar(1)/utau
            tsfcc(1)  = t1xy(1)-thstar(1)*dnom
            t10xy(1)  = thstar(1)*dnom
         else
            thstar(1) = (t1xy(1) - tsfcc(1))/dnom
            t10xy(1)  = thstar(1)*dnom
            qstar(1)  = -utau*thstar(1)
         endif
         amonin = -utau**3/(batagk*qstar(1))
         zeta   = z1/amonin
      endif
c
c ------- surface details, for debug
c
c     write(nprt,2000) windm, utau, qstar(1), tsfcc(1), amonin, zeta,
c    +              z1, batag, vk, batagk, zo
c2000 format(' 2000 suft ',/,
c    +       '    windm = ',e15.6,' utau = ',e15.6,' qstar = ',e15.6,/,
c    +       '    tsfcc = ',e15.6,' MO L = ',e15.6,' z1/L = ',e15.6,/,
c    +       '    z1 = ',e15.6,' batag = ',e15.6,' vk = ',e15.6,/,
c    +       '    batagk = ',e15.6,' zo = ',e15.6)
c
      if (utau.gt.10.0) then
         write(6,9000)
         write(6,9200) utau,windm
         go to 9999
      endif
      if (t10xy(1).gt.0. .and. qstar(1) .gt. 0.) then
         write(6,9000)
         write(6,9300) u1xy,v1xy,t1xy(1),
     +                 tsfcc(1),amonin,utau,it
         go to 9999
      endif
c
c ---------- examples of two other scalars
c
c     c
c     c **** get flux of b scalar, specified surface value
c     c
c           dnom      = (zody-psis)*vk74in
c           thstar(2) = (t1xy(2)-tsfcc(2))/dnom
c           qstar(2)  = -thstar(2)*utau
c           t10xy(2)  = thstar(2)*dnom
c           aut3m(2)  =  qstar(2)
c
c **** get surface value of c scalar, specified surface flux
c
c     dnom      = (zody-psis)*vk74in
c     thstar(2) = -qstar(2)/utau
c     tsfcc(2)  = t1xy(2) - dnom*thstar(2)
c     t10xy(2)  = thstar(2)*dnom
c     aut3m(2)  = qstar(2)
c
      zol = zeta
      hol = zol*zi/z1
c
c ---- note roundoff problem in angles if close to multiples of pi
c
      tep = u1xy/vsfc
      if(tep.gt.1.)  tep = 1.0
      if(tep.lt.-1.) tep = -1.0
      thta      = acos(tep)
      utau2     = utau*utau
      au13m     = -utau2*cos(thta)
      au23m     = -utau2*sin(thta)*sign(1.,v1xy)
      aut3m(1)  =  qstar(1)
c
      return
c
c -------- iteration did not converge
c
 9999 continue
 9000 format(' Trouble in SR. suft')
 9200 format(' Stop because utau = ',e15.6,' windm = ',e15.6)
 9300 format(' ** CHECK SFC U = ',e15.6,' V=',e15.6,' T,TS = ',2e15.6,
     +       ' L =',e15.6,' U_* = ',e15.6,' AT IT = ',i5)
      call mpi_abort(mpi_comm_world,icode,ierr)
      end
      subroutine sufto(it)
c
      use pars
      use fields
      use con_data
      use con_stats
      real buf(3+nscl)
c
c ------- version of similarity theory adpated for ocean flows
c      option to use businger or large version of similarity theory
c
      iz    = 1
      izm1  = iz - 1
      izp1  = iz + 1
      z1_a  = abs(z1)
      buf(1)  = 0.0
      buf(2)  = 0.0
      buf(3)  = 0.0
      tol     = 0.01
      do iy=iys,iye
      do ix=1,nnx
         buf(1) = buf(1) + u(ix,iy,iz)
         buf(2) = buf(2) + v(ix,iy,iz)
         wind(ix,iy) = sqrt((u(ix,iy,iz)+ugal)**2
     +                    +v(ix,iy,iz)*v(ix,iy,iz))
         buf(3) = buf(3) + wind(ix,iy)
      enddo
      enddo
      do iscl=1,nscl
         buf(3+iscl) = 0.0
         do iy=iys,iye
         do ix=1,nnx
            buf(3+iscl) = buf(3+iscl) + t(ix,iy,iscl,iz)
         enddo
         enddo
      enddo
c
c -------- get x-y slab sums
c
      call mpi_sum_xy(buf,myid,iss,ise,(3+nscl))
      u1xy  = buf(1)*fnxy + ugal
      v1xy  = buf(2)*fnxy
      windm = buf(3)*fnxy
      do iscl=1,nscl
         t1xy(iscl) = buf(3+iscl)*fnxy
      enddo
      vsfc  = sqrt(u1xy*u1xy+v1xy*v1xy)
      windm = amax1(windm,ufree)
      vsfc  = amax1(vsfc,ufree)
c
      t10xy(1)=-qstar(1)/utau*zody*vk74in
c
c ---- check for temperature boundary condition
c
      if(isfc .eq. 0 ) then
         tsfcc(1)=t1xy(1)-t10xy(1)
      endif
c     vsfc=sqrt(u1xy*u1xy+v1xy*v1xy)
c     if(windm.le.0.01)windm=0.01
c     if(vsfc .le.0.01)vsfc =0.01
c
c ----------- input surface wind stress (tau = 0.0184n/m*m)
c             density rho = 1000kg/m^3
c          
c     utau = 4.29e-03
c     utau = 6.10e-03
      utau = 7.00e-03
c
c **** save old utau
      utausv = utau
      utau2  = utau*utau
      if (ibuoy.eq.0 .or. qstar(1) .eq. 0.) then
          amonin    = 1000.
          zeta      = 0.
          thstar(1) = 0.0
          t10xy(1)  = 0.0
      else
          amonin = -utau2*utau/(batagk*qstar(1))
          zeta   = z1_a/amonin
      endif
      if (t10xy(1).lt.0. .and. qstar(1) .lt. 0.) then
         write(6,1234)u1xy,v1xy,t1xy(1),tsfcc(1),amonin,utau,it
 1234    format(' ** check sfc u=',e12.3,' v=',e12.3,' t,ts=',2f10.3,
     +     ' l=',e12.3,' u*=',e12.3,' at it=',i5)
         go to 9999
      endif
c
c -------- for stable,neutral and unstable pbl get drift velocity
c
      if(ismlt .eq. 1) then
          call busngr(zeta,phim,phis,psim,psis)
      else
          call fzol(zeta,phim,phis,psim,psis)
      endif
      udrift = windm + stokes(1) - stokess + utau*(zody-psim)*vkin
      vdrift = 0.0
      dnom      = (zody-psis)*vk74in
      if (isfc.eq.1) then
         thstar(1) = (t1xy(1) - tsfcc(1))/dnom
         t10xy(1)  = thstar(1)*dnom
         qstar(1)  = - utau*thstar(1)
      else
         thstar(1)  = -qstar(1)/utau
         tsfcc(1)   = t1xy(1)-thstar(1)*dnom
         t10xy(1)   = thstar(1)*dnom
      endif
      zol = zeta
      hol = zol*zi/z1
c
c ---------- examples of two other scalars
c
c     c
c     c **** get flux of b scalar, specified surface value
c     c
c           dnom      = (zody-psis)*vk74in
c           thstar(2) = (t1xy(2)-tsfcc(2))/dnom
c           qstar(2)  = -thstar(2)*utau
c           t10xy(2)  = thstar(2)*dnom
c           aut3m(2)  =  qstar(2)
c     c
c     c **** get surface value of c scalar, specified surface flux
c     c
c           dnom      = (zody-psis)*vk74in
c           thstar(3) = -qstar(3)/utau
c           tsfcc(3)  = t1xy(3) - dnom*thstar(3)
c           t10xy(3)  = thstar(3)*dnom
c           aut3m(3)  = qstar(3)
c
c **** note roundoff problem in angles are close to multiples of pi
c     tep=u1xy/vsfc
c     if(tep.gt.1.)tep=1.
c     if(tep.lt.-1.)tep=-1.
c     thta=acos(tep)
      utau2 = utau*utau
c     au13m = -utau2*cos(thta)
c     au23m = -utau2*sin(thta)*sign(1.,v1xy)
      au13m = utau2
      au23m = 0.0
      aut3m(1)= qstar(1)
c
      return
c
c --------- trouble in sl routine
c
 9999 continue
c
      write(nprt,9000)
 9000 format(' Trouble in SR. sufto')
      call mpi_finalize(ierr)
      stop
      end
      subroutine suft2(u_level1,it)
c
      use pars
      use fields
      use con_data
      use con_stats
c
      real u_level1(nnx,iys:iye,2+nscl)
c
c     u_level1(.,.,1) = u
c     u_level1(.,.,2) = v
c     u_level1(.,.,3) = theta
c     u_level1(.,.,4) = more scalars
c
      tol = 0.01
      ufree=0.07*(abs(batag*qstar(1)*dzw(1)))**(1./3.)
      zeta_mn = -6.0
      zeta_mn_i = 1.0/zeta_mn
      iz   = 1
c     izm1 = iz - 1
c     izp1 = iz + 1
c
c      write(nprt,3131) myid, utau, zody, vk74in, batagk,
c    +               u_level1(jxs,1,3), u_level1(jxe,1,3),
c    +               u_level1(jxs,1,1), u_level1(jxe,1,1),
c    +               u_level1(jxs,1,2), u_level1(jxe,1,2)
c3131  format(' in suft2 myid = ',i4,/,
c    +        ' utau = ',e15.6,' zody = ',e15.6,/,
c    +        ' vk74in = ',e15.6,' batagk = ',e15.6,/,
c    +        ' t(jxs) = ',e15.6,' t(jxe) = ',e15.6,/,
c    +        ' u(jxs) = ',e15.6,' u(jxe) = ',e15.6,/,
c    +        ' v(jxs) = ',e15.6,' v(jxe) = ',e15.6)
c
      do iy=iys,iye
      do ix=mxs,mxe
c
c ----------------- first guess for utau
c
      utau = .001
c
      t10xy(1) = -qstar(1)/utau*zody*vk74in
      tsfcc(1) = u_level1(ix,iy,3) - t10xy(1)
      vsfc2    = u_level1(ix,iy,1)**2 + u_level1(ix,iy,2)**2
      vsfc     = sqrt(vsfc2)
      windm    = ufree+vsfc
      utausv   = utau
      utau2    = utau*utau
      amonin   = -utau2*utau/(batagk*qstar(1))
      if(amonin.eq.0.) then
            write(6,5050) ix,iy,it,utau,amonin
 5050       format(' 5050, sr. suft2, trouble at ',/,
     +             ' ix = ',i6,'iy = ',i6,' it = ',i6,' utau = ',e15.6,
     +             ' amonin = ',e15.6)
            stop
      endif
c
c ---- for unstable, free convection pbl
c
      iter = 0
 100  continue
c
c ----------------- limit the min (-l/z) change to accmmodate stable flow
c
      zeta_i = amin1(amonin/z1,zeta_mn_i)
      zeta_a = 1.0/zeta_i
c
      if(ismlt .eq. 1) then
          call busngr(zeta_a,phim,phis,psim,psis)
      else
          call fzol(zeta_a,phim,phis,psim,psis)
      endif
      utau     = windm*vk/(zody-psim)
      thstar(1)=-qstar(1)/utau
      amonold  = amonin
      amonin   = utau*utau/(batagk*thstar(1))
      diff     = abs(amonin - amonold)
c      write(nprt,5656)iter,psim,utau,zeta,amonin,dmonin,diff
c 5656 format(' iter=',i4,' phm=',e10.3,' utau=',e10.3,
c     1      ' zeta=',e10.3,' l=',e10.3,' diff = ',e12.4)
      iter = iter+1
      if(iter.gt.10)go to 1000
      if(diff.gt.abs(tol*amonin)) go to 100
 1000 continue
c
 2000 continue
c
      if (utau.gt.10.) then
         write(6,232)utau,windm
  232    format(' stop because utau=',e15.6,' windm=',e15.6)
         stop 9999
      endif
      t10xy(1) = -qstar(1)/utau*vk74in*(zody-psis)
      t_grnd(ix,iy,1) = u_level1(ix,iy,3) - t10xy(1)
c
      zol = zeta_a
      hol = zol*zi/z1
      tep = u_level1(ix,iy,1)/windm
      if(tep.gt.1.)  tep = 1.0
      if(tep.lt.-1.) tep = -1.0
      thta  = acos(tep)
      utau2 = utau*utau
c     au13m=-utau2*cos(thta)
c     au23m=-utau2*sin(thta)*sign(1.,u_level1(ix,iy,2))
c     aut3m(1)= qstar(1)
c
      tau13m(ix,iy)   = -utau2*cos(thta)
      tau23m(ix,iy)   = -utau2*sin(thta)*sign(1.,u_level1(ix,iy,2))
      taut3m(ix,iy,1) = qstar(1)
c
c **** get surface value of c scalar, specified surface flux
c
c     dnom      = (zody-psis)*vk74in
c     thstar(2) = -qstar(2)/utau
c     tsfcc(2)  = u_level1(ix,iy,4) - dnom*thstar(2)
c     t_grnd(ix,iy,2)  = u_level1(ix,iy,4) - dnom*thstar(2)
c     t10xy(2)  = thstar(2)*dnom
c     taut3m(ix,iy,2)  = qstar(2)
c
c
c ------- end of x-y loops
c
      enddo
      enddo
c
      return
      end
      subroutine init
c
      use pars
      use fields
      use con_data
      use con_stats
c
      pi   = 4.0*atan(1.0)
      pi2  = 2.0*pi
      bfac = 1.0
      if(ibuoy.eq.0) bfac = 0.
c
c -------------------- case specific data
c
      if(iocean .eq. 1) then
         t00b    = 5000.0
         cp      = 4.20e03
         gcp     = grav/cp
         batag   = bfac*grav/t00b
         fcor_h  = 0.0
         vgcont  = 0.
c        wtsfc(1)=0.00
c        wtsfc(1)=4.96e-07
         wtsfc(1)=1.190476e-06
         qstar(1)=wtsfc(1)
c        dtdzf(1)=0.000
         dtdzf(1)=0.2548
         dtjump  = 0.
         divgls  = 0.
         zo      = 0.0001
         zi      = -5.
c        izi     = (55*nnz)/100
c        izi     = nnz
         izi     = 55
         xl      = 50.
         yl      = 50.
         zl      = -20.
c
c ---------- if stretched grid specify location of first point
c
      else
         cp      = 1.e3
         gcp     = grav/cp
         batag   = bfac*grav/t00
         fcor_h  = 0.0


c
c ----------- wind tunnel simulation
c
c
         wtsfc(1)=qstar(1)
         wtsfc(2)=qstar(2)
c
         dtdzf(1)=0.000
c        dtdzf(2)=0.000
c
c 
c ---------- 
c
         dtjump  = 0.0
         divgls  = 0.0

c
c        izi     = int(float(nnz)*zi/zl)
c        izi     = (60*nnz)/100
         izi     = 102
c
c ------------ check type of grid generation, adjust box size
c              so that you get the desired size in physical space
c
         if(iz_space .eq. 4) then
           zl = zl + zw1
         endif
      endif
c
      time     = 0.0
      t_stage  = 0.0
      t_stage2 = 0.0
      t_zero   = 0.0
c
c ---------- set mesh stationary flag
c
      imesh = 0
c 
c ---------- outermost coarse grid  indicies are bounds of grid
c
      izlow = 1
      izup  = nnz
      dz    = zl/nnz
      dzg   = abs(dz)
      if(l_root) write(6,4040) zl,nnz,dzg
c
c --------------- generate z grids for particular mesh from
c                 iz = 0,1,...,nnz+1; this allows indexing
c                 to array elements z(0), etc.
c
      zwstrt = 0.0
c
c ------------ if uniform vertical spacing then
c
      if(iz_space .eq. 0) then
c
c ------------ build z grid for w points
c
         do iz=0,nnz+1
            z(iz) = dz*float(iz) + zwstrt
         enddo
      else
        z_gues = 1.1
        !call vgrid(zw1,zi,zl,z_gues,nnz,z(0),l_root,l_debug)
        call vgrid_channel(zw1,zi,zl,nnz,z(0),l_root,l_debug)
      endif
c
      call get_dz
c
      if(l_root) then
         write(6,8002) zwstrt
         write(6,8003) (iz,z(iz),zz(iz),iz=0,nnz+1)
      endif
c
      nnzm1 = nnz-1
      dx    = xl/nnx
      dy    = yl/nny
      fnxy  = 1./float(nxy)
      dzdz  = dzw(1)*dzw(1)
      z1    = zz(1)
c
      c23  = 2.0/3.0
      dsl  = (dx*1.5*dy*1.5*abs(dzw(1)))**(1./3.)
      dslg = dsl
      cs   = 0.2
c
      vk     = 0.4
      batagk = batag*vk
      vkin   = 1./vk
      ttmean = 0.
      zody   = alog(abs(z1/zo))
      write(nprt, 9901) z1,zo,zody
 9901 format(' 9901 z1 = ',e15.6,' zo = ',e15.6,/,
     +       ' zody = ',e15.6)
      zodyin = 1./zody
      wstar  = abs(batag*zi*wtsfc(1))**(1./3.)
      if(ismlt .eq. 1) then
c
c ---- set constants for businger similarity functions
c
         vk74   = vk*0.74
         vk74in = 0.74/vk
         zody74 = zody*0.74
      else 
c
c ---- set constants for large similarity functions
c
        vk74    = vk
        vk74in  = 1.0/vk
        zody74  = zody
      endif
      ugal   = 0.0
c     ugal   = ugcont*0.5
c     ugcont = ugcont - ugal
      cdbtm  = vk*vk/zody/zody
      if(iocean .eq. 1) then
c ----------- set surface friction velocity here and in sr. sufto
c        utau = 4.29e-03
         utau = 7.00e-03
      else
         ufree = 0.07*(abs(batag*qstar(1)*dzw(1)))**(1./3.)
c
c ---- note : new estimate for utau !!!
c
         utau  = vk*(ufree+ugcont)/zody
c        utau  = vk*(ufree)/zody
      endif
      utau2    = utau*utau
      if(ibuoy .eq. 0 .or. qstar(1) .eq. 0.) then
        amonin = 1000.0
      else
        amonin = -utau2*utau/(batagk*qstar(1))
      endif
      hol   = abs(zi)/amonin
      zol   = abs(z1)/amonin
      uwsfc = -utau*utau
      vwsfc = -utau*utau
c
c ------- make sure tsfcc is gt than t00 for both isfc=0 or 1
c
      if(l_root) then
         write(6,80)
         write(6,2)wtsfc(1),utau,amonin,dtdzf(1),zody,zo
     +         ,cdbtm,ugcont
      endif
c
      if(l_debug) then
         write(nprt,80)
         write(nprt,2)wtsfc(1),utau,amonin,dtdzf(1),zody,zo
     +         ,cdbtm,ugcont
      endif
c
      return
c ------------------------
   2  format(10x,' WT =',e12.4,',  U* =',e12.4,',  L =',e12.4,/,
     +       10x,' DTDZ FREE =',e12.4,',  ZODY=',e12.4,/,10x,
     +       ' ZO(BTM) =',e12.4,',  CDBTM=',e12.4,
     +       ',  UG = ',e12.4)
  80  format(///,' ***** SCRATCH RUN ***** ',//)
 4040 format(' zl = ',e15.6,' nnz = ',i5,' dzg = ',e15.6)
 4043 format(' znest = ',e15.6,' nnz = ',i5,' dzg = ',e15.6)
 8002 format(' zwstrt = ',e12.4)
 8003 format(' iz ',5x,' zw',5x,' zu ',5x,/,(i3,2e12.4))
      end
      subroutine cgrid(zl,nnz,z)
c
c --------- uniform vertical grid
c
      real z(0:nnz+1)
c
      ddz = zl/float(nnz)
      do k=1,nnz
         z(k) = float(k)*ddz
      enddo
      z(nnz) = zl
      z(0)   = 0.0
      z(nnz+1) = z(nnz) + (z(nnz) - z(nnz-1))
c
      return
      end
      subroutine surf_setup_gabls
c
c ------- set basic parameters of gabls surface and evaluate pieces that are
c         independent of time
c
      use pars
      use fields
      use fftwk
      use con_data
      use con_stats
      use wavy_pars
c
c --------- allocate surface arrays
c
      allocate(eta0(2,nnx,nny))
c
      wave = xl/4.0
      fac  = pi2/wave
      ak   = 0.3
      ampl = ak*wave/pi2
      dx   = xl/float(nnx)
      do j=iys,iye
      do i=1,nnx
         eta0(1,i,j)  = ampl*cos(fac*dx*float(i-1))
         eta0(2,i,j)  = 0.0
         u_orbit(i,j) = 0.0
         v_orbit(i,j) = 0.0
      enddo
      enddo
c
      return
      end
      subroutine get_surf_gabls(t_bndy)
c
c ------- generate new gabls surface at t = t_bndy. smoothly add or subtract
c         bumps by varying the amplitude
c
      use pars
      use fields
      use fftwk
      use con_data
      use con_stats
      use wavy_pars
c
      t1_st  = 100.0
      t1_en  = 400.0
      b_rate = 1.0/(t1_en - t1_st)
c
      if(t_bndy .lt. t1_st) then
         ampl_fac  = 1.0
         ampl_rate = 0.0
      elseif(t_bndy .ge. t1_st .and. t_bndy .lt. t1_en) then
         ampl_fac  = amax1((1.0 - b_rate*(t_bndy - t1_st)),0.0)
         ampl_rate = -b_rate
      elseif(t_bndy .ge. t1_en) then
         ampl_fac  = 0.0
         ampl_rate = 0.0
      endif
c
      do j=iys,iye
      do i=1,nnx
         bndy(i,j)    = ampl_fac*eta0(1,i,j)
         hdot(i,j)    = ampl_rate*eta0(1,i,j)
         w_orbit(i,j) = hdot(i,j)
      enddo
      enddo
c
      return
      end
      subroutine surf_setup
c
c ------- set basic parameters of surface and evaluate pieces that are
c         independent of time
c
      use pars
      use fields
      use fftwk
      use con_data
      use con_stats
      use wavy_pars
c
      real amp(nnx,nny), ran_amp(2,nnx,nny)
c
c --------- allocate surface arrays
c
      allocate(omega(nnx,nny), 
     +         eta0(2,nnx,nny),
     +         s_wrk(2,nnx,iys:iye),
     +         v_wrk(2,nnx,iys:iye),
     +         etax(nnxp2,iys:iye),
     +         etay(nnxp2,iys:iye),
     +         eta_wrk(nny,i2xs:i2xe))
c
      u10    = 15.0
      age    = 1.2
      angle  = atan(0.0)
      wind_x = cos(angle)
      wind_y = sin(angle)
      dkx    = pi2/xl
      dky    = pi2/yl
c
c ------------- generate an array of random phases or amplitudes
c               and radial frequencies
c
      do j=1,nny
      do i=1,nnx
         omega(i,j) = sqrt(sqrt(xkn(i)**2 + ykn(j)**2)*grav)
      enddo
      enddo
      idum = -1
      if(i_ranp .eq. 0) then
         do j=1,nny
         do i=1,nnx
            aa_phase       = pi2*(ran1(idum) - 0.5)
            ran_amp(1,i,j) = cos(aa_phase)
            ran_amp(2,i,j) = sin(aa_phase)
         enddo
         enddo
      else
c
c ------- normalize amplitudes so that their squared sum = 1
c
         fac = 1.0/sqrt(2.0)
         do j=1,nny
         do i=1,nnx
            ran_amp(1,i,j) =  gasdev(idum)*fac
            ran_amp(2,i,j) =  gasdev(idum)*fac
         enddo
         enddo
         sum1 = 0.0
         sum2 = 0.0
         do j=1,nny
         do i=1,nnx
            sum1 = sum1 + ran_amp(1,i,j)
            sum2 = sum2 + ran_amp(2,i,j)
         enddo
         enddo
         sum1 = sum1*fnxy
         sum2 = sum2*fnxy
         var1 = 0.0
         var2 = 0.0
         do j=1,nny
         do i=1,nnx
            var1 = var1 + (ran_amp(1,i,j) - sum1)**2
            var2 = var2 + (ran_amp(2,i,j) - sum2)**2
         enddo
         enddo
         var1 = var1*fnxy
         var2 = var2*fnxy
         write(nprt,1345) sum1,var1, sum2,var2
 1345    format(' 1345 get surf:',/,
     +          '      sum1 = ',e15.6,' var1 = ',e15.6,/,
     +          '      sum2 = ',e15.6,' var2 = ',e15.6)
      endif
c
      sum1  = 0.0
      sum2  = 0.0
      p_max = 0.0
      p_min = 0.0
      do j=1,nny
      do i=1,nnx
         sum1 = sum1 + ran_amp(1,i,j)
         sum2 = sum2 + ran_amp(2,i,j)
         if(ran_amp(1,i,j) .gt. p_max) p_max = ran_amp(1,i,j)
         if(ran_amp(1,i,j) .lt. p_min) p_max = ran_amp(1,i,j)
      enddo
      enddo
      sum1 = sum1*fnxy
      sum2 = sum2*fnxy
      write(nprt,5000) p_max, p_min, sum1, sum2
 5000 format(' phase max = ',e15.6,/,
     +       ' phase min = ',e15.6,/,
     +       ' sum r     = ',e15.6,/,
     +       ' sum c     = ',e15.6)
c
c --------- first construct the pieces independent of t
c
      fac_a = sqrt(2.0)
      if(i_pm .eq. 1) then
c
c ---------- pierson-moskowitz spectrum
c
         call pm64(dkx,dky,xkn,ykn,nnx,nny,u10,amp)
c
      else
c
c ---------- donelan spectrum
c
         call donelan(dkx,dky,xkn,ykn,nnx,nny,u10,age,angle,amp)
c
      endif
c
c ------- use a gaussian filter to smooth the wave shape
c
      fac     = 3.0
      f_width = sqrt(fac*dx*fac*dy)
      cons    = f_width*f_width/24.0
      sum_spec = 0.0
      do j=1,nny
      do i=1,nnx
         gauss       = exp(-cons*(xkn(i)**2 + ykn(j)**2))
         amp_root    = sqrt(amp(i,j)*dkx*dky)*gauss
         eta0(1,i,j) = fac_a*amp_root*ran_amp(1,i,j)
         eta0(2,i,j) = fac_a*amp_root*ran_amp(2,i,j)
         sum_spec    = sum_spec + amp(i,j)*dkx*dky
      enddo
      enddo
c
      write(6,8001) sum_spec
 8001 format(' 8001 sum_spec = ',e15.6)
c
c --------- build coefficients at t = 0
c
      do j=1,nny
         eta0(1,ncx,j) = 0.0
         eta0(2,ncx,j) = 0.0
      enddo
      do i=1,nnx
         eta0(1,i,ncy) = 0.0
         eta0(2,i,ncy) = 0.0
      enddo
c
c --------- make surface smooth
c
c     mx = nnx/4
c     mx = 3*(nnx/8)
c     my = 3*(nny/8)
c
c     mcx   = mx/2 + 1
c
      m_cut_x = nnx/3
      m_cut_y = nny/3
c
      i_cut_l = m_cut_x
      i_cut_u = nnx + 2 - i_cut_l
      do j=1,nny
      do i=i_cut_l,i_cut_u
         eta0(1,i,j) = 0.0
         eta0(2,i,j) = 0.0
      enddo
      enddo
      j_cut_l = m_cut_y
      j_cut_u = nny + 2 - j_cut_l
      do j=j_cut_l,j_cut_u
      do i=1,nnx
         eta0(1,i,j) = 0.0
         eta0(2,i,j) = 0.0
      enddo
      enddo
c
c ------------ set amplitudes = 0 for iflat case
c
c     do j=1,nny
c     do i=1,nnx
c        eta0(1,i,j) = 0.0
c        eta0(2,i,j) = 0.0
c     enddo
c     enddo
c
      return
      end
      subroutine surf_setup_tank
c
c ------- basic parameters of wavy surface from lab experiments
c
      use pars
      use fields
      use fftwk
      use con_data
      use con_stats
      use wavy_pars
      use tank_pars
c
      real xx(nx_tank), zz_tank(nx_tank), us(nx_tank), ws(nx_tank),
     +     y2(nx_tank), u2(nx_tank), w2(nx_tank), xles(nnx)
     
c
c --------- allocate surface arrays
c
      allocate(z_tank(nnx), u_tank(nnx), w_tank(nnx),
     +         z_tank_f(nnx), u_tank_f(nnx), w_tank_f(nnx),
     +         z_tank_i(nnx), u_tank_i(nnx), w_tank_i(nnx),
     +         hdot_i(nnx), hx_i(nnx))
c
      i_tank = 7
      lut    = 89
      close(lut)
      if(i_tank == 1) then     ! no breaking case
         open(lut,file='./les_tank_nobreak.dat')
         npts_t  = 1485
         wave_l  = 0.232780E+02*0.01
         c_speed = 0.602861E+00
         wave_k  = pi2/wave_l
         ustar_tank = 0.381 ! from table 2 of banner 1990
      elseif(i_tank == 2) then ! breaking case
         open(lut,file='./les_tank_break.dat')
         npts_t  = 1485
         wave_l  = 0.235351E+02*0.01
         c_speed = 0.606335E+00
         wave_k  = pi2/wave_l
         ustar_tank = 0.4928 ! from table 2 of banner 1990
      elseif(i_tank == 3) then     ! mono wave case
         open(lut,file='./les_tank_mono.dat')
         npts_t  = 1500
         wave_l  = 0.232780
         c_speed = 0.602861E+00
         wave_k  = pi2/wave_l
         ustar_tank = 0.381 ! from table 2 of banner 1990
      elseif(i_tank == 6) then     ! mono wave case with no drift
         open(lut,file='./les_tank_mono_3.dat')
         npts_t  = 1500
         wave_l  = 0.232780E+02*0.01
         c_speed = 0.602861E+00
         wave_k  = pi2/wave_l
         ustar_tank = 0.381 ! from table 2 of banner 1990
      elseif(i_tank == 7) then     ! no breaking case with drift = 0
         open(lut,file='./les_tank_nobreak_orb.dat')
         npts_t  = 1485
         wave_l  = 0.232780E+02*0.01
         c_speed = 0.602861E+00
         wave_k  = pi2/wave_l
         ustar_tank = 0.381 ! from table 2 of banner 1990
      elseif(i_tank == 8) then     ! mono wave case ak = 0.1 with no drift
         open(lut,file='./les_tank_mono_4.dat')
         npts_t  = 1500
         wave_l  = 0.232780E+02*0.01
         c_speed = 0.602861E+00
         wave_k  = pi2/wave_l
         ustar_tank = 0.381 ! from table 2 of banner 1990
      elseif(i_tank == 9) then ! breaking case with no drift
         open(lut,file='./les_tank_break_nodrift.dat')
         npts_t  = 1485
         wave_l  = 0.235351E+02*0.01
         c_speed = 0.606335E+00
         wave_k  = pi2/wave_l
         ustar_tank = 0.4928 ! from table 2 of banner 1990
      elseif(i_tank == 10) then ! Trying to replicate Sullivan et al. (2000)
         open(lut,file='./emily_wave.dat')
         npts_t  = 1000
         wave_l  = 1.0*0.01 !Must trick it so that the nondimensionalization process works below
         c_speed = 0.25
         wave_k  = pi2/wave_l
         !ustar_tank = 0.03415 ! from table 1 of Sullivan et al. 2000 ak = 0.2
         ustar_tank = 1.0 !At the moment, unsure of how to handle this, but don't want to mess up c_speed below
      elseif(i_tank == 11) then ! Testing the DNS formulation (no-slip) by giving it a stationary, bumpy surface
         open(lut,file='./emily_wave.dat')
         npts_t  = 1000
         wave_l  = 1.0*0.01 !Must trick it so that the nondimensionalization process works below
         c_speed = 0.0
         wave_k  = pi2/wave_l
         ustar_tank = 1.0 !At the moment, unsure of how to handle this, but don't want to mess up c_speed below
      endif
c
      do i=1,4
         read(lut,'(a1)') idum
      enddo
      do i=1,npts_t
         read(lut,*) xx(i), zz_tank(i), us(i), ws(i)
      enddo
      if (myid==0) write(*,*) 'Finished reading tank data'
c
c ---------- change lengths to m from cm and make dimensionless by 
c            wavelength
c
      do i=1,npts_t
         xx(i)      = xx(i)*0.01/wave_l
         zz_tank(i) = zz_tank(i)*0.01/wave_l
         us(i)      = us(i)/ustar_tank
         ws(i)      = ws(i)/ustar_tank
      enddo
c
      c_speed = c_speed/ustar_tank
      wave_l  = 1.0
      wave_k  = pi2
c
      write(nprt,1001) (i,xx(i), zz_tank(i),us(i),ws(i),
     +                  i=1,nnx)
 1001 format(' 1001: tank ',/,
     +       ' i ',5x,' xx ',5x,' zz ',5x,' us ',5x,
     +       ' ws ',/,(i5,4e15.6))
c
c ---------- fit a spline to the data
c
      yp1 = 2.0e+30
      ypn = yp1
      call spline(xx,zz_tank,npts_t,yp1,ypn,y2)
      call spline(xx,us,npts_t,yp1,ypn,u2)
      call spline(xx,ws,npts_t,yp1,ypn,w2)
c
c ---------- interpolate into the spline function at les points
c
      ddx = xl/float(nnx)
      do i=1,nnx
         xles(i) = float(i-1)*ddx
         call splint(xx,zz_tank,y2,npts_t,xles(i),z_tank(i))
         call splint(xx,us,u2,npts_t,xles(i),u_tank(i))
         call splint(xx,ws,w2,npts_t,xles(i),w_tank(i))
      enddo
c
c     write(nprt,4002) (xx(i),zz_tank(i),i=1,npts_t)
c4002 format(' xx ',5x,' zz tank ',/,(2e15.6))
c     write(nprt,4004) (xx(i),ws(i),i=1,npts_t)
c4004 format(' xx ',5x,' ws tank ',/,(2e15.6))
c     write(nprt,4003) (xles(i), z_tank(i),i=1,nnx)
c4003 format(' xles ',5x,' zz les ',/,(2e15.6))
c     write(nprt,4005) (xles(i), w_tank(i),i=1,nnx)
c4005 format(' xles ',5x,' w les ',/,(2e15.6))
c
      sum = 0.0
      do i=1,nnx
         sum = sum + z_tank(i)
      enddo
      sum = sum/float(nnx)
      do i=1,nnx
         z_tank(i) = z_tank(i) - sum
      enddo
c
c --------- force mean w = 0 from the data 
c
      sum_w = 0.0
      do i=1,nnx
         sum_w = sum_w + w_tank(i)
      enddo
      sum_w = sum_w/float(nnx)
      do i=1,nnx
         w_tank(i) = w_tank(i) - sum_w
      enddo
c
      write(nprt,4001) sum, sum_w
 4001 format(' Mean wave height = ',e15.6,' sum w = ',e15.6)
c
c --------- get fourier coefficients at t = 0
c           to use in building shape at t > 0
c
      fnx = 1.0/float(nnx)
      do i=1,nnx
         z_tank_f(i) = z_tank(i)*fnx
         u_tank_f(i) = u_tank(i)*fnx
         w_tank_f(i) = w_tank(i)*fnx
      enddo
      call rfftf(nnx,z_tank_f(1),trigx(1,1))
      call rfftf(nnx,u_tank_f(1),trigx(1,1))
      call rfftf(nnx,w_tank_f(1),trigx(1,1))
c
c ------ dealias the inputs to match the grid resolution
c        careful with the indices, match fftpack order
c
      ix_cut   = 2*int(float(nnx)/3.) + 2
c     ix_cut   = 44
c
      do i=ix_cut,nnx
         z_tank_f(i) = 0.0
         u_tank_f(i) = 0.0
         w_tank_f(i) = 0.0
      enddo
c
c ------ DEBUG
c
c     do i=1,nnx
c        z_tank_i(i) = z_tank(i)
c        u_tank_i(i) = u_tank(i)
c        w_tank_i(i) = w_tank(i)
c     enddo
c
      return
      end
      subroutine get_surf(t_bndy)
c
c ------- generate new surface at t = t_bndy
c         assuming its the real part of the complex fft
c         allow for time varying amplitude to smoothly add wave
c         spectrum from a restart
c
      use pars
      use fields
      use fftwk
      use con_data
      use con_stats
      use wavy_pars
      real bndyx(nnx,iys:iye), bndyy(nnx,iys:iye,izs:izs)
c
c ------------ for doing restart with gradually growing bumps
c              specify initial and end times to blend over
c
      t1_st  = 0.59781897E+04 + 0.5 ! time for volume ja1062
      t1_en  = t1_st + 400.0
      b_rate = 1.0/(t1_en - t1_st)
c
c --------- for debug turn on waves right away
c
      if(t_bndy .lt. t1_st) then
         ampl_fac  = 0.0
         ampl_rate = 0.0
      elseif(t_bndy .ge. t1_st .and. t_bndy .lt. t1_en) then
         ampl_fac  = amax1((b_rate*(t_bndy - t1_st)),0.0)
         ampl_rate = b_rate
      elseif(t_bndy .ge. t1_en) then
         ampl_fac  = 1.0
         ampl_rate = 0.0
      endif
c
c -------------- make surface flat, for initialization
c
c     ampl_fac  = 0.0
c     ampl_rate = 0.0
c
      nx2 = 2*nnx
      do j=iys,iye
      do i=1,nnx
         aa           = eta0(1,i,j)
         bb           = eta0(2,i,j)
         comg         = cos(omega(i,j)*t_bndy)
         somg         = sin(omega(i,j)*t_bndy)
         s_wrk(1,i,j) = comg*aa + somg*bb
         s_wrk(2,i,j) = comg*bb - somg*aa
      enddo
      enddo
c
c     j = iys
c     write(nprt,7001) (i, bndy(i,j),eta0(i,j),i=1,nnx)
c7001 format(' 7001 debug ',/,' i',5x,' bndy ',5x,' eta0',/,(i5,2e15.6))
c     write(nprt,7010) (i, omega(i,j),i=1,ncx)
c7010 format(' 7010 debug ',/,' i',5x,' omega ',/,(i5,e15.6))
c
c --------- get the u_orbital velocity of the wave
c
      do j=iys,iye
      do i=2,nnx
         fac_o        = (grav/omega(i,j))*ampl_fac
         v_wrk(1,i,j) = fac_o*xkn(i)*s_wrk(1,i,j)
         v_wrk(2,i,j) = fac_o*xkn(i)*s_wrk(2,i,j)
      enddo
      enddo
      i  = 1
      do j=max(2,iys),iye
         fac_o        = (grav/omega(i,j))*ampl_fac
         v_wrk(1,i,j) = fac_o*xkn(i)*s_wrk(1,i,j)
         v_wrk(2,i,j) = fac_o*xkn(i)*s_wrk(2,i,j)
      enddo
      if(iys .eq. 1) then
         v_wrk(1,i,iys) = 0.0
         v_wrk(2,i,iys) = 0.0
      endif
      call fft2d_cmplx_mpi(v_wrk(1,1,iys),eta_wrk(1,i2xs),trigcx,trigc,
     +           nnx,nx2,nny,i2xs,i2xe,i2x_s,i2x_e,iys,iye,iy_s,iy_e,
     +           1,1,myid,ncpu_s,numprocs)
      do j=iys,iye
      do i=1,nnx
         u_orbit(i,j) = v_wrk(1,i,j)
      enddo
      enddo
c
c --------- get the v_orbital velocity of the wave
c
      do j=iys,iye
      do i=2,nnx
         fac_o        = (grav/omega(i,j))*ampl_fac
         v_wrk(1,i,j) = fac_o*ykn(j)*s_wrk(1,i,j)
         v_wrk(2,i,j) = fac_o*ykn(j)*s_wrk(2,i,j)
      enddo
      enddo
      i  = 1
      do j=max(2,iys),iye
         fac_o        = (grav/omega(i,j))*ampl_fac
         v_wrk(1,i,j) = fac_o*ykn(j)*s_wrk(1,i,j)
         v_wrk(2,i,j) = fac_o*ykn(j)*s_wrk(2,i,j)
      enddo
      if(iys .eq. 1) then
         v_wrk(1,i,iys) = 0.0
         v_wrk(2,i,iys) = 0.0
      endif
      call fft2d_cmplx_mpi(v_wrk(1,1,iys),eta_wrk(1,i2xs),trigcx,trigc,
     +           nnx,nx2,nny,i2xs,i2xe,i2x_s,i2x_e,iys,iye,iy_s,iy_e,
     +           1,1,myid,ncpu_s,numprocs)
      do j=iys,iye
      do i=1,nnx
         v_orbit(i,j) = v_wrk(1,i,j)
      enddo
      enddo
c
c ------------- get hdot
c
      do j=iys,iye
      do i=2,nnx
         v_wrk(1,i,j) = omega(i,j)*s_wrk(2,i,j)*ampl_fac +
     +                  ampl_rate*s_wrk(1,i,j)
         v_wrk(2,i,j) = -omega(i,j)*s_wrk(1,i,j)*ampl_fac +
     +                  ampl_rate*s_wrk(2,i,j)
      enddo
      enddo
      i  = 1
      do j=max(2,iys),iye
         v_wrk(1,i,j) = omega(i,j)*s_wrk(2,i,j)*ampl_fac +
     +                  ampl_rate*s_wrk(1,i,j)
         v_wrk(2,i,j) = -omega(i,j)*s_wrk(1,i,j)*ampl_fac +
     +                  ampl_rate*s_wrk(2,i,j)
      enddo
      if(iys .eq. 1) then
         v_wrk(1,i,iys) = 0.0
         v_wrk(2,i,iys) = 0.0
      endif
      call fft2d_cmplx_mpi(v_wrk(1,1,iys),eta_wrk(1,i2xs),trigcx,trigc,
     +           nnx,nx2,nny,i2xs,i2xe,i2x_s,i2x_e,iys,iye,iy_s,iy_e,
     +           1,1,myid,ncpu_s,numprocs)
      do j=iys,iye
      do i=1,nnx
         hdot(i,j) = v_wrk(1,i,j)
      enddo
      enddo
c
c -------- get the surface
c
      call fft2d_cmplx_mpi(s_wrk(1,1,iys),eta_wrk(1,i2xs),trigcx,trigc,
     +           nnx,nx2,nny,i2xs,i2xe,i2x_s,i2x_e,iys,iye,iy_s,iy_e,
     +           1,1,myid,ncpu_s,numprocs)
      do j=iys,iye
      do i=1,nnx
         bndy(i,j)          = s_wrk(1,i,j)*ampl_fac
         bndyx(i,j)         = bndy(i,j)
         bndyy(i,j,izs:izs) = bndy(i,j)
      enddo
      enddo
c
c -------- get variance of surface
c
      sumb = 0.0
      do j=iys,iye
      do i=1,nnx
         sumb = sumb + bndy(i,j)
      enddo
      enddo
      sumb = sumb*fnxy
      call mpi_sum_xy(sumb,myid,iss,ise,1)
c
      varb = 0.0
      do j=iys,iye
      do i=1,nnx
         varb = varb + (bndy(i,j) - sumb)**2
      enddo
      enddo
      varb = varb*fnxy
      call mpi_sum_xy(varb,myid,iss,ise,1)
c     write(6,8102) sumb, varb
c8102 format(' 8102: sum bndy = ',e15.6,' variance bndy = ',e15.6)
c
c --------  w_o = hdot +  u_o*h_x + v_o*h_y
c
      call xderivp(bndyx(1,iys),trigx(1,1),xk(1),nnx,iys,iye)
      call yd_mpi(bndyy(1,iys,izs),trigx(1,2),yk(1),
     +            nnx,nny,ixs,ixe,ix_s,ix_e,
     +            iys,iye,iy_s,iy_e,izs,izs,myid,ncpu_s,numprocs)
      do j=iys,iye
      do i=1,nnx
         w_orbit(i,j) = hdot(i,j) + u_orbit(i,j)*bndyx(i,j) + 
     +                  v_orbit(i,j)*bndyy(i,j,izs)
      enddo
      enddo
c
c ----------- make sure mean of w_orbit = 0
c
      sum_w = 0.0
      do j=iys,iye
      do i=1,nnx
         sum_w = sum_w + w_orbit(i,j)
      enddo
      enddo
      sum_w = sum_w*fnxy
      call mpi_sum_xy(sum_w,myid,iss,ise,1)
c
      do j=iys,iye
      do i=1,nnx
         w_orbit(i,j) = w_orbit(i,j) - sum_w
      enddo
      enddo
c
c     j = iys
c     write(nprt,8002) t_bndy
c8002 format(' t bndy = ',e15.6)
c     write(nprt,8001) (i,bndy(i,j),u_orbit(i,j),w_orbit(i,j),i=1,nnx)
c8001 format(' 8001 get surf',/,
c    +       ' i ',5x,' bndy ',5x,' u orb',5x,' w orb ',/,
c    +       (i5,3e15.6))
c
      return
      end
      subroutine get_surf_tank(t_bndy)
c
c ------- generate new surface at t = t_bndy
c         for the laboratory wave. Assume the shape moves
c         with uniform phase speed. Build w_o and hdot so
c         that they satisfy the inputs for u_o and h
c         with fix sr. hx_deriv
c
      use pars
      use fields
      use fftwk
      use con_data
      use con_stats
      use wavy_pars
      use tank_pars
c
c ------------ for doing restart with gradually growing bumps
c              specify initial and end times to blend over
c              more aggressive strategy to trigger turbulence
c
c     t1_st  = 0.85340788E+01 + 0.01 ! time from volume ub1020
c
      t1_st  =  0.01 ! time relative to t_zero set by i_move_step
c
c     t1_st  = 100000.0 ! to make surface always flat for initialization
c
      t1_en  = t1_st + 0.25
      b_rate = 1.0/(t1_en - t1_st)
c
c --------- for debug turn on waves right away
c
      if(t_bndy .lt. t1_st) then
         ampl_fac  = 0.0
         ampl_rate = 0.0
      elseif(t_bndy .ge. t1_st .and. t_bndy .lt. t1_en) then
         ampl_fac  = amax1((b_rate*(t_bndy - t1_st)),0.0)
         ampl_rate = b_rate
      elseif(t_bndy .ge. t1_en) then
         ampl_fac  = 1.0
         ampl_rate = 0.0
      endif
c
c ------------ get (u,w) components of surface velocity and wave 
c              height. Make h, hdot, uo, wo match
c
      dist = -c_speed*t_bndy
c     dist = 0.0
      call gal_interp(u_tank_f,trigx(1,1),nnx,xkn,dist,u_tank_i)
      call gal_interp(z_tank_f,trigx(1,1),nnx,xkn,dist,z_tank_i)
      call hdot_interp(z_tank_f,trigx(1,1),nnx,xkn,dist,c_speed,hdot_i)
      call hx_deriv(z_tank_i,trigx(1,1),xkn,nnx,hx_i)
c
c     write(nprt,1012) c_speed, t_bndy
c1012 format(' 1012: tank s_speed = ',e15.6,' t_bndy = ',e15.6)
c
      sum   = 0.0
      sum_w = 0.0
      do i=1,nnx
         sum = sum + z_tank_i(i)
      enddo
      sum = sum/float(nnx)
c     write(nprt,1013) sum
c1013 format(' 1013: tank sum z = ',e15.6)
c
c     ampl_fac = 1.0
      do j=iys,iye
      do i=1,nnx
         u_orbit(i,j) = u_tank_i(i)*ampl_fac
         v_orbit(i,j) = 0.0
         bndy(i,j)    = z_tank_i(i)*ampl_fac
      enddo
      enddo
c
c     j = iys
c     write(nprt,7001) (i, bndy(i,j),u_orbit(i,j),w_orbit(i,j),i=1,nnx)
c7001 format(' 7001 debug ',/,' i',5x,' bndy ',5x,' u orbit',
c    +       5x,' w orbit',/,(i5,3e15.6))
c
c -------- get variance of surface
c
      sumb = 0.0
      do j=iys,iye
      do i=1,nnx
         sumb = sumb + bndy(i,j)
      enddo
      enddo
      sumb = sumb*fnxy
      call mpi_sum_xy(sumb,myid,iss,ise,1)
c
      varb = 0.0
      do j=iys,iye
      do i=1,nnx
         varb = varb + (bndy(i,j) - sumb)**2
      enddo
      enddo
      varb = varb*fnxy
      call mpi_sum_xy(varb,myid,iss,ise,1)
c     write(6,8102) sumb, varb
c8102 format(' 8102: sum bndy = ',e15.6,' variance bndy = ',e15.6)
c
c -------- use w_o = hdot + u_o*h_x + v_o*h_y 
c
      do j=iys,iye
      do i=1,nnx
         hdot(i,j)    = hdot_i(i)*ampl_fac
         w_orbit(i,j) = hdot(i,j) + u_orbit(i,j)*hx_i(i)*ampl_fac
      enddo
      enddo
c
c ----------- make sure mean of w_orbit = 0
c
      sum_w = 0.0
      do j=iys,iye
      do i=1,nnx
         sum_w = sum_w + w_orbit(i,j)
      enddo
      enddo
      sum_w = sum_w*fnxy
      call mpi_sum_xy(sum_w,myid,iss,ise,1)
c
      do j=iys,iye
      do i=1,nnx
         w_orbit(i,j)    = w_orbit(i,j) - sum_w
      enddo
      enddo
c
c     j = iys
c     write(nprt,8002) t_bndy
c8002 format(' t bndy = ',e15.6)
c     write(nprt,8001) (i,bndy(i,j),u_orbit(i,j),w_orbit(i,j),i=1,nnx)
c8001 format(' 8001 get surf',/,
c    +       ' i ',5x,' bndy ',5x,' u orb',5x,' w orb ',/,
c    +       (i5,3e15.6))
c
      return
      end
      subroutine pm64(dkx,dky,xk,yk,nx,ny,u10,amp)
c
c --------- evaluate PM wave spectrum in terms of wavenumber
c
      real, parameter ::
     +      grav  = 9.81, f_pm4 = 0.13, a_pm4 = 0.0081, b_pm4 = 1.25
      real kmag
      real amp(nx,ny), xk(nx), yk(ny)
c
      pi2 = 8.0*atan(1.0)
c
      sum_dir  = 0.0
      do j=1,ny
      do i=1,nx
c
c ----------- convert wave number into frequency
c
         kmag = sqrt(xk(i)**2 + yk(j)**2)
         f    = sqrt(grav*kmag)/pi2
c
         if(f .le. 0.0) then
            amp(i,j) = 0.0
         else
            t1        = a_pm4*grav*grav/(f*(pi2*f)**4)
            fpm       = grav*f_pm4/u10
            t4        = b_pm4*(fpm/f)**4
            amp(i,j)  = t1*exp(-t4)
c
c ----------- convert into wavenumber
c
            amp(i,j)  = amp(i,j)*0.5*sqrt(grav/kmag)/(kmag*pi2)
c
c ----------- simple directional spectrum
c
            if(xk(i) .ge. 0.0 .and. yk(j) .ge. 0.0) then
              angle = acos(xk(i)/kmag)
            elseif(xk(i) .ge. 0.0 .and. yk(j) .le. 0.0) then
              angle =  -acos(xk(i)/kmag)
            elseif(xk(i) .le. 0.0 .and. yk(j) .ge. 0.0) then
              angle = pi2*0.5 - acos(abs(xk(i))/kmag)
            elseif(xk(i) .le. 0.0 .and. yk(j) .le. 0.0) then
              angle = -pi2*0.5 + acos(abs(xk(i))/kmag)
            endif
            if(angle .lt. -pi2/4.0 .or. angle .gt. pi2/4.0) then
              fac = 0.0
            else 
              fac1     = cos(angle)
              fac      = fac1**8
            endif
            amp(i,j) = amp(i,j)*fac
            sum_dir  = sum_dir + fac*dkx*dky
         endif
c
      enddo
      enddo
c
      sum_dir_i = 1.0/sum_dir
      sum_spec  = 0.0
      do j=1,ny
      do i=1,nx
         amp(i,j) = amp(i,j)*sum_dir_i
         sum_spec = sum_spec + amp(i,j)*dkx*dky
      enddo
      enddo
c
      write(6,3000) sum_spec, sum_dir
 3000 format(' 3000: PM 64 sum_spec = ',e15.6,' sum_dir = ',e15.6)
c
      return
      end
      subroutine donelan(dkx,dky,xk,yk,nx,ny,u10,age,dir_mean,amp)
c
c -------- get amplitude of wavenumber spectrum according to donelan
c          prescription in Komen etal, p. 187 that includes
c          directional dependence. The routine converts the
c          frequency-directional spectrum F(omega,phi)
c          into a wavenumber-directional spectrum G(k,phi), see notes.
c
c     Inputs are :
c
c     (xk,yk) --- (kx,ky) wavenumbers
c     u10     --- wind speed at 10 m
c     age     --- wave age = cp/u10
c     dir_mean -- mean direction of wave field in radians from x-axis
c
c     Output :
c
c     amp --- amplitude of spectrum at wavenumber (xk,yk)
c
      real xk(nx), yk(ny), amp(nx,ny)
c
      data ionce /0/
      save grav, pi2, ionce
      real kmag
c
      if(ionce .eq. 0) then
        grav  = 9.81
        pi2   = 8.0*atan(1.0)
        ionce = 1
      endif
c
c     write(6,5601) u10, age, dir_mean
 5601 format(' 5601: u10 = ',e15.6,' age = ',e15.6,/,
     +       ' dir mean = ',e15.6)

c
      cp      = age*u10
      omega_p = grav/cp
      age_i   = 1.0/age
c
      aa      = amin1(age_i,5.0)
      aa      = amax1(aa, 1.0)
      sigma_d = 0.08*(1.0 + 4.0/(aa**3))
c
      aa      = amin1(age_i,5.0)
      aa      = amax1(aa, 0.83)
      alpha_d = 0.006*(aa**0.55)
c
      if(age_i .le. 1.0) then
        gamma_d = 1.7
      else
        aa = amin1(age_i,5.0)
        gamma_d = 1.7 + 6.0*alog10(age_i)
      endif
c
      sum_spec = 0.0
      sum_dir  = 0.0
c
      do j=1,ny
      do i=1,nx
c
         kmag    = sqrt(xk(i)**2 + yk(j)**2)
         omega   = sqrt(grav*kmag)
         if(kmag .eq. 0.0) then
           amp(i,j) = 0.0
           go to 999
         endif
c
         if(xk(i) .ge. 0.0 .and. yk(j) .ge. 0.0) then
           angle = acos(xk(i)/kmag)
         elseif(xk(i) .ge. 0.0 .and. yk(j) .le. 0.0) then
           angle =  -acos(xk(i)/kmag)
         elseif(xk(i) .le. 0.0 .and. yk(j) .ge. 0.0) then
           angle = pi2*0.5 - acos(abs(xk(i))/kmag)
         elseif(xk(i) .le. 0.0 .and. yk(j) .le. 0.0) then
           angle = -pi2*0.5 + acos(abs(xk(i))/kmag)
         endif
c
         gamma = exp(-(omega - omega_p)**2/
     +           (2.0*(sigma_d**2)*omega_p**2))
         fac   = exp(-(omega_p/omega)**4)
         fac1  = gamma_d**gamma
         spec  = alpha_d*(grav**2)*(omega/omega_p)*
     +           fac*fac1/(omega**5)
c
c --------- directional spreading
c
         ratio = omega/omega_p
         if(ratio .gt. 0.56 .and. ratio .lt. 0.95) then
           beta = 2.61*ratio**1.3
         elseif(ratio .ge. 0.95 .and. ratio .lt. 1.6) then
           beta = 2.28/ratio**1.3
         else
           beta = 1.24
         endif
c
         fac      = (angle - dir_mean)*beta
         sech     = 2.0/(exp(fac) + exp(-fac))
         spec_dir = beta*0.5*sech**2
c
         amp(i,j)  = spec*spec_dir
c
c --------- weight amp by the conversion factor to put it
c           into wavenumber space ... see notes
c
         amp(i,j) = amp(i,j)*0.5*sqrt(grav/kmag)/kmag
c
c --------- get integrals in wavenumber space
c
         sum_spec  = sum_spec + amp(i,j)*dkx*dky
         sum_dir   = sum_dir + spec_dir*dkx*dky
c
  999 continue
c
      enddo
      enddo
c
      write(6,6000) sum_spec, sum_dir
 6000 format(' 6000: in Donelan ',/,
     +       ' Sum spectrum = ',e15.6,/,
     +       ' Sum directional spectrum = ',e15.6)
c
c ---------- rescale the directional 
c            spectrum to make sure its integral = 1
c
      sum_dir_i = 1.0/sum_dir
c
c     do j=1,ny
c     do i=1,nx
c        amp(i,j) = amp(i,j)*sum_dir_i
c     enddo
c     enddo
c
      return
      end

      real function gasdev(idum)
      integer idum, iset
      real fac, gset, rsq, v1, v2, ran1
      save iset, gset
      data iset /0/
      if(iset .eq. 0) then
    1 continue
        v1  = 2.0*ran1(idum) - 1.0
        v2  = 2.0*ran1(idum) - 1.0
        rsq = v1**2 + v2**2
        if(rsq .ge. 1.0 .or. rsq .eq. 0.0) go to 1
        fac    = sqrt(-2.0*log(rsq)/rsq)
        gset   = v1*fac
        gasdev = v2*fac
        iset   = 1
      else
        gasdev = gset
        iset   = 0
      endif
c
      return
      end
      subroutine l_bndy(t_bndy)
c
c ---------- build the shape of the lower boundary
c            and compute its speed of movement
c            at time t_bndy
c
      use pars
      use fields
      use con_data
      use con_stats
c
c -------- pick boundary shape
c
      ikase = 1 ! wavy bottom with 2 waves
      ikase = 4 ! 3-D hill
      ikase = 2 ! monochromatic wave
      ikase = 6 ! propagating monochromatic wave plus cross swell
      ikase = 7 ! stationary monochromatic wave , ak = 0.5
      ikase = 3 ! 2-D hill
      ikase = 5 ! propagating monochromatic wave
c
      if(ikase .eq. 1) then ! multiple waves
c
         wave = xl/4.0
         fac  = pi2/wave
         ak   = 0.1
         ampl = ak*wave/pi2
         wave2 = xl/8.0
         fac2  = pi2/wave2
         ak2   = 0.01
         ampl2 = ak2*wave2/pi2
         phase = 0.0
         do j=iys,iye
         do i=1,nnx
            bndy(i,j) = ampl*cos(fac*xgrid(i) + phase) + 
     +                  ampl2*sin(fac2*xgrid(i))
            hdot(i,j) = 0.0
            u_orbit(i,j) = 0.0
            v_orbit(i,j) = 0.0
         enddo
         enddo
c
      else if(ikase .eq. 2) then ! monochromatic wave
c
         wave = xl/4.0
         fac  = pi2/wave
         ak   = 0.1
         ampl = ak*wave/pi2
         do j=iys,iye
         do i=1,nnx
            bndy(i,j) = ampl*cos(fac*xgrid(i))
            hdot(i,j) = 0.0
            u_orbit(i,j) = 0.0
            v_orbit(i,j) = 0.0
         enddo
         enddo
c
      elseif(ikase .eq. 3) then ! 2-D hill
c
         a      = 25.0
         xcntr  = 0.5*xl
         hill_l = 67.0
c
         a      = 25.0
         hill_l = 67.0
c
c --------- flat hill for generating wt flow
c
c        a      = 0.0
c
         do j=iys,iye
         do i=1,nnx
            if(xgrid(i) .ge. (xcntr - 2.0*hill_l) .and.
     +         xgrid(i) .le. (xcntr + 2.0*hill_l)) then
              x_temp    = xgrid(i) - xcntr
              bndy(i,j) = a*(1.0 + cos(pi2*x_temp/(4.0*hill_l)))
            else
              bndy(i,j) = 0.0
            endif
            hdot(i,j) = 0.0
            u_orbit(i,j) = 0.0
            v_orbit(i,j) = 0.0
         enddo
         enddo
c
      elseif(ikase .eq. 4) then ! 3-D hill
c
         xo    = xl/2.0
         yo    = yl/2.0
         ampl  = 60.000
         rlen  = 1000.0
         do j=iys,iye
         do i=1,nnx
            rad = sqrt((xgrid(i)-xo)**2 + (ygrid(j)-yo)**2)
            if(rad .le. rlen*0.5) then
               bndy(i,j) = ampl*(1.0 + cos(pi2*rad/rlen))
            else
               bndy(i,j) = 0.0
            endif
            hdot(i,j) = 0.0
            u_orbit(i,j) = 0.0
            v_orbit(i,j) = 0.0
         enddo
         enddo
c
      else if(ikase .eq. 5) then ! propagating monochromatic wave
c
         wave_l  = xl/12.0
         wave_k  = pi2/wave_l
         ak      = 0.1
         ampl    = ak*wave_l/pi2
         c_speed = sqrt(grav/wave_k)
c
c ---------- for start set ampl = 0
c
c        ampl = 0.0
c
c ---------- get Cartesian orbital velocities
c
         f_rad = sqrt(grav*sqrt(wave_k**2))
         con_u = grav*wave_k/f_rad
         do j=iys,iye
         do i=1,nnx
            bndy(i,j) = ampl*cos(wave_k*(xgrid(i) - c_speed*t_bndy))
            hdot(i,j) = ampl*wave_k*c_speed*
     +                    sin(wave_k*(xgrid(i) - c_speed*t_bndy))
            u_orbit(i,j) = bndy(i,j)*con_u
            v_orbit(i,j) = 0.0
         enddo
         enddo
c
      else if(ikase .eq. 6) then ! propagating monochromatic wave
                                 ! long wave moving vertically
c
         wave_l  = xl/12.0
         wave_k  = pi2/wave_l
         ak      = 0.1
         ampl    = ak*wave_l/pi2
         c_speed = sqrt(grav/wave_k)
c
         wave_l2 = xl/6.0
         wave_k2 = pi2/wave_l2
         ak2     = 0.025
         ampl2   = ak2*wave_l2/pi2
         c_spd2  = sqrt(grav/wave_k2)
         do j=iys,iye
         do i=1,nnx
            bndy(i,j) = ampl*cos(wave_k*(xgrid(i) - c_speed*t_bndy))
            hdot(i,j) = ampl*wave_k*c_speed*
     +                    sin(wave_k*(xgrid(i) - c_speed*t_bndy))
            bndy2     = ampl2*cos(wave_k2*(ygrid(j) - c_spd2*t_bndy))
            bndy(i,j) = bndy2 + bndy(i,j)
         enddo
         enddo
c
c ---------- get Cartesian orbital velocities
c
         f_rad = sqrt(grav*sqrt(wave_k**2 + wave_k2**2))
         con_u = grav*wave_k/f_rad
         con_v = grav*wave_k2/f_rad
         do j=iys,iye
         do i=1,nnx
            u_orbit(i,j) = bndy(i,j)*con_u
            v_orbit(i,j) = bndy(i,j)*con_v
         enddo
         enddo
c
c        i = nnx/4
c        j = (iys + iye)/2
c        write(nprt,3101) wave_l, c_speed, bndy(i,j),hdot(i,j)
c3101    format(' 3101 bndy ',/,
c    +   ' wave l = ',e15.6,' c = ',e15.6,
c    +   ' bndy = ',e15.6,' hdot = ',e15.6)
c
      else if(ikase .eq. 7) then ! stationary monochromatic wave
                                 ! long wave moving vertically
c
         wave_l  = xl/2.0
         wave_k  = pi2/wave_l
         ak      = 0.5
c
c -------- make it flat
c
         ak      = 0.0
         ampl    = ak*wave_l/pi2
         c_speed = sqrt(grav/wave_k)
         c_speed = 0.0
c
         do j=iys,iye
         do i=1,nnx
            bndy(i,j) = ampl*cos(wave_k*(xgrid(i)))
            hdot(i,j) = 0.0
         enddo
         enddo
c
c ---------- get Cartesian orbital velocities
c
         f_rad = sqrt(grav*sqrt(wave_k**2))
         con_u = grav*wave_k/f_rad
         con_u = 0.0
         do j=iys,iye
         do i=1,nnx
            u_orbit(i,j) = 0.0
            v_orbit(i,j) = 0.0
         enddo
         enddo
c
c        i = nnx/4
c        j = (iys + iye)/2
c        write(nprt,3101) wave_l, c_speed, bndy(i,j),hdot(i,j)
c3101    format(' 3101 bndy ',/,
c    +   ' wave l = ',e15.6,' c = ',e15.6,
c    +   ' bndy = ',e15.6,' hdot = ',e15.6)
c
c
      endif
c
c     j = iys
c     write(nprt,5001) (i,bndy(i,j),i=1,nnx)
c5001 format(' i ',5x,' bndy ',/,(i5,e15.6))
c
      return
      end
      subroutine mesh
c
c ---------- get the mesh of the terrain following or flat grid 
c            metrics stored at cell centers 
c            should be made more general to avoid grid generation
c            by every processor
c
      use pars
      use fields
#if defined(SWAP)
      use module_byteswap
#endif
      use fftwk
      use con_data
      use con_stats
      include 'mpif.h'
      logical there
      real fs(nnx,iys:iye), fr(nnx,iys:iye)
      integer istatus(mpi_status_size)
c
      integer(kind=mpi_offset_kind) :: offset, disp
      integer(kind=k8)                 nsize, nsize2
      parameter(nvar_g = 4)
c
      real ztemp(0:nnz+2), fnt1(nnx,iys:iye,izs-1:ize+1)
      real, allocatable, dimension(:,:,:) :: temp
      allocate(temp(nvar_g,nnx,iys:iye))
c
c ------------ metric definitions
c
c     gm(.,.,.,1)  = z_zeta = 1/J
c     gm(.,.,.,2)  = zeta_x = - z_xi*J
c     gm(.,.,.,3)  = zeta_y = - z_eta*J
c     gm(.,.,.,4)  = zeta_z = 1/z_zeta = J
c     gm(.,.,.,5)  = z_t = grid speed; zeta_t = - z_t*J
c
      dx = xl/float(nnx)
      do i=1,nnx
         xgrid(i) = float(i-1)*dx
      enddo
      dy = yl/float(nny)
      do j=1,nny
         ygrid(j) = float(j-1)*dy
      enddo
c
      if(iflat .eq. 0) then
         do k=izs-1,ize+1
            do j=iys,iye
            do i=1,nnx
               zgrid_w(i,j,k,1) = z(k)
               zgrid_u(i,j,k)   = zz(k)
               z_zeta           = 1.0
               gm(i,j,k,1)      = z_zeta
               gm(i,j,k,4)      = 1.0/z_zeta
               gm(i,j,k,2)      = 0.0
               gm(i,j,k,3)      = 0.0
               gm(i,j,k,5)      = 0.0
            enddo
            enddo
         enddo
         do j=iys,iye
         do i=1,nnx
            z1b(i,j)      = zz(1)
            bndy_t(i,j,1) = zz(0)
            hdot_t(i,j,1) = 0.0
         enddo
         enddo
c
         if(l_debug) then
            ix = nnx/2
            iy = iys
            write(nprt,1020) (k,xgrid(ix),zgrid_u(ix,iy,k), 
     +                  zgrid_w(ix,iy,k,1), k=izs-1,ize+1)
         endif
c
      else
c
c --------- the z mesh
c
c        if(imesh .eq. 0) then
c          t_bndy = 0.0
c        else
c          t_bndy = amax1(0.,time - t_zero)
c        endif
c
         t_bndy = amax1(0.,time - t_zero)
c
         write(nprt,2001) t_bndy, time, t_zero
 2001    format(' 2001: mesh ',/,
     +          ' t_bndy = ',e15.6,' time = ',e15.6,
     +          ' t_zero = ',e15.6)
c
         if(i3d_surf .eq. 0) then
            call l_bndy(t_bndy)
         elseif(i3d_surf .eq. 1) then
            call get_surf(t_bndy)
         elseif(i3d_surf .eq. 2) then
            call get_surf_gabls(t_bndy)
         elseif(i3d_surf .eq. 3) then
            call get_surf_tank(t_bndy)
         endif
c
c -------- initial guess for stretching factor
c
         z_gues = 1.1
c
         do j=iys,iye
         do i=1,nnx
            if(iz_space == 1) then
               call vgrid(zw1,zi,zl-bndy(i,j),z_gues,nnz,
     +                    ztemp(0),l_root,l_debug)
            elseif(iz_space == 2) then
               z_first = zw1*(1.0 - bndy(i,j)/zl)
               call vgrid(z_first,zi,zl-bndy(i,j),z_gues,nnz,
     +                    ztemp(0),l_root,l_debug)
            elseif(iz_space == 3) then
               call exp_grid(bndy(i,j),zl,z(0),ztemp(0),nnz,a_exp_grd)
            elseif(iz_space == 4) then
               call exp_grid2(bndy(i,j),zl,z(0),ztemp(0),nnz,a_exp_grd2)
            elseif(iz_space == 5) then
               call algeb_grid(bndy(i,j),zl,z(0),ztemp(0),nnz,a_decay)
            else
               call cgrid(zl-bndy(i,j),nnz,ztemp(0))
            endif
            do k=izs-1,ize+1
               zgrid_w(i,j,k,1) = ztemp(k) + bndy(i,j)
            enddo
            do k=izs,ize+1
               zgrid_u(i,j,k) = bndy(i,j) + 0.5*(ztemp(k) + ztemp(k-1))
            enddo
            if(izs == 1) then
               zgrid_u(i,j,izs-1) = 2.0*zgrid_w(i,j,izs-1,1) - 
     +                              zgrid_u(i,j,izs)
            else
               zgrid_u(i,j,izs-1) = bndy(i,j) + 
     +                              0.5*(ztemp(izs-1) + ztemp(izs-2))
            endif
c
c --------- distance off the surface (every processor)
c
            z1b(i,j)      = 0.5*(ztemp(1) + ztemp(0))
            bndy_t(i,j,1) = bndy(i,j)
            hdot_t(i,j,1) = hdot(i,j)
         enddo
         enddo
c
         if(l_debug) then
            ix = nnx/2
            iy = iys
            write(nprt,1020) (k,xgrid(ix),zgrid_u(ix,iy,k), 
     +                     zgrid_w(ix,iy,k,1),
     +                     k=izs-1,ize+1)
         endif
c
c ------ generate metric components at cell centers
c        set metric components outside domain = to boundary values
c
        do k=izs,ize+1
           do j=iys,iye
           do i=1,nnx
              gm(i,j,k,1) = (zgrid_w(i,j,k,1) - zgrid_w(i,j,k-1,1))*
     +                       dzw_i(k)
           enddo
           enddo
        enddo
c
c ---------- pass the vertical gradient at ize
c            to the processor above at level izs-1
c
      nb = myid - ncpu_s
      nt = myid + ncpu_s
      if(iss .eq. 0) then
         nb = mpi_proc_null
      endif
      if(ise .eq. numprocs-1) then
         nt = mpi_proc_null
      endif
      nsend = nnx*(iye + 1 - iys)
      nrecv = nsend
      do j=iys,iye
      do i=1,nnx
         fs(i,j) = gm(i,j,ize,1)
      enddo
      enddo
      call mpi_sendrecv(
     +     fs(1,iys),nsend,mpi_real8,nt,2,
     +     fr(1,iys),nrecv,mpi_real8,nb,2,
     +     mpi_comm_world,istatus,ierr)
      if(iss .ne. 0) then
         do j=iys,iye
         do i=1,nnx
            gm(i,j,izs-1,1) = fr(i,j)
         enddo
         enddo
      else
         do j=iys,iye
         do i=1,nnx
            gm(i,j,izs-1,1) = gm(i,j,izs,1)
         enddo
         enddo
      endif
c
        do k=izs-1,ize+1
           do j=iys,iye
           do i=1,nnx
              gm(i,j,k,4) = 1.0/gm(i,j,k,1)
              fnt1(i,j,k) = zgrid_u(i,j,k)
              gm(i,j,k,5) = 0.0
           enddo
           enddo
           call xderivp(fnt1(1,iys,k),trigx(1,1),xk(1),nnx,iys,iye)
           do j=iys,iye
           do i=1,nnx
              gm(i,j,k,2) = -fnt1(i,j,k)*gm(i,j,k,4)
           enddo
           enddo
        enddo
        if(ize .eq. nnz) then
         k = ize + 1
         j = (iys + iye )/2
         write(nprt,3131) (i,zgrid_u(i,j,k),gm(i,j,k,4),
     +       gm(i,j,k,2),i=1,nnx)
 3131 format('3131 mesh',/,
     +       ' i ',5x,' zu ',5x,' gm 4 ',5x,' gm 2',/,
     +      (i5,3e15.6))
        endif
c
        do k=izs-1,ize+1
           do j=iys,iye
           do i=1,nnx
              fnt1(i,j,k) = zgrid_u(i,j,k)
           enddo
           enddo
        enddo
        call yd_mpi(fnt1(1,iys,izs-1),trigx(1,2),yk(1),
     +              nnx,nny,ixs,ixe,ix_s,ix_e,
     +              iys,iye,iy_s,iy_e,izs-1,ize+1,myid,ncpu_s,numprocs)
        do k=izs-1,ize+1
           do j=iys,iye
           do i=1,nnx
              gm(i,j,k,3) = -fnt1(i,j,k)*gm(i,j,k,4)
           enddo
           enddo
        enddo
c
      endif
      if(l_debug) then
         ix = nnx/2
         iy = iys
         write(nprt,1010) (k,gm(ix,iy,k,1),gm(ix,iy,k,2),
     +                  gm(ix,iy,k,3),gm(ix,iy,k,4),
     +                  gm(ix,iy,k,5),k=izs-1,ize+1)
 1010    format(' ind ',5x,' 1/J',5x,' -z_xi*J',5x,' -z_eta*J',5x,
     +          ' J',5x,' -z_t*J',/,
     +          (i5,5e15.6))
 1020    format(' k',5x,' xgrid',5x,' zgrid_u',5x,'zgrid_w',/,
     +          (i5,3e15.6))
         k  = izs-1
         iy = iys
         write(nprt,1010) (ix,gm(ix,iy,k,1),gm(ix,iy,k,2),
     +                  gm(ix,iy,k,3),gm(ix,iy,k,4),
     +                  gm(ix,iy,k,5),ix=1,nnx)
         k  = izs-1
         ix = nnx/2
         write(nprt,1010) (iy,gm(ix,iy,k,1),gm(ix,iy,k,2),
     +                  gm(ix,iy,k,3),gm(ix,iy,k,4),
     +                  gm(ix,iy,k,5),iy=iys,iye)
      endif
c
c ----------- save the grid file
c
      path_sav_g = trim(path_sav)//'/'//case(1:3)//'.grid'
c     write(nprt,9001) path_sav_g
c9001 format(' 9001: path = ',a80)
c
      call mpi_file_open(mpi_comm_world, path_sav_g,
     +                   mpi_mode_create+mpi_mode_rdwr,
     +                   mpi_info_null, ngrd, ierr)
c
c ---- set file view
c
      disp = 0
      call mpi_file_set_view(ngrd,disp,mpi_real8,mpi_real8,
     +                      'native',mpi_info_null,ierr)
c
c ---- write data
c
      nsize   = int(nvar_g,k8)*nnx*nny
      nsize2  = int(nvar_g,k8)*nnx*(iys-1)
      n_write = nvar_g*nnx*(iye+1-iys)
c
      if(ize .eq. nnz) then
         izen = ize + 1
      else
         izen = ize
      endif
c     do k=izs,ize
      do k=izs,izen
         do j=iys,iye
         do i=1,nnx
            temp(1,i,j) = zgrid_w(i,j,k-1,1)
            temp(2,i,j) = gm(i,j,k-1,1)
            temp(3,i,j) = gm(i,j,k-1,2)
            temp(4,i,j) = gm(i,j,k-1,3)
         enddo
         enddo
#if defined(SWAP)
      call byteswap(temp)
#endif
c
         offset = int((k-1),k8)*nsize + nsize2
c
c -------- mpi i/o with non-uniform blocks of data use _at
c
         call mpi_file_write_at(ngrd,offset,temp,n_write,
     +                              mpi_real8,status,ierr)
         if (ierr /= 0) goto 9991
 
      enddo
c
c ---- close file
c
      call mpi_file_close(ngrd, ierr)
c
c ---- check file
c
      if (l_root) then
         inquire(file=path_sav_g,exist=there)
         if(.not.there) then
            write(6,8000) ngrd,myid
            call mpi_abort(mpi_comm_world,icode,ierr)
         endif
         write(6,7000) path_sav_g
      endif
c
      deallocate(temp)
c
c ----------- store metrics for possible time variation
c
      do l=1,5
         do k=izs-1,ize+1
         do j=iys,iye
         do i=1,nnx
            gm2(i,j,k,l) = gm(i,j,k,l)
         enddo
         enddo
         enddo
      enddo
c
      do k=izs-1,ize+1
      do j=iys,iye
      do i=1,nnx
         zgrid_w(i,j,k,2) = zgrid_w(i,j,k,1)
      enddo
      enddo
      enddo
c
      do j=iys,iye
      do i=1,nnx
         z1b_2(i,j)    = z1b(i,j)
         bndy_t(i,j,2) = bndy_t(i,j,1)
         hdot_t(i,j,2) = hdot_t(i,j,1)
      enddo
      enddo
c
      return
c --------------------------  errors in writing grid file
 9991 continue
      write(6,6000) ngrd, k
 6000 format(' SR. MESH:',/,
     +       '    trouble cannot write grid file on unit = ',i2,/,
     +       '             at iz = ',i4)
      call mpi_abort(mpi_comm_world,icode,ierr)
c --------------------
 7000 format(' **** GRID IS WRITTEN IN FILE  ',a80)
 8000 format(' in MESH: trouble writing file ',i5,'  myid = ',i5)
      end
      subroutine new_mesh(it,istage)
c
c ---------- get a new mesh at time step t_stage3 
c
      use pars
      use fields
      use fftwk
      use con_data
      use con_stats
      include 'mpif.h'
      logical there
      real fs(nnx,iys:iye), fr(nnx,iys:iye)
      integer istatus(mpi_status_size)
c
      real ztemp(0:nnz+2), fnt1(nnx,iys:iye,izs-1:ize+1)
c
c ------------ metric definitions
c
c     gm2(.,.,.,1)  = z_zeta = 1/J
c     gm2(.,.,.,2)  = zeta_x = - z_xi*J
c     gm2(.,.,.,3)  = zeta_y = - z_eta*J
c     gm2(.,.,.,4)  = zeta_z = 1/z_zeta = J
c     gm2(.,.,.,5)  = z_t = grid speed; zeta_t = - z_t*J
c
c --------- update the metrics [note gm2(.,.,.,5) = 0]
c
      do l=1,5
         do k=izs-1,ize+1
         do j=iys,iye
         do i=1,nnx
            gm(i,j,k,l)  = gm2(i,j,k,l)
            gm2(i,j,k,l) = gm3(i,j,k,l)
         enddo
         enddo
         enddo
      enddo
c
      do k=izs-1,ize+1
      do j=iys,iye
      do i=1,nnx
         zgrid_w(i,j,k,1) = zgrid_w(i,j,k,2)
         zgrid_w(i,j,k,2) = zgrid_w(i,j,k,3)
      enddo
      enddo
      enddo
c
c --------- distance off the surface
c
         do j=iys,iye
         do i=1,nnx
            z1b(i,j)      = z1b_2(i,j)
            z1b_2(i,j)    = z1b_3(i,j)
            bndy_t(i,j,1) = bndy_t(i,j,2)
            bndy_t(i,j,2) = bndy_t(i,j,3)
            hdot_t(i,j,1) = hdot_t(i,j,2)
            hdot_t(i,j,2) = hdot_t(i,j,3)
         enddo
         enddo
c
c --------- get the new boundary shape
c           at t = t_stage3 
c
         t_bndy = t_stage3 - t_zero
c
c        write(nprt, 1010) t_bndy, t_stage3, t_zero
c1010    format(' 1010: new mesh',/,
c    +          ' t_bndy = ',e15.6,
c    +          ' t_stage3 = ',e15.6,' t_zero = ',e15.6)
c
         if(i3d_surf .eq. 0) then
            call l_bndy(t_bndy)
         elseif(i3d_surf .eq. 1) then
            call get_surf(t_bndy)
         elseif(i3d_surf .eq. 2) then
            call get_surf_gabls(t_bndy)
         elseif(i3d_surf .eq. 3) then
            call get_surf_tank(t_bndy)
         endif
c
c -------- initial guess for stretching factor
c
         z_gues = 1.1
c
         do j=iys,iye
         do i=1,nnx
            if(iz_space == 1) then
               call vgrid(zw1,zi,zl-bndy(i,j),z_gues,nnz,
     +                    ztemp(0),l_root,l_debug)
            elseif(iz_space == 2) then
               z_first = zw1*(1.0 - bndy(i,j)/zl)
               call vgrid(z_first,zi,zl-bndy(i,j),z_gues,nnz,
     +                    ztemp(0),l_root,l_debug)
            elseif(iz_space == 3) then
               call exp_grid(bndy(i,j),zl,z(0),ztemp(0),nnz,a_exp_grd)
            elseif(iz_space == 4) then
               call exp_grid2(bndy(i,j),zl,z(0),ztemp(0),nnz,a_exp_grd2)
            elseif(iz_space == 5) then
               call algeb_grid(bndy(i,j),zl,z(0),ztemp(0),nnz,a_decay)
            else
               call cgrid(zl-bndy(i,j),nnz,ztemp(0))
            endif
            do k=izs-1,ize+1
               zgrid_w(i,j,k,3) = ztemp(k) + bndy(i,j)
            enddo
            do k=izs,ize+1
               zgrid_u(i,j,k) = bndy(i,j) + 0.5*(ztemp(k) + ztemp(k-1))
            enddo
            if(izs == 1) then
               zgrid_u(i,j,izs-1) = 2.0*zgrid_w(i,j,izs-1,3) - 
     +                              zgrid_u(i,j,izs)
            else
               zgrid_u(i,j,izs-1) = bndy(i,j) + 
     +                              0.5*(ztemp(izs-1) + ztemp(izs-2))
            endif
c
c --------- distance off the surface (every processor)
c
            z1b_3(i,j)    = 0.5*(ztemp(1) + ztemp(0))
            bndy_t(i,j,3) = bndy(i,j)
            hdot_t(i,j,3) = hdot(i,j)
         enddo
         enddo
c
c        j = iys
c        k = 1
c        write(nprt,6501) (i, bndy(i,j), zgrid_w(i,j,k,3), 
c    +                     z1b(i,j),z1b_2(i,j),
c    +                     z1b_3(i,j),i=1,nnx)
c6501    format(' 6501 new mesh:',/,
c    + ' i ',5x,' bndy ',5x,' zw(1)',5x,' z1b',5x,
c    + ' z2b ',5x,' z3b',/,(i5,5e15.6))
c
c ------ generate metric components at cell centers
c        set metric components outside domain = to boundary values
c
        do k=izs,ize+1
           do j=iys,iye
           do i=1,nnx
              gm3(i,j,k,1) = (zgrid_w(i,j,k,3) - zgrid_w(i,j,k-1,3))*
     +                       dzw_i(k)
           enddo
           enddo
        enddo
c
c ---------- pass the 1/J at ize
c            to the processor above at level izs-1
c
      nb = myid - ncpu_s
      nt = myid + ncpu_s
      if(iss .eq. 0) then
         nb = mpi_proc_null
      endif
      if(ise .eq. numprocs-1) then
         nt = mpi_proc_null
      endif
      nsend = nnx*(iye + 1 - iys)
      nrecv = nsend
      do j=iys,iye
      do i=1,nnx
         fs(i,j) = gm3(i,j,ize,1)
      enddo
      enddo
      call mpi_sendrecv(
     +     fs(1,iys),nsend,mpi_real8,nt,2,
     +     fr(1,iys),nrecv,mpi_real8,nb,2,
     +     mpi_comm_world,istatus,ierr)
      if(iss .ne. 0) then
         do j=iys,iye
         do i=1,nnx
            gm3(i,j,izs-1,1) = fr(i,j)
         enddo
         enddo
      else
         do j=iys,iye
         do i=1,nnx
            gm3(i,j,izs-1,1) = gm3(i,j,izs,1)
         enddo
         enddo
      endif
c
c ----- compute grid speed gm2(.,.,.,5) in sr. grid_speed
c
      do k=izs-1,ize+1
         do j=iys,iye
         do i=1,nnx
            gm3(i,j,k,4) = 1.0/gm3(i,j,k,1)
            fnt1(i,j,k) = zgrid_u(i,j,k)
         enddo
         enddo
         call xderivp(fnt1(1,iys,k),trigx(1,1),xk(1),nnx,iys,iye)
         do j=iys,iye
         do i=1,nnx
            gm3(i,j,k,2) = -fnt1(i,j,k)*gm3(i,j,k,4)
         enddo
         enddo
      enddo
c
      do k=izs-1,ize+1
         do j=iys,iye
         do i=1,nnx
            fnt1(i,j,k) = zgrid_u(i,j,k)
         enddo
         enddo
      enddo
      call yd_mpi(fnt1(1,iys,izs-1),trigx(1,2),yk(1),
     +            nnx,nny,ixs,ixe,ix_s,ix_e,
     +            iys,iye,iy_s,iy_e,izs-1,ize+1,myid,ncpu_s,numprocs)
      do k=izs-1,ize+1
         do j=iys,iye
         do i=1,nnx
            gm3(i,j,k,3) = -fnt1(i,j,k)*gm3(i,j,k,4)
         enddo
         enddo
      enddo
c
      return
      end
      subroutine start_mesh(it,istage)
c
c ---------- case with moving mesh
c            initialize results at time step t_stage2
c
      use pars
      use fields
      use fftwk
      use con_data
      use con_stats
      include 'mpif.h'
      logical there
      real fs(nnx,iys:iye), fr(nnx,iys:iye)
      integer istatus(mpi_status_size)
c
      real ztemp(0:nnz+2), fnt1(nnx,iys:iye,izs-1:ize+1)
c
c ------------ metric definitions
c
c     gm2(.,.,.,1)  = z_zeta = 1/J
c     gm2(.,.,.,2)  = zeta_x = - z_xi*J
c     gm2(.,.,.,3)  = zeta_y = - z_eta*J
c     gm2(.,.,.,4)  = zeta_z = 1/z_zeta = J
c     gm2(.,.,.,5)  = z_t = grid speed; zeta_t = - z_t*J
c
c --------- update the metrics [note gm2(.,.,.,5) = 0]
c
      do l=1,5
         do k=izs-1,ize+1
         do j=iys,iye
         do i=1,nnx
            gm2(i,j,k,l)  = gm(i,j,k,l)
         enddo
         enddo
         enddo
      enddo
c
      do j=iys,iye
      do i=1,nnx
         z1b_2(i,j)    = z1b(i,j)
         bndy_t(i,j,2) = bndy_t(i,j,1)
         hdot_t(i,j,2) = hdot_t(i,j,1)
      enddo
      enddo
c
c --------- get the new boundary shape
c           at t = t_stage2 
c
         t_bndy = t_stage2 - t_zero
c
         if(i3d_surf .eq. 0) then
            call l_bndy(t_bndy)
         elseif(i3d_surf .eq. 1) then
            call get_surf(t_bndy)
         elseif(i3d_surf .eq. 2) then
            call get_surf_gabls(t_bndy)
         elseif(i3d_surf .eq. 3) then
            call get_surf_tank(t_bndy)
         endif
c
c -------- initial guess for stretching factor
c
         z_gues = 1.1
c
         do j=iys,iye
         do i=1,nnx
            if(iz_space == 1) then
               call vgrid(zw1,zi,zl-bndy(i,j),z_gues,nnz,
     +                    ztemp(0),l_root,l_debug)
            elseif(iz_space == 2) then
               z_first = zw1*(1.0 - bndy(i,j)/zl)
               call vgrid(z_first,zi,zl-bndy(i,j),z_gues,nnz,
     +                    ztemp(0),l_root,l_debug)
            elseif(iz_space == 3) then
               call exp_grid(bndy(i,j),zl,z(0),ztemp(0),nnz,a_exp_grd)
            elseif(iz_space == 4) then
               call exp_grid2(bndy(i,j),zl,z(0),ztemp(0),nnz,a_exp_grd2)
            elseif(iz_space == 5) then
               call algeb_grid(bndy(i,j),zl,z(0),ztemp(0),nnz,a_decay)
            else
               call cgrid(zl-bndy(i,j),nnz,ztemp(0))
            endif
            do k=izs-1,ize+1
               zgrid_w(i,j,k,3) = ztemp(k) + bndy(i,j)
            enddo
            do k=izs,ize+1
               zgrid_u(i,j,k) = bndy(i,j) + 0.5*(ztemp(k) + ztemp(k-1))
            enddo
            if(izs == 1) then
               zgrid_u(i,j,izs-1) = 2.0*zgrid_w(i,j,izs-1,3) - 
     +                              zgrid_u(i,j,izs)
            else
               zgrid_u(i,j,izs-1) = bndy(i,j) + 
     +                              0.5*(ztemp(izs-1) + ztemp(izs-2))
            endif
c
c --------- distance off the surface (every processor)
c
            z1b_3(i,j)    =  0.5*(ztemp(1) + ztemp(0))
            bndy_t(i,j,3) =  bndy(i,j)
            hdot_t(i,j,3) =  hdot(i,j)
         enddo
         enddo
c
c ------ generate metric components at cell centers
c        set metric components outside domain = to boundary values
c
        do k=izs,ize+1
           do j=iys,iye
           do i=1,nnx
              gm3(i,j,k,1) = (zgrid_w(i,j,k,3) - zgrid_w(i,j,k-1,3))*
     +                       dzw_i(k)
           enddo
           enddo
        enddo
c
c ---------- pass the 1/J at ize
c            to the processor above at level izs-1
c
      nb = myid - ncpu_s
      nt = myid + ncpu_s
      if(iss .eq. 0) then
         nb = mpi_proc_null
      endif
      if(ise .eq. numprocs-1) then
         nt = mpi_proc_null
      endif
      nsend = nnx*(iye + 1 - iys)
      nrecv = nsend
      do j=iys,iye
      do i=1,nnx
         fs(i,j) = gm3(i,j,ize,1)
      enddo
      enddo
      call mpi_sendrecv(
     +     fs(1,iys),nsend,mpi_real8,nt,2,
     +     fr(1,iys),nrecv,mpi_real8,nb,2,
     +     mpi_comm_world,istatus,ierr)
      if(iss .ne. 0) then
         do j=iys,iye
         do i=1,nnx
            gm3(i,j,izs-1,1) = fr(i,j)
         enddo
         enddo
      else
         do j=iys,iye
         do i=1,nnx
            gm3(i,j,izs-1,1) = gm3(i,j,izs,1)
         enddo
         enddo
      endif
c
c ----- compute grid speed gm2(.,.,.,5) in sr. grid_speed
c
      do k=izs-1,ize+1
         do j=iys,iye
         do i=1,nnx
            gm3(i,j,k,4) = 1.0/gm3(i,j,k,1)
            fnt1(i,j,k) = zgrid_u(i,j,k)
         enddo
         enddo
         call xderivp(fnt1(1,iys,k),trigx(1,1),xk(1),nnx,iys,iye)
         do j=iys,iye
         do i=1,nnx
            gm3(i,j,k,2) = -fnt1(i,j,k)*gm3(i,j,k,4)
         enddo
         enddo
      enddo
c
      do k=izs-1,ize+1
         do j=iys,iye
         do i=1,nnx
            fnt1(i,j,k) = zgrid_u(i,j,k)
         enddo
         enddo
      enddo
      call yd_mpi(fnt1(1,iys,izs-1),trigx(1,2),yk(1),
     +            nnx,nny,ixs,ixe,ix_s,ix_e,
     +            iys,iye,iy_s,iy_e,izs-1,ize+1,myid,ncpu_s,numprocs)
      do k=izs-1,ize+1
         do j=iys,iye
         do i=1,nnx
            gm3(i,j,k,3) = -fnt1(i,j,k)*gm3(i,j,k,4)
         enddo
         enddo
      enddo
c
      return
      end
      subroutine grid_speed(it,istage)
c
c ---------- get grid speeds for the mesh at t = t_stage
c
      use pars
      use fields
      use fftwk
      use con_data
      use con_stats
      real fs(nnx,iys:iye), fr(nnx,iys:iye), rh(nnz)
      real gt(0:nnz+1,iys:iye,mxs:mxe)
      include 'mpif.h'
      integer istatus(mpi_status_size)
c
      if(istage .le. 2) then
         dtgama_2 = dt*gama(istage+1)
         dtzeta_2 = dt*zetas(istage+1)
      else
         dtgama_2 = dt1*gama(istage-2)
         dtzeta_2 = dt1*zetas(istage-2)
      endif
c
c ------- get the grid speed at t = t_stage
c
      gami = 1.0/dtgama_2
c
      do k=izs,ize
         do j=iys,iye
         do i=1,nnx
            gm2(i,j,k,5) = dzw(k)*gami*(gm3(i,j,k,1) - gm2(i,j,k,1) -
     +                       dtzeta_2*rj(i,j,k))
         enddo
         enddo
      enddo
      call xtoz_trans(gm2(1,iys,izs-1,5),gt,nnx,nnz,mxs,mxe,mx_s,mx_e,
     +                iys,iye,izs,ize,iz_s,iz_e,myid,ncpu_s,
     +                numprocs)
c
c ---------- integrate from bottom up to find grid speeds
c            using surface value as boundary condition
c            hdot comes from boundary routine
c
      do i=mxs,mxe
      do j=iys,iye
         do k=1,nnz
            rh(k) = gt(k,j,i)
         enddo
         gt(0,j,i) = hdot_t(i,j,2)
         do k=1,nnz
            gt(k,j,i) = rh(k) + gt(k-1,j,i)
         enddo
         gt(nnz+1,j,i) = gt(nnz,j,i)
      enddo
      enddo
c
c --------- transpose back defining ghost point values [izs-1,ize+1]
c           surface value [izs-1] /= value at [izs]
c           with non-uniform spacing of first gridline.
c
      call ztox_trans(gt,gm2(1,iys,izs-1,5),nnx,nnz,mxs,mxe,mx_s,mx_e,
     +                iys,iye,izs,ize,iz_s,iz_e,myid,ncpu_s,
     +                numprocs)
c
c ------- get the new rhs of the 1/J equation 
c
      do k=izs,ize
         do j=iys,iye
         do i=1,nnx
            rj(i,j,k) = (gm2(i,j,k,5) - gm2(i,j,k-1,5))*dzw_i(k)
         enddo
         enddo
      enddo
c
c ---------- determine boundary speeds at t = t_stage
c            for use in psolver
c
      if(iss .eq. 0) then
         k = 0
         do j=iys,iye
         do i=1,nnx
            wfbc(i,j,3) = gm2(i,j,k,5)
         enddo
         enddo
      endif
c
      if(ise .eq. numprocs-1) then
         k = nnz
         do j=iys,iye
         do i=1,nnx
            wfbc(i,j,4) = gm2(i,j,k,5)
         enddo
         enddo
      endif
c
      return
      end
      subroutine algeb_grid(h,zl,zeta,zw,nz,alp)
c
c ----------- algebraic mapping with grid decay.
c             nicely maps boundary shape as function of(x,y)
c             on to computational coordinates. Use a_decay (alp)
c             to control how fast bumps decay with height.
c             Large values cause non-uniform spacing of
c             first grid point. see hres test code
c
      real zeta(0:nz+1), zw(0:nz+1)
c
      do i=0,nz
         zw(i) = zeta(i) + h*(1.0 - zeta(i)/zl)**alp
      enddo
      zw(nz+1) = zw(nz) + (zw(nz) - zw(nz-1))
c
c --------- fix to match rest of code
c
      do i=0,nz+1
         zw(i) = zw(i) - h
      enddo
c
      return
      end
      subroutine exp_grid(h,zl,zeta,zw,nz,alp)
c
c ----------- simple decaying exponential grid
c
      real zeta(0:nz+1), zw(0:nz+1)
c
c --------- choose alp to match physical problem
c
c     alp = 0.017
c     alp = 0.020
c
c ----------- tank simulations
c
c     alp = 66.67
c     alp = 50.00
c
      do i=0,nz
         zw(i) = zeta(i) + h*exp(-alp*zeta(i))
      enddo
c     zw(nz)   = zeta(nz)
      zw(nz+1) = zw(nz) + (zw(nz) - zw(nz-1))
c
c --------- fix to match rest of code
c
      do i=0,nz+1
         zw(i) = zw(i) - h
      enddo
c
      return
      end
      subroutine exp_grid2(h,zl,zeta,zw,nz,alp)
c
c ----------- simple decaying exponential grid
c             but with first grid z(1) = zeta(1)
c             works best to pick box height 
c             zl(code) = zl(desired) + zeta(1)
c             otherwise top of box in physical space
c             will be shorter by first grid point off the
c             surface
c
      real zeta(0:nz+1), zw(0:nz+1)
c
c     alp = 0.020
c     alp = 0.030
c     alp = 0.017
c     alp = 0.00005
c     alp = 0.00010
c
      zw(0) = h
      do i=1,nz
         d_zeta = zeta(i) - zeta(1)
         zw(i) = d_zeta + (h + zeta(1))*exp(-alp*d_zeta**2)
      enddo
c     zw(nz)   = zeta(nz)
      zw(nz+1) = zw(nz) + (zw(nz) - zw(nz-1))
c
c --------- fix to match rest of code
c
      do i=0,nz+1
         zw(i) = zw(i) - h
      enddo
c
      return
      end
      subroutine vgrid(z1,zi,zl,z_gues,nnz,z,l_root,ldebug)
c
c ------ iterate sufficiently so that z(nnz) = zl (use r8)
c
      real z(0:nnz+1)
      logical l_root, l_debug
      data ig_max /500/
      save ig_max
c
c ----------------- build grid up to zi first
c
      z_frst = z1
      z_cntr = zl
      n_pbl  = nnz
      z_fac1 = z_cntr/z_frst
      z_fac2 = 1.0/float(nnz)
      z_fac  = z_gues
      knt    = 0
      tol    = 1.0e-10
   10 continue
        knt = knt + 1
        z_facn = (z_fac1*(z_fac - 1.0) + 1.0)**z_fac2
        test   = abs(1.0 - z_facn/z_fac)
        if(knt .gt. ig_max) then
            if(l_root) write(6,9000) z_fac, z_facn, knt
 9000       format(' Cannot find stretching factor',/,
     +             ' z_fac = ',e15.6,' z_facn = ',e15.6,' knt = ',i3)
            stop
        endif
        z_fac = z_facn
        if(test .gt. tol) go to 10
c
c     if(l_root) write(6,9100) z_fac, z_cntr, z1, knt
c9100 format(' Stretching factor = ',e15.6,/,
c    +       ' Match point       = ',e15.6,/,
c    +       ' First z           = ',e15.6,/,
c    +       ' Number of iters   = ',i4)
      z(1) = z_frst
      do iz=2,nnz
         z(iz) = z_frst*(z_fac**(float(iz)) - 1.0)/(z_fac - 1.0)
      enddo
      z(nnz)   = zl
      z(0)     = 0.0
      z(nnz+1) = z(nnz) + (z(nnz) - z(nnz-1))
c
      return
      end
      subroutine get_dz
c
c --------------- compute spacing for given vertical
c                 point distribution
c
      use pars
      use fields
      use con_data
      use con_stats
      include 'mpif.h'
c
      do iz=1,nnz+1
         dzw(iz) = z(iz) - z(iz-1)
      enddo
      dzw(0)     = dzw(1)
      dzw(nnz+2) = dzw(nnz+1)
      do iz=0,nnz+2
         dzw_i(iz) = 1.0/dzw(iz)
      enddo
c
c ------------ build weights for vertical interpolation
c              of a centered variable to a wf-level
c
      do iz=0,nnz+1
         weit(iz)  = dzw(iz)/(dzw(iz) + dzw(iz+1))
         weitm(iz) = 1.0 - weit(iz)
      enddo
c
c ------------ build z grid for u points
c
      dzovr2 = dz*0.5
      do iz=1,nnz+1
         zz(iz) = 0.5*(z(iz) + z(iz-1))
      enddo
      zz(0) = - zz(1)
      do iz=1,nnz+1
         dzu(iz) = zz(iz) - zz(iz-1)
      enddo
      dzu(0)     = dzu(1)
      dzu(nnz+2) = dzu(nnz+1)
      do iz=0,nnz+2
         dzu_i(iz) = 1.0/dzu(iz)
      enddo
c
      return
      end
      subroutine vgrid_channel(z1,zi,zl,nnz,z,l_root,ldebug)
c
      real z(0:nnz+1)
      integer :: zidx
      logical l_root, l_debug
c
c ----------------- build grid up to zi first
c
      z_frst = z1
      z_cntr = zi*0.5
      n_pbl  = nnz
c     n_pbl  = (5*nnz)/8
      z_fac1 = z_cntr/z_frst
      z_fac2 = 1.0/float(n_pbl/2)
      z_fac  = 1.1
      knt = 0
      tol = 0.00001
   10 continue
        knt = knt + 1
        z_facn = (z_fac1*(z_fac - 1.0) + 1.0)**z_fac2
        test   = abs(1.0 - z_facn/z_fac)
        if(knt .gt. 50) then
            if(l_root) write(6,9000) z_fac, z_facn, knt
 9000       format(' Cannot find stretching factor',/,
     +             ' z_fac = ',e15.6,' z_facn = ',e15.6,' knt = ',i3)
            stop
        endif
        z_fac = z_facn
        if(test .gt. tol) go to 10
      if(l_root) write(6,9100) z_fac, z_cntr, z1, knt
 9100 format(' Stretching factor = ',e15.6,/,
     +       ' Match point       = ',e15.6,/,
     +       ' First z           = ',e15.6,/,
     +       ' Number of iters   = ',i4)
      z(1) = z_frst
      do iz=2,n_pbl/2-1
         z(iz) = z_frst*(z_fac**(float(iz)) - 1.0)/(z_fac - 1.0)
      enddo
      z(n_pbl/2) = z_cntr
      do iz=1,n_pbl/2 - 1
         z(n_pbl-iz) = zi - z(iz)
      enddo
      z(n_pbl) = zi
      z(0)   = 0.0
c
      if(l_root) write(6,5300) n_pbl
 5300 format(' n_pbl = ',i4)
c
c -------------- build grid from zi on up
!     For the channel, zi represents the channel centerline
!     Want the mesh to be a mirror image across this:
c
!      zidx = 1
!      do iz=n_pbl+1,nnz
!         z(iz) = zi + (zi - z(n_pbl-zidx))
!         zidx = zidx + 1
!      enddo
      z(nnz+1) = z(nnz) + (z(nnz) - z(nnz-1))
c
      return
      end subroutine vgrid_channel
      subroutine random
c
c ----------- geostrophic winds designed for comparison case
c
      use pars
      use fields
      use fftwk
      use con_data
      use con_stats
      use particles
      real psi(nnx,iys:iye), psix(nnx,iys:iye),
     +     psiy(nnx,iys:iye,izs:izs), uxx(nnx,iys:iye),
     +     vyy(nnx,iys:iye,izs:izs)

      !Initialize partcount to 0:
      partcount = 0.0
      partcount_t = 0.0
      vpsum = 0.0
      vpsum_t = 0.0
      vpsqrsum = 0.0
      vpsqrsum_t = 0.0
      upwp_t = 0.0
      upwp = 0.0
      Tpsum = 0.0
      Tpsum_t = 0.0
      Tpsqrsum = 0.0
      Tpsqrsum_t = 0.0
      wpTpsum = 0.0
      wpTpsum_t = 0.0
      partsrc = 0.0
      partsrc_t = 0.0
      partTsrc = 0.0
      partTsrc_t = 0.0

c
c ------------ note set nmatch in sr. iso so that
c              it is compatible with conditions here
c
      do iz=1,nnz
c        ug(iz)   = ugcont*(zz(iz)/zl)
         ug(iz)   = ugcont
         vg(iz)   = vgcont
         divz(iz) = 0.0
      enddo
c
CHECK
c
c     izi = (50*nnz)/100
c
      izi = 92
      zi  = z(izi)
c
c     z_lower = zi - 50.0
c     t_lower = 300.0
c     z_upper = zi + 50.0
c     t_upper = 308.0
c     slope   = (t_upper - t_lower)/(z_upper - z_lower)
c
c -------- alternate strategy for specifying theta
c
      z_lower = 300.0
      t_lower = 290.0
c
      do iz=izs,ize
         do iy=iys,iye
         do ix=1,nnx
            u(ix,iy,iz) = ugcont-ugal
c           u(ix,iy,iz) = ug(iz) - ugal
            v(ix,iy,iz) = vgcont
            w(ix,iy,iz) = 0.0
            e(ix,iy,iz) = 0.0
         enddo
         enddo
         do iy=iys,iye
         do ix=1,nnx
            if(zgrid_w(ix,iy,iz,1) .le. z_lower) then
              t(ix,iy,1,iz) = t_lower
            else
              t(ix,iy,1,iz) = t_lower + 
     +                        (zgrid_u(ix,iy,iz+1) - z_lower)*dtdzf(1)
            endif
         enddo
         enddo
         do iy=iys,iye
         do ix=1,nnx
            w(ix,iy,iz)   = 0.
            r1(ix,iy,iz)  = 0.
            r2(ix,iy,iz)  = 0.
            r3(ix,iy,iz)  = 0.
            r4(ix,iy,1,iz)= 0.
            r5(ix,iy,iz)  = 0.
            p(ix,iy,iz)   = 0.
            rj(ix,iy,iz)  = 0.
c
c ---------- flux velocities simple guess
c
c           uf(ix,iy,iz)  = u(ix,iy,iz)*gm(ix,iy,iz,1)
c           vf(ix,iy,iz)  = v(ix,iy,iz)*gm(ix,iy,iz,1)
c           wf(ix,iy,iz)  = u(ix,iy,iz)*gm(ix,iy,iz,2) + 
c    +                      v(ix,iy,iz)*gm(ix,iy,iz,3)
            uf(ix,iy,iz)  = u(ix,iy,iz)
            vf(ix,iy,iz)  = v(ix,iy,iz)
            wf(ix,iy,iz)  = 0.0
         enddo 
         enddo 
      enddo
c
c ------------- set initial random field to be
c               divergence free
c
      idum = -1 - myid
      do iz=izs,ize
c
c ----------- ampv and ampt are max amplitudes of random 
c             velocity and temperature fields
c             make sure ampv is set if free convection so
c             that we have motions at first time step
c
         ampv = 0.0
         ampt = 0.10
c  
c ------- simple random field scaled between -0.5 and 0.5
c
         sum_psi = 0.0
         do iy=iys,iye
         do ix=1,nnx
            psi(ix,iy) = ran1(idum)
            sum_psi = sum_psi + psi(ix,iy)
         enddo
         enddo
         sum_psi = sum_psi*fnxy
         call mpi_sum_xy(sum_psi,myid,iss,ise,1)
         do iy=iys,iye
         do ix=1,nnx
            psi(ix,iy) = psi(ix,iy) - sum_psi
            psix(ix,iy)     = psi(ix,iy)
            psiy(ix,iy,izs) = psi(ix,iy)
         enddo
         enddo
         call xderivp(psix(1,iys),trigx(1,1),xk(1),nnx,iys,iye)
         call yd_mpi(psiy(1,iys,izs),trigx(1,2),yk(1),
     +           nnx,nny,ixs,ixe,ix_s,ix_e,
     +           iys,iye,iy_s,iy_e,izs,izs,myid,ncpu_s,numprocs)
         vmaxx = 0.0
         do iy=iys,iye
         do ix=1,nnx
            vmag = sqrt(psix(ix,iy)**2 + psiy(ix,iy,izs)**2)
            if(vmag .gt. vmaxx) vmaxx = vmag
         enddo
         enddo
         facv = ampv/vmaxx
c
         if (z(iz) .le. 50.0) then
         do iy=iys,iye
         do ix=1,nnx
            u(ix,iy,iz)   = u(ix,iy,iz) - psiy(ix,iy,izs)*facv
            v(ix,iy,iz)   = v(ix,iy,iz) + psix(ix,iy)*facv
            t(ix,iy,1,iz) = t(ix,iy,1,iz) + psi(ix,iy)*ampt
         enddo
         enddo
         endif
c
         if(z(iz) .le. 250.0) then
         do iy=iys,iye
         do ix=1,nnx
            e(ix,iy,iz) = 0.4*(1.0 - z(iz)/250.0)**3
         enddo
         enddo
         endif
c
c ---------- check divergence of initial field
c
         do iy=iys,iye
         do ix=1,nnx
            uxx(ix,iy)     = uf(ix,iy,iz)
            vyy(ix,iy,izs) = vf(ix,iy,iz)
         enddo
         enddo
         call xderivp(uxx(1,iys),trigx(1,1),xk(1),nnx,iys,iye)
         call yd_mpi(vyy(1,iys,izs),trigx(1,2),yk(1),
     +           nnx,nny,ixs,ixe,ix_s,ix_e,
     +           iys,iye,iy_s,iy_e,izs,izs,myid,ncpu_s,numprocs)
         do iy=iys,iye
         do ix=1,nnx
            divz(iz) = divz(iz) + (uxx(ix,iy) + vyy(ix,iy,izs))**2
         enddo
         enddo
         divz(iz) = divz(iz)*fnxy
c
c -------- end z loop
c
      enddo
c
      call mpi_sum_z(divz(1),i_root,myid,nnz,1)
c
      write(nprt,6000)
 6000 format(' check of divergence for initial state',/,
     +         ' iz ',5x,' divergence')
      write(nprt,6100) (iz,divz(iz),iz=izs,ize)
 6100 format(i5,e15.6)
c
c ------------ fix for baroclinic and subsidence effects !!
c
c     do iz=izs,ize
c        ug(iz)=ugcont
c        vg(iz)=vgcont
c        if (.not.(ibrcl.eq.1)) go to 19988
c        if (.not.(iz.le.izi)) go to 19987
c        ug(iz)=0.
c        vg(iz)=0.
c 19987    continue
c 19988    continue
c        zz2=zz(iz)
c        wls(iz)=-divgls*zz2
c        if (.not.(iz.eq.1)) go to 19986
c        do ix=1,nnx
c        uls(ix)=divgls*(dx*float(ix-1)-xl*.5)
c        enddo
c     enddo
c     write(nprt,9)(uls(ix),ix=1,nnx)
c  9  format(1x,8e12.3)
c 19986 continue
c
      return
      end
      subroutine random_wt
c
c ----------- random conditions for a wind tunnel flow
c             made dimensionless by u_* and wavelength
c
      use pars
      use fields
      use fftwk
      use con_data
      use con_stats
      real psi(nnx,iys:iye), psix(nnx,iys:iye),
     +     psiy(nnx,iys:iye,izs:izs), uxx(nnx,iys:iye),
     +     vyy(nnx,iys:iye,izs:izs)
c
c ------------ note set nmatch in sr. iso so that
c              it is compatible with conditions here
c
      do iz=1,nnz
c        ug(iz)   = ugcont*(zz(iz)/zl)
         ug(iz)   = ugcont
         vg(iz)   = vgcont
         divz(iz) = 0.0
      enddo
c
CHECK
c
c     izi = (50*nnz)/100
c
      izi = 100
      zi  = z(izi)
c
      ustar_gues = 1.0
      ustar_vk   = ustar_gues/vk
      do iz=izs,ize
         do iy=iys,iye
         do ix=1,nnx
!            u(ix,iy,iz) = ustar_vk*
!     +                    alog((zgrid_u(ix,iy,iz) - bndy(ix,iy))/zo)
            u(ix,iy,iz) = ugcont
            v(ix,iy,iz) = 0.0
            w(ix,iy,iz) = 0.0
            e(ix,iy,iz) = 0.0
         enddo
         enddo
         do iy=iys,iye
         do ix=1,nnx
            t(ix,iy,1,iz) = tsfcc(1)
         enddo
         enddo
         do iy=iys,iye
         do ix=1,nnx
            w(ix,iy,iz)   = 0.
            r1(ix,iy,iz)  = 0.
            r2(ix,iy,iz)  = 0.
            r3(ix,iy,iz)  = 0.
            r4(ix,iy,1,iz)= 0.
            r5(ix,iy,iz)  = 0.
            p(ix,iy,iz)   = 0.
            rj(ix,iy,iz)  = 0.
c
c ---------- flux velocities simple guess
c
c           uf(ix,iy,iz)  = u(ix,iy,iz)*gm(ix,iy,iz,1)
c           vf(ix,iy,iz)  = v(ix,iy,iz)*gm(ix,iy,iz,1)
c           wf(ix,iy,iz)  = u(ix,iy,iz)*gm(ix,iy,iz,2) + 
c    +                      v(ix,iy,iz)*gm(ix,iy,iz,3)
            uf(ix,iy,iz)  = u(ix,iy,iz)
            vf(ix,iy,iz)  = v(ix,iy,iz)
            wf(ix,iy,iz)  = 0.0
         enddo 
         enddo 
      enddo
c
c ------------- set initial random field to be
c               divergence free
c
      idum = -1 - myid
      do iz=izs,ize
c
c ----------- ampv and ampt are max amplitudes of random 
c             velocity and temperature fields
c             make sure ampv is set if free convection so
c             that we have motions at first time step
c             made dimensionless by ustar
c
         ampv = 0.01
         ampt = 0.01
c  
c ------- simple random field scaled between -0.5 and 0.5
c
         sum_psi = 0.0
         do iy=iys,iye
         do ix=1,nnx
            psi(ix,iy) = ran1(idum)
            sum_psi = sum_psi + psi(ix,iy)
         enddo
         enddo
         sum_psi = sum_psi*fnxy
         call mpi_sum_xy(sum_psi,myid,iss,ise,1)
         do iy=iys,iye
         do ix=1,nnx
            psi(ix,iy) = psi(ix,iy) - sum_psi
            psix(ix,iy)     = psi(ix,iy)
            psiy(ix,iy,izs) = psi(ix,iy)
         enddo
         enddo
         call xderivp(psix(1,iys),trigx(1,1),xk(1),nnx,iys,iye)
         call yd_mpi(psiy(1,iys,izs),trigx(1,2),yk(1),
     +           nnx,nny,ixs,ixe,ix_s,ix_e,
     +           iys,iye,iy_s,iy_e,izs,izs,myid,ncpu_s,numprocs)
         vmaxx = 0.0
         do iy=iys,iye
         do ix=1,nnx
            vmag = sqrt(psix(ix,iy)**2 + psiy(ix,iy,izs)**2)
            if(vmag .gt. vmaxx) vmaxx = vmag
         enddo
         enddo
         facv = ampv/vmaxx
c
         if (z(iz) .le. 0.2) then
         do iy=iys,iye
         do ix=1,nnx
            u(ix,iy,iz)   = u(ix,iy,iz) - psiy(ix,iy,izs)*facv
            v(ix,iy,iz)   = v(ix,iy,iz) + psix(ix,iy)*facv
            t(ix,iy,1,iz) = t(ix,iy,1,iz) + psi(ix,iy)*ampt
         enddo
         enddo
         endif
c
         if(z(iz) .le. 0.2) then
         do iy=iys,iye
         do ix=1,nnx
c           e(ix,iy,iz) = 0.4*(1.0 - z(iz)/zl)**3
            e(ix,iy,iz) = 0.05*(1.0 - z(iz)/zl)**3
         enddo
         enddo
         endif
c
c ---------- check divergence of initial field
c
         do iy=iys,iye
         do ix=1,nnx
            uxx(ix,iy)     = uf(ix,iy,iz)
            vyy(ix,iy,izs) = vf(ix,iy,iz)
         enddo
         enddo
         call xderivp(uxx(1,iys),trigx(1,1),xk(1),nnx,iys,iye)
         call yd_mpi(vyy(1,iys,izs),trigx(1,2),yk(1),
     +           nnx,nny,ixs,ixe,ix_s,ix_e,
     +           iys,iye,iy_s,iy_e,izs,izs,myid,ncpu_s,numprocs)
         do iy=iys,iye
         do ix=1,nnx
            divz(iz) = divz(iz) + (uxx(ix,iy) + vyy(ix,iy,izs))**2
         enddo
         enddo
         divz(iz) = divz(iz)*fnxy
c
c -------- end z loop
c
      enddo
c
      call mpi_sum_z(divz(1),i_root,myid,nnz,1)
c
      write(nprt,6000)
 6000 format(' check of divergence for initial state',/,
     +         ' iz ',5x,' divergence')
      write(nprt,6100) (iz,divz(iz),iz=izs,ize)
 6100 format(i5,e15.6)
c
      return
      end
      subroutine random_f
c
c ---------- example of using given (sparse) initial 
c            sounding profiles (FIX for ncpu_s).
c            
      use pars
      use fields
      use fftwk
      use con_data
      use con_stats
      real psi(nnx,iys:iye), psix(nnx,iys:iye),
     +     psiy(nnx,iys:iye,izs:izs), uxx(nnx,iys:iye),
     +     vyy(nnx,iys:iye,izs:izs)
c
      parameter (nt=12, nz=11)
      real zg(nz), u_i(nz,nt), v_i(nz,nt), theta_i(nz,nt)
      real ui_temp(nz), vi_temp(nz), ti_temp(nz)
      real time_g(nt)
c
      data time_g /
     +  0.0000E+00,  0.3600E+04,  0.7200E+04,  0.1080E+05,  0.1440E+05,
     +  0.1800E+05,  0.2160E+05,  0.2520E+05,  0.2880E+05,  0.3240E+05,
     +  0.3600E+05,  0.3960E+05
     +/
      data zg /
     +  0.1000E+02,  0.3000E+02,  0.5500E+02,  0.9000E+02,  0.1400E+03,
     +  0.2150E+03,  0.3300E+03,  0.5000E+03,  0.7500E+03,  0.1100E+04,
     +  0.1600E+04
     +/
      data u_i /
     + -0.1510E+01, -0.1560E+01, -0.1580E+01, -0.1580E+01, -0.1560E+01,
     + -0.1530E+01, -0.1510E+01, -0.9000E+00, -0.1390E+01, -0.1220E+01,
     + -0.5100E+00,
     + -0.1090E+01, -0.1110E+01, -0.1120E+01, -0.1120E+01, -0.1030E+01,
     + -0.9900E+00, -0.9500E+00, -0.6200E+00, -0.1230E+01, -0.9400E+00,
     +  0.2800E+00,
     + -0.9100E+00, -0.9200E+00, -0.9100E+00, -0.9000E+00, -0.8800E+00,
     + -0.8400E+00, -0.8000E+00, -0.6500E+00, -0.1510E+01, -0.1070E+01,
     +  0.2400E+00,
     + -0.8900E+00, -0.8900E+00, -0.8900E+00, -0.8800E+00, -0.8700E+00,
     + -0.8500E+00, -0.8100E+00, -0.7000E+00, -0.1830E+01, -0.8400E+00,
     +  0.3500E+00,
     + -0.1250E+01, -0.1260E+01, -0.1260E+01, -0.1250E+01, -0.1240E+01,
     + -0.1220E+01, -0.1160E+01, -0.8800E+00, -0.1980E+01, -0.1900E+00,
     +  0.7500E+00,
     + -0.1800E+01, -0.1810E+01, -0.1820E+01, -0.1820E+01, -0.1800E+01,
     + -0.1780E+01, -0.1710E+01, -0.1150E+01, -0.1960E+01,  0.3900E+00,
     +  0.9200E+00,
     + -0.2110E+01, -0.2130E+01, -0.2140E+01, -0.2140E+01, -0.2130E+01,
     + -0.2110E+01, -0.2050E+01, -0.9300E+00, -0.1400E+01,  0.8800E+00,
     +  0.9600E+00,
     + -0.2250E+01, -0.2280E+01, -0.2290E+01, -0.2300E+01, -0.2290E+01,
     + -0.2260E+01, -0.2070E+01, -0.4000E-01, -0.1600E+00,  0.1440E+01,
     +  0.1190E+01,
     + -0.2160E+01, -0.2200E+01, -0.2220E+01, -0.2220E+01, -0.2220E+01,
     + -0.2190E+01, -0.1610E+01,  0.1470E+01,  0.1420E+01,  0.2050E+01,
     +  0.1610E+01,
     + -0.2230E+01, -0.2270E+01, -0.2290E+01, -0.2300E+01, -0.2300E+01,
     + -0.2260E+01, -0.1350E+01,  0.2480E+01,  0.2380E+01,  0.2320E+01,
     +  0.1740E+01,
     + -0.1890E+01, -0.1930E+01, -0.1950E+01, -0.1950E+01, -0.1940E+01,
     + -0.1890E+01, -0.1120E+01,  0.3010E+01,  0.3030E+01,  0.2800E+01,
     +  0.2000E+01,
     + -0.1210E+01, -0.1230E+01, -0.1240E+01, -0.1230E+01, -0.1210E+01,
     + -0.1140E+01, -0.4600E+00,  0.3320E+01,  0.3510E+01,  0.3420E+01,
     +  0.2340E+01
     +/
      data v_i /
     +  0.4800E+00,  0.5100E+00,  0.5300E+00,  0.5700E+00,  0.6900E+00,
     +  0.7300E+00,  0.7600E+00,  0.1410E+01, -0.4200E+00, -0.3060E+01,
     + -0.3500E+01,
     +  0.7800E+00,  0.8100E+00,  0.8400E+00,  0.8900E+00,  0.1060E+01,
     +  0.1110E+01,  0.1130E+01,  0.1190E+01, -0.1040E+01, -0.2900E+01,
     + -0.3440E+01,
     +  0.3000E+00,  0.3200E+00,  0.3400E+00,  0.3800E+00,  0.4800E+00,
     +  0.5300E+00,  0.5800E+00,  0.5300E+00, -0.1330E+01, -0.2040E+01,
     + -0.2830E+01,
     + -0.2700E+00, -0.2600E+00, -0.2400E+00, -0.2200E+00, -0.1800E+00,
     + -0.1300E+00, -0.5000E-01,  0.1000E+00, -0.1170E+01, -0.1100E+01,
     + -0.2370E+01,
     + -0.5500E+00, -0.5400E+00, -0.5300E+00, -0.5100E+00, -0.4800E+00,
     + -0.4100E+00, -0.2600E+00,  0.1700E+00, -0.4200E+00, -0.2200E+00,
     + -0.2080E+01,
     + -0.2700E+00, -0.2600E+00, -0.2500E+00, -0.2400E+00, -0.2100E+00,
     + -0.1600E+00, -0.1000E-01,  0.8500E+00,  0.9700E+00,  0.3500E+00,
     + -0.2250E+01,
     +  0.5300E+00,  0.5400E+00,  0.5600E+00,  0.5700E+00,  0.6000E+00,
     +  0.6500E+00,  0.7600E+00,  0.1960E+01,  0.2280E+01,  0.3600E+00,
     + -0.2590E+01,
     +  0.1590E+01,  0.1630E+01,  0.1650E+01,  0.1680E+01,  0.1720E+01,
     +  0.1780E+01,  0.2010E+01,  0.3260E+01,  0.3110E+01,  0.1600E+00,
     + -0.2580E+01,
     +  0.2560E+01,  0.2620E+01,  0.2660E+01,  0.2690E+01,  0.2740E+01,
     +  0.2830E+01,  0.3400E+01,  0.4030E+01,  0.3030E+01, -0.7000E-01,
     + -0.2320E+01,
     +  0.3500E+01,  0.3600E+01,  0.3650E+01,  0.3700E+01,  0.3750E+01,
     +  0.3860E+01,  0.4580E+01,  0.4100E+01,  0.2450E+01,  0.6000E-01,
     + -0.1770E+01,
     +  0.4500E+01,  0.4640E+01,  0.4700E+01,  0.4760E+01,  0.4830E+01,
     +  0.4930E+01,  0.5420E+01,  0.3960E+01,  0.2000E+01,  0.5000E+00,
     + -0.1150E+01,
     +  0.5290E+01,  0.5470E+01,  0.5550E+01,  0.5620E+01,  0.5690E+01,
     +  0.5790E+01,  0.6070E+01,  0.4000E+01,  0.1910E+01,  0.9700E+00,
     + -0.5600E+00
     +/
      data theta_i /
     +  0.2936E+03,  0.2936E+03,  0.2937E+03,  0.2937E+03,  0.2938E+03,
     +  0.2942E+03,  0.2948E+03,  0.2980E+03,  0.3027E+03,  0.3092E+03,
     +  0.3186E+03,
     +  0.2937E+03,  0.2937E+03,  0.2937E+03,  0.2938E+03,  0.2939E+03,
     +  0.2942E+03,  0.2946E+03,  0.2978E+03,  0.3024E+03,  0.3090E+03,
     +  0.3184E+03,
     +  0.2939E+03,  0.2939E+03,  0.2939E+03,  0.2939E+03,  0.2939E+03,
     +  0.2941E+03,  0.2944E+03,  0.2976E+03,  0.3023E+03,  0.3089E+03,
     +  0.3182E+03,
     +  0.2940E+03,  0.2939E+03,  0.2939E+03,  0.2939E+03,  0.2939E+03,
     +  0.2941E+03,  0.2943E+03,  0.2975E+03,  0.3022E+03,  0.3087E+03,
     +  0.3181E+03,
     +  0.2940E+03,  0.2940E+03,  0.2939E+03,  0.2939E+03,  0.2939E+03,
     +  0.2940E+03,  0.2942E+03,  0.2974E+03,  0.3021E+03,  0.3086E+03,
     +  0.3180E+03,
     +  0.2941E+03,  0.2940E+03,  0.2940E+03,  0.2940E+03,  0.2941E+03,
     +  0.2941E+03,  0.2941E+03,  0.2973E+03,  0.3019E+03,  0.3085E+03,
     +  0.3179E+03,
     +  0.2942E+03,  0.2942E+03,  0.2942E+03,  0.2942E+03,  0.2941E+03,
     +  0.2941E+03,  0.2941E+03,  0.2973E+03,  0.3020E+03,  0.3086E+03,
     +  0.3179E+03,
     +  0.2943E+03,  0.2943E+03,  0.2943E+03,  0.2943E+03,  0.2943E+03,
     +  0.2943E+03,  0.2943E+03,  0.2975E+03,  0.3022E+03,  0.3087E+03,
     +  0.3181E+03,
     +  0.2945E+03,  0.2945E+03,  0.2945E+03,  0.2945E+03,  0.2945E+03,
     +  0.2944E+03,  0.2946E+03,  0.2978E+03,  0.3025E+03,  0.3090E+03,
     +  0.3184E+03,
     +  0.2947E+03,  0.2947E+03,  0.2947E+03,  0.2947E+03,  0.2946E+03,
     +  0.2946E+03,  0.2949E+03,  0.2980E+03,  0.3027E+03,  0.3093E+03,
     +  0.3187E+03,
     +  0.2949E+03,  0.2949E+03,  0.2949E+03,  0.2948E+03,  0.2948E+03,
     +  0.2948E+03,  0.2950E+03,  0.2982E+03,  0.3028E+03,  0.3094E+03,
     +  0.3188E+03,
     +  0.2950E+03,  0.2950E+03,  0.2950E+03,  0.2950E+03,  0.2950E+03,
     +  0.2950E+03,  0.2950E+03,  0.2982E+03,  0.3029E+03,  0.3095E+03,
     +  0.3188E+03
     +/
c
      save time_g, zg, u_i, v_i, theta_i
c
c --------- find time location of initial profiles 
c
      call lterp(nt,time_g,t_factor,jt,jtp1,t_weit)
c
      do iz=1,nz
         ui_temp(iz) = u_i(iz,jt)*(1.0 - t_weit) +
     +                 u_i(iz,jtp1)*t_weit
         vi_temp(iz) = v_i(iz,jt)*(1.0 - t_weit) +
     +                 v_i(iz,jtp1)*t_weit
         ti_temp(iz) = theta_i(iz,jt)*(1.0 - t_weit) +
     +                 theta_i(iz,jtp1)*t_weit
      enddo
c
c ----------- interpolate vertically
c
      do iz=izs,ize
         call lterp(nz,zg,zz(iz),kk,kkp1,v_weit)
         u_temp = ui_temp(kk)*(1.0 - v_weit) +
     +            ui_temp(kkp1)*v_weit
         v_temp = vi_temp(kk)*(1.0 - v_weit) +
     +            vi_temp(kkp1)*v_weit
         theta_temp = ti_temp(kk)*(1.0 - v_weit) +
     +            ti_temp(kkp1)*v_weit
c
         do iy=iys,iye
         do ix=1,nnx
            u(ix,iy,iz)   = u_temp
            v(ix,iy,iz)   = v_temp
            t(ix,iy,1,iz) = theta_temp
            w(ix,iy,iz)   = 0.
            r1(ix,iy,iz)  = 0.
            r2(ix,iy,iz)  = 0.
            r3(ix,iy,iz)  = 0.
            r4(ix,iy,1,iz)= 0.
            r5(ix,iy,iz)  = 0.
         enddo 
         enddo 
      enddo
c
c ------------- set initial random field to be
c               divergence free
c
      idum = -1
      do iz=izs,ize
         if (iz.le.8) then
c
c ----------- ampv and ampt are max amplitudes of random 
c             velocity and temperature fields
c
         ampv = 0.5
         ampt = 0.1
c  
c ------- simple random field scaled between 0 and 1
c
         do iy=iys,iye
         do ix=1,nnx
            psi(ix,iy) = ran1(idum)
         enddo
         enddo
c
         do iy=iys,iye
         do ix=1,nnx
            psix(ix,iy) = psi(ix,iy)
            psiy(ix,iy,izs) = psi(ix,iy)
         enddo
         enddo
         call xderivp(psix(1,iys),trigx(1,1),xk(1),nnx,iys,iye)
         call yd_mpi(psiy(1,iys,izs),trigx(1,2),yk(1),
     +           nnx,nny,ixs,ixe,ix_s,ix_e,
     +           iys,iye,iy_s,iy_e,izs,izs,myid,ncpu_s,numprocs)
c
         vmaxx = 0.0
         do iy=iys,iye
         do ix=1,nnx
            vmag = sqrt(psix(ix,iy)**2 + psiy(ix,iy,izs)**2)
            if(vmag .gt. vmaxx) vmaxx = vmag
         enddo
         enddo
         facv = ampv/vmaxx
         do iy=iys,iye
         do ix=1,nnx
            u(ix,iy,iz)   = u(ix,iy,iz) - psiy(ix,iy,izs)*facv
            v(ix,iy,iz)   = v(ix,iy,iz) + psix(ix,iy)*facv
            t(ix,iy,1,iz) = t(ix,iy,1,iz) + psi(ix,iy)*ampt
            e(ix,iy,iz)   = 1.0
         enddo
         enddo
         endif
c
c ---------- check divergence of initial field
c
         do iy=iys,iye
         do ix=1,nnx
            uxx(ix,iy)     = u(ix,iy,iz)
            vyy(ix,iy,izs) = v(ix,iy,iz)
         enddo
         enddo
         call xderivp(uxx(1,iys),trigx(1,1),xk(1),nnx,iys,iye)
         call yd_mpi(vyy(1,iys,izs),trigx(1,2),yk(1),
     +           nnx,nny,ixs,ixe,ix_s,ix_e,
     +           iys,iye,iy_s,iy_e,izs,izs,myid,ncpu_s,numprocs)
         do iy=iys,iye
         do ix=1,nnx
            divz(iz) = divz(iz) + (uxx(ix,iy) + vyy(ix,iy,izs))**2
         enddo
         enddo
         divz(iz) = divz(iz)*fnxy
c
c -------- end z loop
c
      enddo
c
      call mpi_sum_z(divz(1),i_root,myid,nnz,1)
c
      write(nprt,6000)
 6000 format(' check of divergence for initial state',/,
     +         ' iz ',5x,' divergence')
      write(nprt,6100) (iz,divz(iz),iz=izs,ize)
 6100 format(i5,e15.6)
c
c ------------ fix for baroclinic and subsidence effects !!
c
c     do iz=izs,ize
c        ug(iz)=ugcont
c        vg(iz)=vgcont
c        if (.not.(ibrcl.eq.1)) go to 19988
c        if (.not.(iz.le.izi)) go to 19987
c        ug(iz)=0.
c        vg(iz)=0.
c 19987    continue
c 19988    continue
c        zz2=zz(iz)
c        wls(iz)=-divgls*zz2
c        if (.not.(iz.eq.1)) go to 19986
c        do ix=1,nnx
c        uls(ix)=divgls*(dx*float(ix-1)-xl*.5)
c        enddo
c     enddo
c     write(nprt,9)(uls(ix),ix=1,nnx)
c  9  format(1x,8e12.3)
c 19986 continue
c
      return
      end
      subroutine randoc
c
c -------- random initial conditions for an
c          ocean simulation
c
      use pars
      use fields
      use fftwk
      use con_data
      use con_stats
      real psi(nnx,iys:iye), psix(nnx,iys:iye),
     +     psiy(nnx,iys:iye,izs:izs), uxx(nnx,iys:iye),
     +     vyy(nnx,iys:iye,izs:izs)
c
      izi=(5*nnz)/20
      zi=z(izi)
      tmixed = 283.0
      do iz=izs,ize
         if (iz.le.izi) then
            do iy=iys,iye
            do ix=1,nnx
               u(ix,iy,iz)   = ugcont-ugal
               v(ix,iy,iz)   = vgcont
               w(ix,iy,iz)   = 0.0
               t(ix,iy,1,iz) = tmixed
               e(ix,iy,iz)   = 0.0
            enddo
            enddo
         endif
         if (iz.gt.izi) then
            do iy=iys,iye
            do ix=1,nnx
               u(ix,iy,iz)   = ugcont-ugal
               v(ix,iy,iz)   = vgcont
               w(ix,iy,iz)   = 0.0
               t(ix,iy,1,iz) = tmixed + dtdzf(1)*(zz(iz)-zi)
               e(ix,iy,iz)   = 0.0
            enddo
            enddo
         endif
         do iy=iys,iye
         do ix=1,nnx
            w(ix,iy,iz)    = 0.0
            r1(ix,iy,iz)   = 0.0
            r2(ix,iy,iz)   = 0.0
            r3(ix,iy,iz)   = 0.0
            r4(ix,iy,1,iz) = 0.0
            r5(ix,iy,iz)   = 0.0
         enddo
         enddo
      enddo
c
c ------------- set initial random field to be
c               divergence free
c
      idum = -1
      do iz=izs,ize
      if (iz.le.4) then
c
c ----------- ampv and ampt are max amplitudes of random 
c             velocity and temperature fields
c
         ampv = 0.01
c        ampt = 0.00
         ampt = 0.0001
c  
c ------- simple random field scaled between 0 and 1
c
         do iy=iys,iye
         do ix=1,nnx
            psi(ix,iy) = ran1(idum)
         enddo
         enddo
c
         do iy=iys,iye
         do ix=1,nnx
            psix(ix,iy) = psi(ix,iy)
            psiy(ix,iy,izs) = psi(ix,iy)
         enddo
         enddo
         call xderivp(psix(1,iys),trigx(1,1),xk(1),nnx,iys,iye)
         call yd_mpi(psiy(1,iys,izs),trigx(1,2),yk(1),
     +           nnx,nny,ixs,ixe,ix_s,ix_e,
     +           iys,iye,iy_s,iy_e,izs,izs,myid,ncpu_s,numprocs)
c
         vmaxx = 0.0
         do iy=iys,iye
         do ix=1,nnx
            vmag = sqrt(psix(ix,iy)**2 + psiy(ix,iy,izs)**2)
            if(vmag .gt. vmaxx) vmaxx = vmag
         enddo
         enddo
         facv = ampv/vmaxx
         do iy=iys,iye
         do ix=1,nnx
            u(ix,iy,iz) = u(ix,iy,iz) - psiy(ix,iy,izs)*facv
            v(ix,iy,iz) = v(ix,iy,iz) + psix(ix,iy)*facv
            t(ix,iy,1,iz) = t(ix,iy,1,iz) + psi(ix,iy)*ampt
            e(ix,iy,iz) = 0.0001
         enddo
         enddo
      endif
c
c ---------- check divergence of initial field
c
         do iy=iys,iye
         do ix=1,nnx
            uxx(ix,iy) = u(ix,iy,iz)
            vyy(ix,iy,izs) = v(ix,iy,iz)
         enddo
         enddo
         call xderivp(uxx(1,iys),trigx(1,1),xk(1),nnx,iys,iye)
         call yd_mpi(vyy(1,iys,izs),trigx(1,2),yk(1),
     +           nnx,nny,ixs,ixe,ix_s,ix_e,
     +           iys,iye,iy_s,iy_e,izs,izs,myid,ncpu_s,numprocs)
         do iy=iys,iye
         do ix=1,nnx
            divz(iz) = divz(iz) + (uxx(ix,iy) + vyy(ix,iy,izs))**2
         enddo
         enddo
         divz(iz) = divz(iz)*fnxy
c
c -------- end z loop
c
      enddo
c
      call mpi_sum_z(divz(1),i_root,myid,nnz,1)
c
      write(nprt,6000)
 6000 format(' check of divergence for initial state',/,
     +         ' iz ',5x,' divergence')
      write(nprt,6100) (iz,divz(iz),iz=izs,ize)
 6100 format(i5,e15.6)
c
      do iz=izs,ize
         ug(iz)=ugcont
         vg(iz)=vgcont
      enddo
c
      return
      end
      subroutine get_fields
c
c ----------- special routine to read just 3d fields
c             as an initial guess, easy to customize
c             if missing data, etc..
c
      use pars
      use fields
      use fftwk
      use con_data
      use con_stats
#if defined(SWAP)
      use module_byteswap
#endif
      include 'mpif.h'
c
      integer status(mpi_status_size), ierr
      integer(kind=mpi_offset_kind) :: offset, disp
      integer(kind=k8)              :: nsize, nsize2
      real, allocatable, dimension(:,:,:) :: temp
      logical there
c
      allocate(temp(nvar+4,nnx,iys:iye))
c
c ---------- input file to read from
c
c --------------------- get restart file from local directory
c                       reuse unit number
c
      close(nvel)
c
      inquire(file=path_ran,exist=there)
      if(there) then
         if(l_root) write(6,6001) path_ran
      else
         if(l_root) write(6,6005) path_ran
         stop
      endif
c
c ---- open file
c
      call mpi_file_open(mpi_comm_world, path_ran,
     +                   mpi_mode_create+mpi_mode_rdwr,
     +                   mpi_info_null, nvel, ierr)
c
c ---- set file view
c
      disp = 0
      call mpi_file_set_view(nvel,disp,mpi_real8,mpi_real8,
     +                      'native',mpi_info_null,ierr)
c
c ------------ read 3d fields, make rhs*8
c              grid speed is in file but don't need it for this restart
c
      nsize  = int(nvar+4,k8)*nnx*nny
      nsize2 = int(nvar+4,k8)*nnx*(iys-1)
      n_read = (nvar+4)*nnx*(iye+1-iys)
c
      do k=izs,ize
         offset = int((k-1),k8)*nsize + nsize2
         call mpi_file_read_at_all(nvel,offset,temp,n_read,
     +                              mpi_real8,status,ierr)
         if (ierr /= 0) goto 9992
#if defined(SWAP)
         call byteswap(temp)
#endif
         u_off_set = 0.0
         do j=iys,iye
         do i=1,nnx
            u(i,j,k)  = temp(1,i,j) + u_off_set
            v(i,j,k)  = temp(2,i,j)
            w(i,j,k)  = temp(3,i,j)
            uf(i,j,k) = temp(4,i,j) + u_off_set
            vf(i,j,k) = temp(5,i,j)
            wf(i,j,k) = temp(6,i,j)
            e(i,j,k)  = temp(nvar+3,i,j)
         enddo
         enddo
         do is = 1,nscl
            do j = iys,iye
            do i = 1,nnx
c              t(i,j,is,k) = temp(6+is,i,j)
               t(i,j,is,k) = 300.0
            enddo
            enddo
         enddo
c
      enddo
c
c ---- close file
c
      call mpi_file_close(nvel, ierr)
c
      deallocate(temp)
c
      do k=1,nnz
         ug(k) = ugcont
         vg(k) = vgcont
      enddo
c
      do iz=izs,ize
c
c ---------------- initial guess for pressure
c
         do iy=iys,iye
         do ix=1,nnx
            p(ix,iy,iz) = 0.0
         enddo
         enddo
      enddo
c
      return
c ---------------------------- process errors
  100 continue
      write(6,9000) path_ran, nvel
      call mpi_finalize(ierr)
      stop
c
 9992 continue
      write(6,6100) nvel,iz
      call mpi_finalize(ierr)
      stop
c ---------------------
 6001 format(' SR. GET_FIELDS: FILE READ FOR INITIALIZATION = ',a80)
 6005 format(' 6005, SR. GET_FIELDS: cannot find restart file = ',a80)
 6100 format(' SR. GET_FIELDS: file read error on unit number = ',i2,/,
     +       '               at iz = ',i4)
 9000 format(' 9000, SR. GET_FIELDS: cannot open file =',a80,/,
     +       ' to unit number = ',i2)
      end
      subroutine forcing
c
c ----------- update surface temperature based on a 
c             constant cooling rate
c
      use pars
      use fields
      use fftwk
      use con_data
      use con_stats
      include 'mpif.h'
c
      t_surface = t_surf_i - c_rate*time
c
      do j=iys,iye
      do i=1,nnx
         t_grnd(i,j,1) = t_surface
      enddo
      enddo
c
      return
      end
      subroutine set_sav(it,istart)
c
c --------- time stepping layout
c
c ----------------------------------------------------------------------
c      it-1          it             it+1
c       0 ----------> 1               2
c       *             *               *
c             dt             dt1             dt_new
c     time
c ----------------------------------------------------------------------
c
c                it-1 = 1 ---------> it=2           3
c                     *               *             *
c                         dt = dt1       dt1 = dt_new 
c                                                update dt_new from it = 1  
c                    time
c ----------------------------------------------------------------------
c
c --------- dt  = current increment between [it-1,it]
c           dt1 = next increment between [it,it+1]
c           dt_new from flow field at end of current it+1 step
c 
      use pars
      use fields
      use con_data
      use con_stats
c
      data ionce /0/
      save ionce
c
      if(it .ne. istart) then
c
c ---------- increment time if not first time through
c
         time=time+dt
      endif
c
      if(istart .eq. 0) then
         dt1 = dt_new
      endif
c
      it=it+1
c
      dt    = dt1
      dt1   = dt_new
      mnout = (mod(it,imean).eq.0).or. (it.eq.1)
      mtape = (mod(it,itape).eq.0)
      micut = (mod(it,itcut).eq.0)
      mviz  = (mod(it,iviz).eq.0)
c
c ---------- decide frequency history fields are saved
c
      if(ihst .lt. 0) then
         mhis = .false.
      else
         mhis = (mod(it,ihst).eq.0 .and. it .ge. it_his)
      endif
      mtrans = (mod(it+1,ihst).eq.0)
c
c ---------- decide frequency viz fields are saved
c
      if(iviz .lt. 0) then
         msave_v = .false.
      else
         msave_v = (mod(it,iviz).eq.0 .and. it .ge. it_viz)
      endif
c
c ---------- decide whether velocity fields are saved
c
      msave = .false.
      if(it .ge. itstr .and. mtape) then
         itn=itn+1
         msave = .true.
         call get_output_filenames
      endif
c
c --------- decide whether history files are to be saved
c
      if((ihst .gt. 0) .and. (it .ge. it_his_nxt)) then
         call open_his(it)
         it_his_nxt = it_his_nxt + itape
      endif
c
c --------- decide whether viz files are to be saved
c
      if((iviz .gt. 0) .and. (it .ge. it_viz_nxt)) then
c     if(l_root) then
c       write(6,4501) iviz, it_viz_nxt
c4501   format(' 4501: iviz = ',i5,' it_viz_nxt = ',i5)
c     endif
         call viz_output_filename(it)
         it_viz_nxt = it_viz_nxt + itape
      endif
c
c ---------- if first time thru and moving mesh
c            setup the grid and set t_zero = reference time
c
      if(i_move_step .lt. 0 .or.
     +   it .lt. i_move_step) then
        imesh  = 0
        t_zero = time
        go to 999
      endif
c
      if(it .eq. i_move_step .and. imesh .eq. 0) then
c
c -------- first time thru set W = grid speed everywhere
c
        imesh    = 1
        t_zero   = time
        t_stage  = time + dt*etas(1)
        t_stage2 = time + dt*etas(2)
        call start_mesh(it,1)
        call grid_speed(it,0)
        do k=izs-1,ize+1
           do j=iys,iye
           do i=1,nnx
              wf(i,j,k) = gm2(i,j,k,5) + wf(i,j,k)
c             wf(i,j,k) = gm2(i,j,k,5)
           enddo
           enddo
        enddo
c
      elseif(it .gt. i_move_step .and. imesh .eq. 0) then 
c
c ---------- restart with moving grid
c
        imesh    = 1
        t_stage  = time + dt*etas(1)
        t_stage2 = time + dt*etas(2)
        call start_mesh(it,1)
        call grid_speed(it,0)
      endif
c
  999 continue
c
c     write(nprt,9901) it, i_move_step, t_zero
c9901 format(' 9901 set_sav',/,
c    +       ' it = ',i5,' i_move_step = ',i8,' t_zero = ',e15.6)
c
      return
      end
      subroutine pbltop(itop)
c
c ---------- get estimate of pbl top
c
c            method = 0, min of wt flux
c                        (good for buoyancy cases)
c            method = 1, uw flux less than critical value
c                        (good for ekman cases)
c            method = 2, running t average exceeds criterion
c                        (good for neutral cases with capping
c                         inversions)
c            method = 3, maximum gradient in temperature field
c                        (good for finding local zi see jas paper)
c                        with minimum search height (sr. setup)
c
c ------------ if method uses average statistics then only root
c              process need find zi
c
      use pars
      use fields
      use con_data
      use con_stats
      real trun(maxnz)
      include 'mpif.h'
      real gradloc(2,nnx,nny), gradmax(2,nnx,nny)
      external get_zi
c
      if(method .le. 2 .and. l_root) then
c
      sgn = 1.0
      if(iocean .eq. 1) sgn = 1.0
      if (method .le. 0 .or. method .gt. 2) then
         itop=1
         wttot=wtle(1,1)+wtsb(1,1)
         wtmin=wttot*sgn
         do iz=2,nnz
            wttot=(wtle(iz,1)+wtsb(iz,1))*sgn
            if (wttot.le.wtmin) then
               itop=iz
               wtmin=wttot
            endif
         enddo
         zi=z(itop)
      else if (method .eq. 1) then
         itop = 1
         crit = 0.05
         uwsf = utau*utau
         do iz=1,nnzm1
               uwtot = (uwle(iz) + uwsb(iz))**2 +
     $                 (vwle(iz) + vwsb(iz))**2
               uwtot = sqrt(uwtot)
               if(uwtot/uwsf .gt. crit) then
                  itop=iz
               endif
         enddo
         zi=z(itop)
      else if (method .eq. 2) then
         trun(1) = txym(1,1)
         do iz=2,nnz
             weight = z(iz-1)/z(iz)
             trun(iz) = trun(iz-1)*weight + (1.0-weight)*txym(iz,1)
         enddo
         itop = 1
         tcrit = 0.25
         if(iocean .eq. 1) tcrit = 0.1
         do iz=2,nnz
                if(txym(iz,1) .gt. (trun(iz) + tcrit)) then
                  itop = iz
                  go to 320
                endif
         enddo
  320    continue
         zi=z(itop)
      endif
      do iy=1,nny
      do ix=1,nnx
         gradmax(2,ix,iy) = zi
      enddo
      enddo
c
c ----------- use gradient method, every process computes
c
      elseif(method .eq. 3) then
c
c ---------------- get local zi from gradient in temperaure field
c
c     dz_i = dzu_i(izs+1)
c     do iy=1,nny
c     do ix=1,nnx
c        gradloc(1,ix,iy) = (t(ix,iy,1,izs+1) - t(ix,iy,1,izs))*dz_i
c        gradloc(2,ix,iy) = z(izs)
c     enddo
c     enddo
c
c ------- similar to zeroing the stat array in sr. mean_stat
c
      do iy=1,nny
      do ix=1,nnx
         gradloc(1,ix,iy) = 0.0
         gradloc(2,ix,iy) = z(iz_min)
      enddo
      enddo
c
c ------------- now all z in this process
c
      if(iz_min .le. ize) then
      do iz=max(izs,iz_min),ize
         izp1 = iz + 1
         do iy=iys,iye
         do ix=1,nnx
            grad = (t(ix,iy,1,izp1) - t(ix,iy,1,iz))*dzu_i(izp1)
            if(grad .gt. gradloc(1,ix,iy)) then
               gradloc(1,ix,iy) = grad
               gradloc(2,ix,iy) = z(iz)
            endif
         enddo
         enddo
      enddo
      endif
c
c     call mpi_reduce(gradloc,gradmax,2*nnx*nny,mpi_real8,ziloc,
c    +                i_root,mpi_comm_world,ierror)
c
c ----------- alternate version using already defined function in mpi
c             passes 2 real8 variables
c
      call mpi_reduce(gradloc,gradmax,nnx*nny,mpi_2double_precision,
     +                mpi_maxloc,i_root,mpi_comm_world,ierror)
c
c ------------ get average on root process
c
      if(l_root) then
         zi_avg = 0.0
         do iy=1,nny
         do ix=1,nnx
            zi_avg = zi_avg + gradmax(2,ix,iy)
         enddo
         enddo
         zi = zi_avg*fnxy
         itop = 1
         do k=1,nnz-1
            if(zi .gt. z(k) .and. zi .le. z(k+1)) then
              itop = k
            endif
         enddo
      endif
c
      endif
c
c -------- send average zi everywhere
c
      call mpi_bcast(zi,1,mpi_real8,
     +              i_root,mpi_comm_world,ierr)
c
      if(iocean .ne. 1) then
         do iz=1,nnz
            if(zi .ge. z(iz) .and.
     +         zi .lt. z(iz+1)) itop = iz
         enddo
      else
         do iz=1,nnz
            if(zi .le. z(iz) .and.
     +         zi .gt. z(iz+1)) itop = iz
         enddo
      endif
c
c ---------- get zi/L
c
      hol = zi/amonin
c
c     if(l_root) write(6,7001) myid,zi,itop
 7001 format(' 7001 in pbltop myid = ',i4,' zi = ',e15.6,
     +       ' itop = ',i3)
c
      return
      end
      subroutine get_zi(gradmax,gradout,len,itype)
c
      use pars
      real gradmax(*), gradout(*)
c
c     write(nprt,2001) myid, len
c2001 format(' 2001 in get_zi myid = ',i4,' len = ',i8)
c     write(nprt,2002) (i,gradmax(i),gradmax(i+1),i=1,len,2)
c2002 format(' i ',5x,' grad ',5x,' location ',/,
c    +      (i5,2e15.6))
c
      do i=1,len,2
         if(gradmax(i) .gt. gradout(i)) then
              gradout(i)   = gradmax(i)
              gradout(i+1) = gradmax(i+1)
         endif
      enddo
c
      return
      end
      subroutine print(lu,it,iz_strt,iz_end)
c
      use pars
      use fields
      use fftwk
      use con_data
      use con_stats
c
      write(lu,4000)
 4000 format(30X,' --- SOLUTION ---')
      write(lu,4100) it,time,dt,zi,tsfcc(1),uwsfc,vwsfc,wtsfc(1),
     +              zol, hol, amonin, ucfl, vcfl, wcfl, utau,
     +              t_ref, drg_x, drg_y, p_iter, p_err
 4100 format(' IT=',I7,5x,'TIME (s) = ',e15.8,',  DT(s) = ',e15.6,/,
     +       10x,'ZTOP = ',e15.6,
     +       ',  TSFC = ',e15.6,
     +       ',  UW = ',e15.6,',  VW = ',e15.6,/,10x,
     +       'WT = ',e15.6,',  Z1/L =',e15.6,
     +       ',  ZI/L = ',e15.6,',  MO-L = ',e15.6,/,10x,
     +       'U_cfl = ',e15.6,
     +       ',  V_cfl = ',e15.6,',  W_cfl = ',e15.6,
     +       ',  UTAU = ',e15.6,/,10x,
     +       'Theta Ref = ',e15.6,/,10x,'P-Drag_x  = ',e15.6,
     +       ',   P-Drag_y = ',e15.6,/,10x,
     +       'P iterations = ',e15.6,',   P error = ',e15.6)
      write(lu,4200)
 4200 format(//,20x,'--------- HORIZONTAL MEAN VALUES ---------- ',
     +       //,2x,'IZ',4x,'T_MEAN',7x,
     + 'DIVG',8X,'LE_KE',6X,'SGS_KE',7X,'LE_WT',6X,
     + 'SGS_WT',7X,'SHRZ',8X,'BUOY')
      do 19999 iz=iz_end,iz_strt,-1
         write(lu,4300)iz,txym(iz,1)-t_ref,divz(iz),
     +              englez(iz),eavg(iz),wtle(iz,1),
     +              wtsb(iz,1),shrz(iz),buyz(iz)
 4300    format(1X,I3,e12.4,7e12.4)
19999 continue
      write(lu,4400)tsfcc(1),wtsfc(1)
 4400 format('  SURFACE VALUES: TXYM = ',E15.6,'  WTSB = ',E15.6)
      if(iocean .eq. 1) then
         write(lu,4500) stokess,udrift,vdrift
 4500    format(/,' STOKESS = ',e12.4,' UDRIFT = ',e12.4,
     +          ' VDRIFT = ',e12.4)
      endif
      write(lu,4600) (iz,uxym(iz)+ugal,vxym(iz),uwle(iz),
     +       uwsb(iz),vwle(iz),vwsb(iz),pm(iz),iz=iz_strt,iz_end)
 4600 format(//,' IZ',5x,' UXYM + UGAL',8x,' VXYM',10x,' UWLE',11x,
     +          ' UWSB',11x,' VWLE',11x,' VWSB',11x,' P MEAN'
     +       ,/,(1x,i4,7(3x,e13.6)))
      if(ivis .eq. 1) then
         write(lu,4800) xksurf, nmatch, viscon, vise
 4800    format(//,' XKSURF = ',e15.6,' NMATCH = ',i4,/,
     +             ' VISCON = ',e15.6,' VISE = ',e15.6)
         write(lu,4700) (iz,dfac(iz),iz=iz_strt,iz_end)
 4700    format(//,'   IZ',5x,'  DFAC',/,(1x,i4,3x,e15.6))
      endif
c
c --------------- output additional scalars
c
c     if(nscl .eq. 2) then
c     write(lu,5005)tsfcc(2),wtsfc(2)
c5005 format(/,'  SURFACE VALUE: TXYM(2) =',e15.6,' WTSFC(2) = ',e15.6)
c     write(lu,5100) (iz,txym(iz,2),wtle(iz,2),
c    +              wtsb(iz,2),iz=iz_strt,iz_end)
c5100 format(//,' IZ',5x,' SCALAR-1 MEAN',8x,' WS1LE',10x,
c    +          ' WS1SB',10x
c    +       ,/,(1x,i4,3(3x,e13.6)))
c     else if (nscl .eq. 3) then
c     write(lu,5205)tsfcc(2),wtsfc(2),tsfcc(3),wtsfc(3)
c5205 format(/,'  SURFACE VALUE: TXYM(2) =',e15.6,' WTSFC(2) = ',e15.6,
c    +       /,'  SURFACE VALUE: TXYM(3) =',e15.6,' WTSFC(3) = ',e15.6)
c     write(lu,5200) (iz,txym(iz,2),txym(iz,3),wtle(iz,2),
c    +    wtsb(iz,2),wtle(iz,3),wtsb(iz,3),iz=iz_strt,iz_end)
c5200 format(//,' IZ',5x,' SCALAR-1 MEAN',8x,' SCALAR-2 MEAN',10x,
c    +          ' WS1LE',10x,' WS1SB',10x,' WS2LE',10x,' WS1SB'
c    +       ,/,(1x,i4,6(3x,e13.6)))
c     endif
c
      return
      end
      subroutine xy_stats
c
c ------------ get statistics.
c              fluxes that appear in transformed equations
c              are based on (UF,VF,WF-Z_t) located at cell centers
c              and upper cell face. 
c              
c              f_avg = [\int \int f * fac dx dy]/area
c              fac   = [sqrt(zeta_x^2 + zeta_y^2 + zeta_z^2]/J
c
      use pars
      use fields
      use con_data
      use con_stats
      use particles
c
c ------- indices for indexing array stat(.,.)
c         js = number of non-scalar stats
c         ns = number of scalar stats
c
      parameter(js = 28, ns = 6, nstat = js + ns*nscl)
      real stat(1:nnz,nstat), buf(4)
c
c -------- stat(.,1) = u*u = ups
c          stat(.,2) = v*v = vps
c          stat(.,3) = w*w = wps
c          stat(.,4) = w**3 = wcube
c          stat(.,5) = w**4 = wfour
c          stat(.,6) = resolved tke at zu = englez
c          stat(.,7) = sgs e at zu = engsbz
c          stat(.,8) = sgs e at zu = eavg
c          stat(.,9) = resolved uw_f at zw = uwle
c          stat(.,10) = resolved vw_f at zw = vwle
c          stat(.,11) = resolved uw at zu = uwcle
c          stat(.,12) = resolved vw at zu = vwcle
c          stat(.,13) = form drag in x direction at zu
c          stat(.,14) = form drag in y direction at zu
c          stat(.,15) = x form drag at zu correlated with surface [p(z)*z_xi(1)]
c          stat(.,16) = y form drag at zu correlated with surface [p(z)*z_eta(1)]
c          stat(.,17) = resolved w*w_f flux at zw = wwle
c          stat(.,18) = particle mass in each horizontal layer
c          stat(.,19) = vpsum(1) (mean horizontal particle velocity)
c          stat(.,20) = vpsum(2) (mean spanwise particle velocity)
c          stat(.,21) = vpsum(3) (mean vertical particle velocity)
c          stat(.,22) = vpsqrsum(1)
c          stat(.,23) = vpsqrsum(2)
c          stat(.,24) = vpsqrsum(3)
c          stat(.,25) = upwp = up'*wp'
c          stat(.,26) = Tpsum
c          stat(.,27) = Tpsqrsum
c          stat(.,28) = wpTpsum
c          stat(.,m1) = resolved scalar flux w_ft at zw = wtle
c          stat(.,m2) = resolved scalar flux u_ft at zu = utle
c          stat(.,m3) = resolved scalar flux v_ft at zu = vtle
c          stat(.,m4) = scalar t*t at zu = tps
c          stat(.,m5) = scalar t*t*t at zu = tcube
c          stat(.,m6) = resolved scalar flux wct at zu = wctle
c
c --------- use a trick with mpi reduce over all z to get averages
c           by setting stat array = 0 for all z on each process
c
      do i=1,nstat
      do k=1,nnz
         stat(k,i) = 0.0
      enddo
      enddo
c
c -------- indices for scalars
c
      m1 = js
      m2 = js + nscl
      m3 = js + 2*nscl
      m4 = js + 3*nscl
      m5 = js + 4*nscl
      m6 = js + 5*nscl
c
      sgn = 1.0
      if(iocean .eq. 1 .and. iupwnd .eq. 1) sgn = -1.0
c
      do k=izs,ize
c
      kp2 = k + 2
      kp1 = k + 1
      km1 = k - 1
c
c ------- simple average along coordinate lines
c
      do j=iys,iye
      do i=1,nnx
         stat(k,1) = stat(k,1) + (u(i,j,k) - uxym(k))**2
         stat(k,2) = stat(k,2) + (v(i,j,k) - vxym(k))**2
         stat(k,3) = stat(k,3) + (w(i,j,k) - wxym(k))**2
         stat(k,4) = stat(k,4) + (w(i,j,k) - wxym(k))**3
         stat(k,5) = stat(k,5) + (w(i,j,k) - wxym(k))**4
         stat(k,6) = stat(k,6) + 
     +                ((w(i,j,k)- wxym(k))**2 +
     +                 (u(i,j,k)- uxym(k))**2 +
     +                 (v(i,j,k)- vxym(k))**2)*0.5
c
         stat(k,7) = stat(k,7) + e(i,j,k)
         stat(k,8) = stat(k,8) + e(i,j,k)
         stat(k,9) = stat(k,9) + 0.5*(wf(i,j,k) - gm(i,j,k,5))*
     +               (u(i,j,k)-uxym(k) + u(i,j,kp1) - uxym(kp1))
         stat(k,10) = stat(k,10) + 0.5*(wf(i,j,k) - gm(i,j,k,5))*
     +               (v(i,j,k)-vxym(k) + v(i,j,kp1) - vxym(kp1))
         stat(k,11) = stat(k,11) + (w(i,j,k)-wxym(k))*
     +                           (u(i,j,k)-uxym(k))
         stat(k,12) = stat(k,12) + (w(i,j,k)-wxym(k))*
     +                             (v(i,j,k)-vxym(k))
c
c --------- get drag [p(z)*z_xi(z), p(z)*z_eta(z)]
c
         stat(k,13) = stat(k,13) + p(i,j,k)*gm(i,j,k,1)*gm(i,j,k,2)
         stat(k,14) = stat(k,14) + p(i,j,k)*gm(i,j,k,1)*gm(i,j,k,3)
c
c --------- get drag [p(z)*z_xi(1), p(z)*z_eta(1)]
c
         stat(k,15) = stat(k,15) + p(i,j,k)*gms(i,j,1)*gms(i,j,2)
         stat(k,16) = stat(k,16) + p(i,j,k)*gms(i,j,1)*gms(i,j,3)
c
         stat(k,17) = stat(k,17) + 0.5*(wf(i,j,k) - gm(i,j,k,5))*
     +               (w(i,j,k)-wxym(k) + w(i,j,kp1) - wxym(kp1))

         stat(k,18) = stat(k,18) + partcount(i,j,k)
         stat(k,19) = stat(k,19) + vpsum(i,j,k,1)
         stat(k,20) = stat(k,20) + vpsum(i,j,k,2)
         stat(k,21) = stat(k,21) + vpsum(i,j,k,3)
         stat(k,22) = stat(k,22) + vpsqrsum(i,j,k,1)
         stat(k,23) = stat(k,23) + vpsqrsum(i,j,k,2)
         stat(k,24) = stat(k,24) + vpsqrsum(i,j,k,3)
         stat(k,25) = stat(k,25) + upwp(i,j,k)
         stat(k,26) = stat(k,26) + Tpsum(i,j,k)
         stat(k,27) = stat(k,27) + Tpsqrsum(i,j,k)
         stat(k,28) = stat(k,28) + wpTpsum(i,j,k)
      enddo
      enddo
c
c ------------ get scalar resolved fluxes and variances
c
      do l=1,nscl
         if(iupwnd .ne. 1 .or. k .eq. nnz) then
            do j=iys,iye
            do i=1,nnx
               stat(k,m1+l)=stat(k,m1+l) +
     +               0.5*(wf(i,j,k) - gm(i,j,k,5))*
     +          (t(i,j,l,k)-txym(k,l) + t(i,j,l,kp1) - txym(kp1,l))
            enddo
            enddo
         else
c
c ------------------- monotone fluxes
c
           do j=iys,iye
           do i=1,nnx
              wflx = wf(i,j,k) - gm(i,j,k,5)
              stat(k,m1+l) = stat(k,m1+l) +
     +    amax1(sgn*wflx,0.)*(t(i,j,l,k) +
     + rlim(t(i,j,l,kp1),t(i,j,l,k),t(i,j,l,km1))) +
     +    amin1(sgn*wflx,0.)*(t(i,j,l,kp1) +
     + rlim(t(i,j,l,k),t(i,j,l,kp1),t(i,j,l,kp2)))
           enddo
           enddo
         endif
         stat(k,m1+l)= sgn*stat(k,m1+l)
c
           do j=iys,iye
           do i=1,nnx
              stat(k,m6+l) = stat(k,m6+l) +
     +                       (w(i,j,k) - wxym(k))*
     +                       (t(i,j,l,k)-txym(k,l))
           enddo
           enddo
c
c ------------ get horizontal scalar resolved fluxes 
c
         do j=iys,iye
         do i=1,nnx
            stat(k,m2+l) = stat(k,m2+l)+
     +               uf(i,j,k)*(t(i,j,l,k)-txym(k,l)) 
            stat(k,m3+l) = stat(k,m3+l)+
     +               vf(i,j,k)*(t(i,j,l,k)-txym(k,l)) 
         enddo
         enddo
c
c ------------------- scalar variances & higher moments
c
         do j=iys,iye
         do i=1,nnx
            stat(k,m4+l) = stat(k,m4+l) + 
     +                (t(i,j,l,k) - txym(k,l))**2
            stat(k,m5+l) = stat(k,m5+l) + 
     +                (t(i,j,l,k) - txym(k,l))**3
         enddo
         enddo
c
c ------ end scalar loop
c
      enddo
c
c ------ end z loop
c
      enddo
c
c -------- add partial sums and send it to all
c
      call mpi_sum_z(stat(1,1),i_root,myid,nnz*nstat,1)
c
c ------ fill arrays for printout and constant file
c
      do k=1,nnz
c 
      ups(k)      =   stat(k,1)*fnxy
      vps(k)      =   stat(k,2)*fnxy
      wps(k)      =   stat(k,3)*fnxy
      wcube(k)    =   stat(k,4)*fnxy
      wfour(k)    =   stat(k,5)*fnxy
      englez(k)   =   stat(k,6)*fnxy
      engsbz(k)   =   stat(k,7)*fnxy
      eavg(k)     =   stat(k,8)*fnxy
      uwle(k)     =   stat(k,9)*fnxy
      vwle(k)     =   stat(k,10)*fnxy
      uwcle(k)    =   stat(k,11)*fnxy
      vwcle(k)    =   stat(k,12)*fnxy
      uw_tot(k)   =   uwle(k) + uwsb(k)
      vw_tot(k)   =   vwle(k) + vwsb(k)
      drg_z_x(k)  =   stat(k,13)*fnxy
      drg_z_y(k)  =   stat(k,14)*fnxy
      drg_zs_x(k) =  stat(k,15)*fnxy
      drg_zs_y(k) =  stat(k,16)*fnxy
      wwle(k)     =  stat(k,17)*fnxy
      zconc(k)    = stat(k,18)/xl/yl/dzw(iz)
      vp1mean(k)  = stat(k,19)/stat(k,18)
      vp2mean(k)  = stat(k,20)/stat(k,18)
      vp3mean(k)  = stat(k,21)/stat(k,18)
      vp1msqr(k)  = sqrt(stat(k,22)/stat(k,18) - vp1mean(k)**2)
      vp2msqr(k)  = sqrt(stat(k,23)/stat(k,18) - vp2mean(k)**2)
      vp3msqr(k)  = sqrt(stat(k,24)/stat(k,18) - vp3mean(k)**2)
      upwpm(k)    = stat(k,25)/stat(k,18)-(vp1mean(k)*vp3mean(k))
      Tpmean(k)   = stat(k,26)/stat(k,18)
      Tpmsqr(k)   = sqrt(stat(k,27)/stat(k,18)-Tpmean(k)**2)
      wpTpm(k)    = stat(k,28)/stat(k,18) - (Tpmean(k)*vp3mean(k))

c
c ------------ get scalar resolved fluxes and variances
c
      do l=1,nscl
         wtle(k,l)   = stat(k,m1+l)*fnxy
         utle(k,l)   = stat(k,m2+l)*fnxy
         vtle(k,l)   = stat(k,m3+l)*fnxy
         tps(k,l)    = stat(k,m4+l)*fnxy
         tcube(k,l)  = stat(k,m5+l)*fnxy
         wctle(k,l)  = stat(k,m6+l)*fnxy
         wt_tot(k,l) = wtle(k,l) + wtsb(k,l)
      enddo
      enddo
c
c ---------- drag at first zu grid point
c
      drg_x = drg_z_x(1)
      drg_y = drg_z_y(1)
c
      return
      end
      subroutine tke_budget
c
c -------- get terms in resolved scale tke budget
c          as in gabls writeup at w-points
c          at istage = 1. 
c          t_diss and tr_tau are in comp1, pxym is in get_means
c
      use pars
      use fields
      use con_data
      use con_stats
c
      real stat(1:nnz,2)
c
c -------- stat(.,1) = tke transport  = wq
c          stat(.,2) = pressure transport  = wp
c
      do k=1,nnz
         stat(k,1) = 0.0
         stat(k,2) = 0.0
      enddo
c
c --------------- get transport terms as vertical arrays
c
      do k=izs,ize
c
         km1 = k - 1
         do j=iys,iye
         do i=1,nnx
c
c --------- get estimate of turbulent transport term
c
            ufluc   = u(i,j,k) - uxym(k)
            vfluc   = v(i,j,k) - vxym(k)
            wfluc   = w(i,j,k) - wxym(k)
            stat(k,1)  = stat(k,1) + 0.5*wfluc*
     +             (ufluc**2 + vfluc**2 + wfluc**2)
c
c --------- get estimate of pressure transport term
c
            pfluc     = pm(k) + p(i,j,k) - c23*e(i,j,k)
            stat(k,2) = stat(k,2) + pfluc*wfluc
         enddo
         enddo
         stat(k,1) = stat(k,1)*fnxy
         stat(k,2) = stat(k,2)*fnxy
      enddo
      call mpi_sum_z(stat(1,1),i_root,myid,nnz*2,1)
c
c ------ we have all terms on all processors for all z, add them up
c        treat tr_tau at bottom special, tr_tau = 0
c
      tr_tau(0) = 0.0
      do k=1,nnz
c
         kp1 = k + 1
         km1 = k - 1
         if(k .eq. nnz) then
            t_tau(k) = 0.0
            t_wp(k)  = 0.0
            t_wq(k)  = 0.0
         else
            t_tau_u   = 0.5*(tr_tau(kp1) + tr_tau(k))
            t_tau_l   = 0.5*(tr_tau(km1) + tr_tau(k))
            t_tau(k) = -(t_tau_u - t_tau_l)*dzu_i(kp1)
            t_wq(k)  = -(stat(kp1,1) - stat(k,1))*dzu_i(kp1)
            t_wp(k)  = -(stat(kp1,2) - stat(k,2))*dzu_i(kp1)
         endif
         dudz = (uxym(kp1) - uxym(k))*dzu_i(kp1)
         dvdz = (vxym(kp1) - vxym(k))*dzu_i(kp1)
c
c ------------- gather all the budget terms
c
         t_tran(k)  = t_wq(k) + t_wp(k) + t_tau(k)
         t_rprod(k) = -(dudz*uwle(k) + dvdz*vwle(k))
         t_sprod(k) =  (dudz*uwsb(k) + dvdz*vwsb(k))
         t_buoy(k)  =  batag*wtle(k,1)
c
      enddo
c
      return
      end
      subroutine write_his(iloc)
c
c ----- write history file with global parameters
c       write tsfcc specially to preserve digits!
c
      use pars
      use fields
      use con_data
      use con_stats
      use particles
c
      real save_theta(0:nnz)
c
      divgmax = 0.0
      do iz=1,nnz
         divgmax = amax1(divgmax, divz(iz))
      enddo
c
      ziavg = zi
      holtop = hol
      wt_min = wtsb(iloc,1)
      wt_le  = wtle(iloc,1)
      krec = krec + 1
      mid = nnz/4
c
      write(nhis1,6000) time,dt,utau,ziavg,amonin,holtop,
     +         (tsfcc(1)-t_ref),uusfc,uvsfc,uwsfc,vvsfc,vwsfc,wwsfc,
     +         divgmax, wt_min, wt_le,
     +         ucfl, vcfl, wcfl, wtsfc(1),
     +         ups(mid),vps(mid),wps(mid),tps(mid,1),
     +         uwle(mid),uwsb(mid),uw_tot(mid),
     +         vwle(mid),vwsb(mid),vw_tot(mid),
     +         uwcle(mid),vwcle(mid),
     +         wtle(mid,1),wtsb(mid,1),wctle(mid,1),wt_tot(mid,1),
     +         englez(mid),eavg(mid), wabs, float(ip_max),
     +         p_iter, p_err, drg_x, drg_y,
     +         Rep_avg,float(his_reintro)
c    +         tps(mid,2), tps(mid,3),
c    +         wtle(mid,2),wtsb(mid,2),wt_tot(mid,2),
c    +         wtle(mid,3),wtsb(mid,3),wt_tot(mid,3)
 6000 format(46e17.8)
c
c ------ to increase resolution of theta
c        subtract reference before saving history file
c
      do k=1,nnz
         save_theta(k) = txym(k,1)
         txym(k,1)     = txym(k,1) - t_ref
      enddo
c
c -------------- write profile information
c
      call write_prof(nhisp,krec,isize,c_s%wwsb)
c
      do k=1,nnz
         txym(k,1) = save_theta(k)
      enddo
c
      return
      end
      subroutine write_prof(nhisp,krec,num,f)
      real f(num)
      real*4 f32(num)
c
c -------------- build special 32 bit arrays for profiles
c
      do i=1,num
         f32(i) = f(i)
      enddo
c
      write(nhisp,err=999,rec=krec) (f32(i),i=1,num)
c
      return
c --------------- errors
  999 continue
      write(6,9000) num,krec
 9000 format(' 9000, trouble in ',
     +       'SR. save_prof cannot write profile data ',/,
     +       ' num = ',i8, 'krec = ',i6)
      stop
      end
      subroutine close_his
c
c ---- close history files
c
      use pars
      logical there
c
c ---- root closes and checks the files
c
      close(nhis1)
      close(nhisp)
      inquire(file=path_sav_h,exist=there)
      if(.not.there) then
         write(6,8000) path_sav_h
         call mpi_finalize(ierr)
         stop
      endif
      inquire(file=path_sav_hp,exist=there)
      if(.not.there) then
         write(6,8100) path_sav_hp
         call mpi_finalize(ierr)
         stop
      endif
      write(6,7000) path_sav_h
      write(6,7100) path_sav_hp
c
      return
c -------------------- process write errors
 7000 format(' HISTORY DATA IS WRITTEN IN FILE  ',a80)
 7100 format(' PROFILE HISTORY DATA IS WRITTEN IN FILE  ',a80)
 8000 format(' SR. SAVE_HIS: Truble history file not in path =',a80)
 8100 format(' SR. SAVE_HIS: Trouble profile history file',
     +       ' not in path =',a80)
      end
      subroutine dealias_grid_speed
c
c --------- wave cutoff filter using 2d fft
c           for boundary condition values
c
      use pars
      use fields
      use fftwk
      use con_data
      use con_stats
      real wve(nny,jxs:jxe), gm_work(nnx+2,iys:iye)
c
c --------- sharp spectral cutoff, specific to current 2dfft
c
      ix_cut   = 2*int(float(nnx)/3.) + 3
      iy_cut_l = int(float(nny)/3.) + 2
      iy_cut_u = nnyp2 - iy_cut_l
c
      if(iss == 0) then
c
      do j=iys,iye
      do i=1,nnx
c        gm_work(i,j) = gm(i,j,izs-1,5)
         gm_work(i,j) = gm2(i,j,izs-1,5)
      enddo
      enddo
      call fft2d_mpi(gm_work(1,iys),wve(1,jxs),
     +           trigx(1,1),trigc,
     +           nnx,nny,jxs,jxe,jx_s,jx_e,iys,iye,iy_s,iy_e,
     +           1,1,myid,ncpu_s,numprocs,-2)
      call sharp_bndy(wve,ix_cut,iy_cut_l,iy_cut_u)
      call fft2d_mpi(gm_work(1,iys),wve(1,jxs),
     +           trigx(1,1),trigc,
     +           nnx,nny,jxs,jxe,jx_s,jx_e,iys,iye,iy_s,iy_e,
     +           1,1,myid,ncpu_s,numprocs,2)
      do j=iys,iye
      do i=1,nnx
c        gm(i,j,izs-1,5)  = gm_work(i,j)
         gm2(i,j,izs-1,5) = gm_work(i,j)
      enddo
      enddo
c
      endif
c
      if(ise == numprocs-1) then
c
      do j=iys,iye
      do i=1,nnx
c        gm_work(i,j) = gm(i,j,ize,5)
         gm_work(i,j) = gm2(i,j,ize,5)
      enddo
      enddo
      call fft2d_mpi(gm_work(1,iys),wve(1,jxs),
     +           trigx(1,1),trigc,
     +           nnx,nny,jxs,jxe,jx_s,jx_e,iys,iye,iy_s,iy_e,
     +           1,1,myid,ncpu_s,numprocs,-2)
      call sharp_bndy(wve,ix_cut,iy_cut_l,iy_cut_u)
      call fft2d_mpi(gm_work(1,iys),wve(1,jxs),
     +           trigx(1,1),trigc,
     +           nnx,nny,jxs,jxe,jx_s,jx_e,iys,iye,iy_s,iy_e,
     +           1,1,myid,ncpu_s,numprocs,2)
      do j=iys,iye
      do i=1,nnx
c        gm(i,j,ize,5)  = gm_work(i,j)
         gm2(i,j,ize,5) = gm_work(i,j)
      enddo
      enddo
c
      endif
c
      return
      end
      subroutine dealias
c
c --------- wave cutoff filter using 2d fft
c
      use pars
      use fields
      use fftwk
      use con_data
      use con_stats
      real wve(nny,jxs:jxe,izs:ize)
      real wves(nnxp2,iys:iye,izs:ize)
c
c --------- sharp spectral cutoff, specific to current 2dfft
c
      ix_cut   = 2*int(float(nnx)/3.) + 3
      iy_cut_l = int(float(nny)/3.) + 2
c
c     ix_cut   = 2*int(float(nnx_c)/3.) + 3
c     iy_cut_l = int(float(nny_c)/3.) + 2
c
      iy_cut_u = nnyp2 - iy_cut_l
c
c ---------- u-equation
c
      call fft2d_mpi(u(1,iys,izs),wve(1,jxs,izs),trigx(1,1),trigc,
     +           nnx,nny,jxs,jxe,jx_s,jx_e,iys,iye,iy_s,iy_e,
     +           izs,ize,myid,ncpu_s,numprocs,-2)
      call sharp(wve,ix_cut,iy_cut_l,iy_cut_u)
      call fft2d_mpi(u(1,iys,izs),wve(1,jxs,izs),trigx(1,1),trigc,
     +           nnx,nny,jxs,jxe,jx_s,jx_e,iys,iye,iy_s,iy_e,
     +           izs,ize,myid,ncpu_s,numprocs,2)
c
c ---------- v-equation
c
      call fft2d_mpi(v(1,iys,izs),wve(1,jxs,izs),trigx(1,1),trigc,
     +           nnx,nny,jxs,jxe,jx_s,jx_e,iys,iye,iy_s,iy_e,
     +           izs,ize,myid,ncpu_s,numprocs,-2)
      call sharp(wve,ix_cut,iy_cut_l,iy_cut_u)
      call fft2d_mpi(v(1,iys,izs),wve(1,jxs,izs),trigx(1,1),trigc,
     +           nnx,nny,jxs,jxe,jx_s,jx_e,iys,iye,iy_s,iy_e,
     +           izs,ize,myid,ncpu_s,numprocs,2)
c
c ---------- w-equation
c
      call fft2d_mpi(w(1,iys,izs),wve(1,jxs,izs),trigx(1,1),trigc,
     +           nnx,nny,jxs,jxe,jx_s,jx_e,iys,iye,iy_s,iy_e,
     +           izs,ize,myid,ncpu_s,numprocs,-2)
      call sharp(wve,ix_cut,iy_cut_l,iy_cut_u)
      call fft2d_mpi(w(1,iys,izs),wve(1,jxs,izs),trigx(1,1),trigc,
     +           nnx,nny,jxs,jxe,jx_s,jx_e,iys,iye,iy_s,iy_e,
     +           izs,ize,myid,ncpu_s,numprocs,2)
c
c ---------- e-equation
c
      call fft2d_mpi(e(1,iys,izs),wve(1,jxs,izs),trigx(1,1),trigc,
     +           nnx,nny,jxs,jxe,jx_s,jx_e,iys,iye,iy_s,iy_e,
     +           izs,ize,myid,ncpu_s,numprocs,-2)
      call sharp(wve,ix_cut,iy_cut_l,iy_cut_u)
      call fft2d_mpi(e(1,iys,izs),wve(1,jxs,izs),trigx(1,1),trigc,
     +           nnx,nny,jxs,jxe,jx_s,jx_e,iys,iye,iy_s,iy_e,
     +           izs,ize,myid,ncpu_s,numprocs,2)
c
c ---------- uf-equation
c
      call fft2d_mpi(uf(1,iys,izs),wve(1,jxs,izs),trigx(1,1),trigc,
     +           nnx,nny,jxs,jxe,jx_s,jx_e,iys,iye,iy_s,iy_e,
     +           izs,ize,myid,ncpu_s,numprocs,-2)
      call sharp(wve,ix_cut,iy_cut_l,iy_cut_u)
      call fft2d_mpi(uf(1,iys,izs),wve(1,jxs,izs),trigx(1,1),trigc,
     +           nnx,nny,jxs,jxe,jx_s,jx_e,iys,iye,iy_s,iy_e,
     +           izs,ize,myid,ncpu_s,numprocs,2)
c
c ---------- vf-equation
c
      call fft2d_mpi(vf(1,iys,izs),wve(1,jxs,izs),trigx(1,1),trigc,
     +           nnx,nny,jxs,jxe,jx_s,jx_e,iys,iye,iy_s,iy_e,
     +           izs,ize,myid,ncpu_s,numprocs,-2)
      call sharp(wve,ix_cut,iy_cut_l,iy_cut_u)
      call fft2d_mpi(vf(1,iys,izs),wve(1,jxs,izs),trigx(1,1),trigc,
     +           nnx,nny,jxs,jxe,jx_s,jx_e,iys,iye,iy_s,iy_e,
     +           izs,ize,myid,ncpu_s,numprocs,2)
c
c ---------- wf-equation
c
      call fft2d_mpi(wf(1,iys,izs),wve(1,jxs,izs),trigx(1,1),trigc,
     +           nnx,nny,jxs,jxe,jx_s,jx_e,iys,iye,iy_s,iy_e,
     +           izs,ize,myid,ncpu_s,numprocs,-2)
      call sharp(wve,ix_cut,iy_cut_l,iy_cut_u)
      call fft2d_mpi(wf(1,iys,izs),wve(1,jxs,izs),trigx(1,1),trigc,
     +           nnx,nny,jxs,jxe,jx_s,jx_e,iys,iye,iy_s,iy_e,
     +           izs,ize,myid,ncpu_s,numprocs,2)
c
c ------------- scalars, not stored in correct order
c
      do iscl=1,nscl
         do iz=izs,ize
         do iy=iys,iye
         do ix=1,nnx
            wves(ix,iy,iz) = t(ix,iy,iscl,iz)
         enddo
         enddo
         enddo
         call fft2d_mpi(wves(1,iys,izs),wve(1,jxs,izs),trigx(1,1),
     +           trigc,nnx,nny,jxs,jxe,jx_s,jx_e,iys,iye,iy_s,iy_e,
     +           izs,ize,myid,ncpu_s,numprocs,-2)
         call sharp(wve,ix_cut,iy_cut_l,iy_cut_u)
         call fft2d_mpi(wves(1,iys,izs),wve(1,jxs,izs),trigx(1,1),
     +           trigc,nnx,nny,jxs,jxe,jx_s,jx_e,iys,iye,iy_s,iy_e,
     +           izs,ize,myid,ncpu_s,numprocs,2)
         do iz=izs,ize
         do iy=iys,iye
         do ix=1,nnx
            t(ix,iy,iscl,iz) = wves(ix,iy,iz)
         enddo
         enddo
         enddo
      enddo
c
      return
      end
      subroutine sharp(wve,ix_cut,iy_cut_l,iy_cut_u)
c
c --------- sharp cutoff filter for field wve stored
c           in 2d-fft order
c
      use pars
      real wve(nny,jxs:jxe,izs:ize)
c
      do iz=izs,ize
         do ix=jxs,jxe
         do iy=iy_cut_l,iy_cut_u
            wve(iy,ix,iz) = 0.0
         enddo
         enddo
      enddo
c
      if(jxe .lt. ix_cut) go to 999
c
         do iz=izs,ize
            do ix=max(jxs,ix_cut),jxe
            do iy=1,nny
               wve(iy,ix,iz) = 0.0
            enddo
            enddo
         enddo
c
  999 continue
c
      return
      end
      subroutine sharp_bndy(wve,ix_cut,iy_cut_l,iy_cut_u)
c
c --------- sharp cutoff filter for boundary array
c           in 2d-fft order
c
      use pars
      real wve(nny,jxs:jxe)
c
      do ix=jxs,jxe
      do iy=iy_cut_l,iy_cut_u
         wve(iy,ix) = 0.0
      enddo
      enddo
c
      if(jxe .lt. ix_cut) go to 999
c
         do ix=max(jxs,ix_cut),jxe
         do iy=1,nny
            wve(iy,ix) = 0.0
         enddo
         enddo
c
  999 continue
c
      return
      end
      subroutine gridd
c
c ----------- allocate space and pass arrays using modules
c
      use pars
      use fields
      use fftwk
      use con_data
      use con_stats
      use particles
c
c ------------- establish association between pointers
c               and data structures
c
      call fill_cc
      call fill_cs
c
      if (myid==0) write(6,5001) isize
 5001 format(' size of stats array = ',i8)
c
c ---------------- debug for arrays
c
      big = -99.0e+300
c
c ---------------- setup grid
c
      nnx = nxg1
      nny = nyg1
      nnz = nzg1
c     izs = 1
c     ize = nnz
c
c
c ----------- make sure problem and cpu's match
c
      maxp   = numprocs-1
      ncpu_z = numprocs/ncpu_s
      if(mod(numprocs,ncpu_s) .ne. 0 .or.
     +   ncpu_z .gt. nnz) then
         go to 999
      endif
      if(l_root) write(6, 1100) ncpu_s, ncpu_z, numprocs,
     +                          maxp
      write(nprt,1100) ncpu_s, ncpu_z, numprocs, maxp
 1100 format(' Number of x-y slab cpus = ',i5,/,
     +       ' Number of z-level cpus  = ',i5,/,
     +       ' Total number of cpus    = ',i5,/,
     +       ' Max-p for index arrays  = ',i5)
c
c ---------------- allocate arrays for (i,j,k)-indexing on
c                  each processor (see set_range)
c
      allocate(ix_s(0:maxp), ix_e(0:maxp),
     +         jx_s(0:maxp), jx_e(0:maxp),
     +         kx_s(0:maxp), kx_e(0:maxp),
     +         mx_s(0:maxp), mx_e(0:maxp),
     +         iy_s(0:maxp), iy_e(0:maxp),
     +         jy_s(0:maxp), jy_e(0:maxp),
     +         is_s(0:maxp), is_e(0:maxp),
     +         iz_s(0:maxp), iz_e(0:maxp),
     +         i2x_s(0:maxp), i2x_e(0:maxp))
c
c ---------------- setup array sizes and variable dimensions
c
      nxy   = nnx*nny
      ncx   = nnx/2 + 1
      ncy   = nny/2 + 1
      nnxp1 = nnx + 1
      nnyp1 = nny + 1
      nnxp2 = nnx + 2
      nnyp2 = nny + 2
      nnzp1 = nnz + 1
      nnzm1 = nnz - 1
      ivis = ivis0
      fnxy  = 1.0/float(nnx*nny)
c
      write(nprt,7001) nnx,nny,nnz
 7001 format(' 7001 gridd nnx = ',i4,' nny = ',i4,' nnz = ',i4)
c
      call set_range
c
      num_y = iye + 1 - iys
c
c ------------- allocate solution arrays
c               account for nnxp2 for fields but not in rhs
c               and possible monotone for scalars
c
      allocate(u(nnxp2,iys:iye,izs-1:ize+1), 
     +         v(nnxp2,iys:iye,izs-1:ize+1), 
     +         w(nnxp2,iys:iye,izs-1:ize+1), 
     +         t(nnxp2,iys:iye,nscl,izs-2:ize+2), 
     +         e(nnxp2,iys:iye,izs-1:ize+1), 
     +         r1(nnx,iys:iye,izs-1:ize+1),
     +         r2(nnx,iys:iye,izs-1:ize+1),
     +         r3(nnx,iys:iye,izs-1:ize+1),
     +         r4(nnx,iys:iye,nscl,izs-1:ize+1),
     +         r5(nnx,iys:iye,izs-1:ize+1),
     +         rj(nnx,iys:iye,izs-1:ize+1),
     +         uf(nnxp2,iys:iye,izs-1:ize+1),
     +         vf(nnxp2,iys:iye,izs-1:ize+1),
     +         wf(nnxp2,iys:iye,izs-1:ize+1),
     +         ufi(nnxp2,iys:iye,izs-1:ize+1),
     +         vfi(nnxp2,iys:iye,izs-1:ize+1),
     +         wfi(nnxp2,iys:iye,izs-1:ize+1))
c
c ------------- allocate space for grid and metrics
c
      allocate(xgrid(nnx),
     +         ygrid(nny),
     +         zgrid_w(nnx,iys:iye,izs-1:ize+1,3),
     +         zgrid_u(nnx,iys:iye,izs-1:ize+1),
     +         gm(nnx,iys:iye,izs-1:ize+1,5),
     +         gm2(nnx,iys:iye,izs-1:ize+1,5),
     +         gm3(nnx,iys:iye,izs-1:ize+1,5),
     +         gms(nnx,iys:iye,3),
     +         bndy(nnxp2,iys:iye),
     +         hdot(nnxp2,iys:iye),
     +         u_orbit(nnxp2,iys:iye), 
     +         v_orbit(nnxp2,iys:iye),
     +         w_orbit(nnxp2,iys:iye),
     +         bndy_t(nnx,iys:iye,3),
     +         hdot_t(nnx,iys:iye,3),
     +         z1b(nnx,iys:iye), 
     +         z1b_2(nnx,iys:iye),
     +         z1b_3(nnx,iys:iye))

c
c ------------- allocate extended arrays for interpolation of
c               particle/spray location
c
      if (ispray==1) then
      allocate(uext(0:nnz+1,iys-2:iye+3,mxs-2:mxe+3), 
     +         vext(0:nnz+1,iys-2:iye+3,mxs-2:mxe+3), 
     +         wext(0:nnz+1,iys-2:iye+3,mxs-2:mxe+3),
     +         Text(0:nnz+1,iys-2:iye+3,mxs-2:mxe+3)) 
      !Transposed velocities to do the uf interpolation:
      allocate(u_t(0:nnz+1,iys:iye,mxs:mxe),
     +         v_t(0:nnz+1,iys:iye,mxs:mxe),
     +         w_t(0:nnz+1,iys:iye,mxs:mxe),
     +         T_t(0:nnz+1,iys:iye,mxs:mxe))
      end if
      !Keep track of particle counts at each node (its surrounding volume)
      !NOTE: allocate even if ispray == 0, since it's in xy_stats
      allocate(partcount(nnx,iys:iye,izs-1:ize+1))
      allocate(partcount_t(0:nnz+1,iys:iye,mxs:mxe))
      allocate(upwp_t(0:nnz+1,iys:iye,mxs:mxe))
      allocate(upwp(nnx,iys:iye,izs-1:ize+1))
      allocate(vpsum(nnx,iys:iye,izs-1:ize+1,1:3))
      allocate(vpsum_t(0:nnz+1,iys:iye,mxs:mxe,1:3))
      allocate(vpsqrsum(nnx,iys:iye,izs-1:ize+1,1:3))
      allocate(vpsqrsum_t(0:nnz+1,iys:iye,mxs:mxe,1:3))
      allocate(Tpsum(nnx,iys:iye,izs-1:ize+1))
      allocate(Tpsum_t(0:nnz+1,iys:iye,mxs:mxe))
      allocate(Tpsqrsum(nnx,iys:iye,izs-1:ize+1))
      allocate(Tpsqrsum_t(0:nnz+1,iys:iye,mxs:mxe))
      allocate(wpTpsum(nnx,iys:iye,izs-1:ize+1))
      allocate(wpTpsum_t(0:nnz+1,iys:iye,mxs:mxe))
      allocate(partsrc(nnx,iys:iye,izs-1:ize+1,1:3))
      allocate(partsrc_t(0:nnz+1,iys:iye+1,mxs:mxe+1,1:3))
      allocate(partTsrc(nnx,iys:iye,izs-1:ize+1))
      allocate(partTsrc_t(0:nnz+1,iys:iye+1,mxs:mxe+1))

c
c ------------- allocate space for boundary condition arrays
c               on top and bottom of domain
c
      allocate(ubc(nnx,iys:iye,2),
     +         vbc(nnx,iys:iye,2),
     +         wbc(nnx,iys:iye,2),
     +         tbc(nnx,iys:iye,nscl,2),
     +         ebc(nnx,iys:iye,2),
     +         pbc(nnx,iys:iye,2),
     +         pbc2(nnx,iys:iye,2),
     +         ufbc(nnx,iys:iye,2),
     +         vfbc(nnx,iys:iye,2),
     +         wfbc(nnx,iys:iye,4))
c
c ------------ allocate space for wind and surface arrays
c
      allocate(wind(nnx,iys:iye), 
     +         tau13m(nnx,iys:iye), 
     +         tau23m(nnx,iys:iye), 
     +         taut3m(nnx,iys:iye,nscl), 
     +         t_grnd(nnx,iys:iye,nscl))
c
c ------------------- allocate space for derivative arrays
c
      allocate(ux(nnx,iys:iye,izs-1:ize+1),
     +         uy(nnx,iys:iye,izs-1:ize+1),
     +         vx(nnx,iys:iye,izs-1:ize+1),
     +         vy(nnx,iys:iye,izs-1:ize+1),
     +         wx(nnx,iys:iye,izs-1:ize+1),
     +         wy(nnx,iys:iye,izs-1:ize+1))
c
c ------------- allocate space for pressure, pressure bcs
c
      allocate(p(nnxp2,iys:iye,izs-1:ize+1),
     +         p_old(nnxp2,iys:iye,izs-1:ize+1),
     +         ptop(nnxp2,iys:iye,2))
c
c ------------- allocate space for viscosity and diffusivity
c
      allocate(vis_m(nnx,iys:iye,izs-1:ize+1),
     +         vis_s(nnx,iys:iye,izs-1:ize+1))
c
c ------------- allocate space for tau bc
c
      allocate(t11bc(nnx,iys:iye),
     +         t12bc(nnx,iys:iye),
     +         t13bc(nnx,iys:iye),
     +         t22bc(nnx,iys:iye),
     +         t23bc(nnx,iys:iye),
     +         t33bc(nnx,iys:iye),
     +         ustar(nnx,iys:iye),
     +         amol(nnx,iys:iye),
     +         t1tbc(nnx,iys:iye,nscl),
     +         t2tbc(nnx,iys:iye,nscl),
     +         t3tbc(nnx,iys:iye,nscl))
c
c ------------- allocate space for fft trig factors
c
      nq_trig = max(nnx,nny)
      allocate(trigx(2*nq_trig+15,2),
     +         trigc(4*nq_trig+15), trigcx(4*nq_trig+15))
      return
  999 continue
c
      if(l_root) write(6,1000) numprocs, ncpu_s, mmz
      write(nprt,1000) numprocs, ncpu_s, nnz
 1000 format(' Gridd Trouble number of processors and grid',
     +          ' partitioning do not match!',/,
     +          ' Total num of cpus   = ',i5,
     +          ' Num cpu on x-y slab = ',i5,/,
     +          ' Num of z-levels     = ',i5)
      call mpi_finalize(ierr)
      end
      subroutine restart
c
c ----------- get restart file from local directory
c
      use pars
      use fields
      use con_data
      use con_stats
      character*80 path_res_c
      logical there
c
c --------------------- check if file is there
c
      inquire(file=path_res,exist=there)
      if(there) then
         if(l_root) write(6,6001) path_res
      else
         if(l_root) write(6,6005) path_res
         stop
      endif
c
c ------------------ get constant file
c
      iloc = index(path_res,' ')
      path_res_c = path_res(1:iloc-1)//'.con'
      inquire(file=path_res_c,exist=there)
      if(there) then
         if(l_root) write(6,6002) path_res_c
      else
         if(l_root) write(6,6006) path_res_c
         stop
      endif
      open(nvelc,err=200,file=path_res_c,form='unformatted',
     +        status='old')
c
      call read_res
c
      return
c ---------------------------- process errors
  100 continue
      write(6,9000) path_res, nvel
      call mpi_finalize(ierr)
      stop
c -----------------------
  200 continue
      write(6,9001) path_res_c, nvelc
      call mpi_finalize(ierr)
      stop
c -----------------------
 6001 format(' SR. RESTART: FILE READ = ',A80)
 6002 format(' SR. RESTART: CONSTANT FILE READ = ',A80)
 6005 format(' 6005, SR. RESTART: cannot find restart file = ',a80)
 6006 format(' 6005, SR. RESTART: cannot find constant file = ',a80)
 9000 format(' 9000, SR. RESTART: cannot open file =',a80,/,
     +       ' to unit number = ',i2)
 9001 format(' 9001, SR. RESTART: cannot open file =',a80,/,
     +       ' to unit number = ',i2)
      end
      subroutine read_res
c
c -------------- read restart file including constant file
c                changed for iys:iye
c
      use pars
      use fields
      use con_data
      use con_stats
#if defined(SWAP)
      use module_byteswap
#endif
      include 'mpif.h'
c
      integer status(mpi_status_size), ierr
      integer(kind=mpi_offset_kind) :: offset, disp
      integer(kind=k8)              :: nsize, nsize2
      real, allocatable, dimension(:,:,:) :: temp
      allocate(temp(nvar+4,nnx,iys:iye))
c
c ---- open file
c
      call mpi_file_open(mpi_comm_world, path_res,
     +                   mpi_mode_create+mpi_mode_rdwr,
     +                   mpi_info_null, nvel, ierr)
c
c ---- set file view
c
      disp = 0
      call mpi_file_set_view(nvel,disp,mpi_real8,mpi_real8,
     +                      'native',mpi_info_null,ierr)
c
c ------------ read 3d fields
c
      nsize  = int(nvar+4,k8)*nnx*nny
      nsize2 = int(nvar+4,k8)*nnx*(iys-1)
      n_read = (nvar+4)*nnx*(iye+1-iys)
c
      do k=izs,ize
         offset = int((k-1),k8)*nsize + nsize2
         call mpi_file_read_at_all(nvel,offset,temp,n_read,
     +                              mpi_real8,status,ierr)
         if (ierr /= 0) goto 9992
#if defined(SWAP)
         call byteswap(temp)
#endif
         do j=iys,iye
         do i=1,nnx
            u(i,j,k)    = temp(1,i,j) 
            v(i,j,k)    = temp(2,i,j)
            w(i,j,k)    = temp(3,i,j)
            uf(i,j,k)   = temp(4,i,j) 
            vf(i,j,k)   = temp(5,i,j)
            wf(i,j,k)   = temp(6,i,j)
            e(i,j,k)    = temp(nvar+3,i,j)
            gm(i,j,k,5) = temp(nvar+4,i,j)
         enddo
         enddo
         do is = 1,nscl
            do j = iys,iye
            do i = 1,nnx
               t(i,j,is,k) = temp(6+is,i,j)
            enddo
            enddo
         enddo
c
      enddo
c
c ---- close file
c
      call mpi_file_close(nvel, ierr)
c
      deallocate(temp)
c
c ------------ every mpi process reads constant file
c
      rewind(nvelc)
      read(nvelc,err=9993) c_c, c_s, case
      close(nvelc)
c
      if(l_root) write(6,4001) case
 4001 format(' 4001, SR. RESTART: case from restart = ',a3)
c
c ----- special restart conditions -------------------------------------
c
c -------- set case name to case input
c
      case   = case_inp
      if(l_root) write(6,4002) case_inp, utau, utausv
 4002 format(' 4002, SR. RESTART:',/,
     +       ' files will be saved with case name = ',a3,/,
     +       ' utau = ',e15.6,' utausv = ',e15.6)
c
c ------------------- if new vis model set match point for
c                     outer grid
      nmatch = 48
      utau = utausv
c
c -------- hand coded changes to restart if needed
c
        qstars = 0.000
        wtsfcs = 0.000
        zos    = 250.0e-06
c
c
c ------ reset qstar and wtsfc for no heat flux
c
c              qstar(1) = qstars
c              wtsfc(1) = wtsfcs
c              qstar(2) = qstars
c              wtsfc(2) = wtsfcs
c              zo       = zos
c ------ redefine case id to input value
c              case = cases
c
c
c --------- flaw in t_zero ... fix in later runs
c
      if(iti .lt. i_move_step) then
         t_zero = time
      endif
c
      if(l_root) write(6,4012) time, t_zero, dt, dt1, dt_new
      if(l_root) write(6,4013) qstar(1) , nmatch, case, zo
c
      call get_dz
c
      return
c ------------------------  process errors from read
c9991 continue
c     write(6,6000) nvel,iz
c6000 format(' SR. READ_RES: hit end of file on unit number = ',i2,/,
c    +       '               at iz = ',i4)
c     call mpi_finalize(ierr)
c     stop
c ---------------------
 9992 continue
      write(6,6100) nvel,iz
 6100 format(' SR. READ_RES: error reading file on unit number = ',i2,/,
     +       '               at iz = ',i4)
      call mpi_finalize(ierr)
      stop
c ---------------------
 9993 continue
      write(6,6200) nvelc
 6200 format(' SR. READ_RES:',/,
     +       '    error reading constant file on unit number = ',i2)
      call mpi_finalize(ierr)
      stop
c ---------------------
 4012 format(' SR. RESTART: ',/,
     +       ' T = ',e15.6,5x,' T_zero = ',e15.6,/,
     +       ' dt = ',e15.6,' dt1 = ',e15.6,' dt_new = ',e15.6)
 4013 format(' after restart qstar = ',e15.6,' nmatch = ',i5,
     +       ' case = ',a3,' zo = ',e15.6)
      end
      subroutine save_viz(it)
c
c --------------- save multiple (x-y), (x-z), (y-z), planes of data .
c                 modify recl in all open statements for more or less
c                 variables. 
c                 Constant - x, implies yz planes
c                 Constant - y, implies xz planes
c                 Constant - z, implies xy planes
c
c ------------- routine uses send/recv to get information in y-z planes
c
      use pars
      use fields
      use con_data
      use con_stats
      use fftwk
#if defined(SWAP)
      use module_byteswap
#endif
      include 'mpif.h'
c
c ------ for xz and yz planes output z grid also
c
      parameter(nvar_o = 6, nvar_o1 = nvar_o + 1)
c
      integer ix_pick(maxnx),  iy_pick(maxny),  iz_pick(maxnz), 
     +        ix_order(maxnx), iy_order(maxny), iz_order(maxnz)
c
      integer istatus(mpi_status_size), ierr
      integer(kind=mpi_offset_kind) :: offset, disp
      integer(kind=k8)              :: nsize, nsize2
c
      real(kind=4), dimension(nvar_o1,nny,izs:ize) :: temp_x
      real(kind=4), dimension(nvar_o1,nnx,izs:ize) :: temp_y
      real(kind=4), dimension(nvar_o,nnx,iys:iye)  :: temp_z
      real, dimension(nvar_o1,iys:iye,izs:ize)     :: buf_send
      real(kind=8), dimension(nnx,0:nnz)           :: z_xz
      real(kind=8), dimension(nny,0:nnz)           :: z_yz
c
c ------------- don't touch
c
      data iviz_x,  iviz_y,  iviz_z  /0, 0, 0/
      data ionce_x, ionce_y, ionce_z, istuff /0, 0, 0, 0/
      data ix_pick, iy_pick, iz_pick /maxnx*0, maxny*0, maxnz*0/
      data ix_order, iy_order, iz_order /maxnx*0, maxny*0, maxnz*0/
      save iviz_x,  iviz_y,  iviz_z, 
     +     ix_pick, iy_pick, iz_pick, 
     +     ix_order, iy_order, iz_order,
     +     ionce_x, ionce_y, ionce_z, istuff,
     +     npln_x, npln_y, npln_z
c
c
c ----------- turn on z levels to save. Customize for your own use.
c             Set iz_pick(iz) = iz, ix_pick(ix) = ix, iy_pick(iy) = iy
c             Data is round-robin alternated in the data file for more than
c             1 plane for any particular view.
c
      iz_pick(3)   = 3
      iz_pick(6)   = 6
      iz_pick(10)  = 10
      iz_pick(20)  = 20
      iz_pick(40)  = 40
      iz_pick(85)  = 85
      iz_pick(100) = 100
c
c -------------- pick an x-z plane of data (can add more)
c
      iy_pick(1)         = 1
      iy_pick(nny/4)     = nny/4
      iy_pick(nny/2)     = nny/2
      iy_pick((3*nny)/4) = (3*nny)/4
c
c -------------- pick a y-z plane of data (can add more)
c
      ix_pick(nnx/4) = nnx/4
      ix_pick(nnx/2) = nnx/2
      ix_pick(nnx)   = nnx
c
c ------ find total number of z's turned on and open file once
c
      if(ionce_z .eq. 0) then
         npln_z = 0
         do k=1,nnz
            if(iz_pick(k) .eq. k) then
               npln_z = npln_z + 1
               iz_order(k) = npln_z
            endif
         enddo
         ionce_z = 1
         iviz_z =  -npln_z
         if(npln_z .ne. 0) then
            call mpi_file_open(mpi_comm_world, path_viz_xy,
     +                         mpi_mode_create+mpi_mode_rdwr,
     +                         mpi_info_null, nviz_z, ierr)
            disp = 0
            call mpi_file_set_view(nviz_z,disp,mpi_real4,mpi_real4,
     +                            'native',mpi_info_null,ierr)
         endif
      endif
c
c ------ find total number of y's turned on and open file once
c
      if (ionce_y .eq. 0) then
         npln_y = 0
         do j=1,nny
            if(iy_pick(j) .eq. j) then
               npln_y = npln_y + 1
               iy_order(j) = npln_y
            endif
         enddo
         ionce_y = 1
         iviz_y  = -npln_y
         if(npln_y .ne. 0) then
            call mpi_file_open(mpi_comm_world, path_viz_xz,
     +                         mpi_mode_create+mpi_mode_rdwr,
     +                         mpi_info_null, nviz_y, ierr)
            disp = 0
            call mpi_file_set_view(nviz_y,disp,mpi_real4,mpi_real4,
     +                            'native',mpi_info_null,ierr)
         endif
      endif
c
c ------ find total number of x's turned on and open file once
c
      if(ionce_x .eq. 0) then
         npln_x = 0
         do i=1,nnx
            if(ix_pick(i) .eq. i) then
               npln_x = npln_x + 1
               ix_order(i) = npln_x
            endif
         enddo
         ionce_x = 1
         iviz_x  = -npln_x
         if(npln_x .ne. 0) then
            call mpi_file_open(mpi_comm_world, path_viz_yz,
     +                         mpi_mode_create+mpi_mode_rdwr,
     +                         mpi_info_null, nviz_x, ierr)
            disp = 0
            call mpi_file_set_view(nviz_x,disp,mpi_real4,mpi_real4,
     +                            'native',mpi_info_null,ierr)
         endif
      endif
c
      if(istuff .eq. 0 .and. l_root) then
         open(nviz_s,file=path_stuf)
         istuff = 1
      endif
c
c --------- write data, subtract t_ref to increase
c           resolution on 32 bit machines
c
c ---------- xy planes of data
c
      iviz_z  = iviz_z + npln_z
      nsize   = int(nvar_o,k8)*nnx*nny
      nsize2  = int(nvar_o,k8)*nnx*(iys-1)
      n_write = nvar_o*nnx*(iye+1-iys)
      do k=izs,ize
         if(iz_pick(k) .eq. k) then
            km1 = k - 1
            do j=iys,iye
            do i=1,nnx
               temp_z(1,i,j) = u(i,j,k)
               temp_z(2,i,j) = v(i,j,k)
               temp_z(3,i,j) = w(i,j,k)
               temp_z(4,i,j) = (t(i,j,1,k) - t_ref)
c
c ---------- get the pressure field assumes flux form for advection
c
               temp_z(5,i,j) = p(i,j,k) - c23*e(i,j,k) - pxym(k)
c
c ---------- get the flux velocity minus the grid speed
c
               temp_z(6,i,j) = wf(i,j,k) - gm(i,j,k,5)
            enddo
            enddo
#if defined(SWAP)
            call byteswap(temp_z)
#endif
            offset = int((iviz_z + iz_order(k) - 1),k8)*nsize + nsize2
            call mpi_file_write_at(nviz_z,offset,temp_z,n_write,
     +                             mpi_real4,istatus,ierr)
            if (ierr .ne. 0) go to 9991
         endif
      enddo
c
c ---------- xz planes of data
c
      iviz_y = iviz_y + npln_y
      nsize  = int(nvar_o1,k8)*nnx*nnz
      nsize2 = int(nvar_o1,k8)*nnx*(izs-1)
      nwrite = (nvar_o1)*nnx*(ize+1-izs)
      do j=iys,iye
         if(iy_pick(j) .eq. j) then
            do k=izs,ize
            km1 = k - 1
            do i=1,nnx
               temp_y(1,i,k) = u(i,j,k)
               temp_y(2,i,k) = v(i,j,k)
               temp_y(3,i,k) = w(i,j,k)
               temp_y(4,i,k) = (t(i,j,1,k) - t_ref)
c
c ---------- get the pressure field
c
               temp_y(5,i,k) =  p(i,j,k) - pxym(k) - c23*e(i,j,k)
c
c ---------- get the flux velocity minus the grid speed
c
               temp_y(6,i,k) = wf(i,j,k) - gm(i,j,k,5)
c
c ---------- the shape of the gridlines
c
               temp_y(7,i,k) =  0.5*(zgrid_w(i,j,km1,1) + 
     +                               zgrid_w(i,j,k,1))
            enddo
            enddo
#if defined(SWAP)
            call byteswap(temp_y)
#endif
            offset = int((iviz_y + iy_order(j) - 1),k8)*nsize + nsize2
            call mpi_file_write_at(nviz_y,offset,temp_y,nwrite,
     +                                mpi_real4,istatus,ierr)
            if (ierr .ne. 0) goto 9992
         endif
      enddo
c
c ---------- yz planes that cut across all processors
c            just have root node on that slab write data
c
      iviz_x  = iviz_x + npln_x
      n_write = nvar_o1*nny*(ize+1-izs)
      nsize   = int(nvar_o1,k8)*nny*nnz
      nsize2  = int(nvar_o1,k8)*nny*(izs-1)
      n_send  = nvar_o1*(ize+1-izs)*(iye+1-iys)
      do i=1,nnx
         if(ix_pick(i) .eq. i) then
c
c ----------- build send buffer
c
            do k=izs,ize
            km1 = k - 1
            do j=iys,iye
               buf_send(1,j,k) = u(i,j,k)
               buf_send(2,j,k) = v(i,j,k)
               buf_send(3,j,k) = w(i,j,k)
               buf_send(4,j,k) = (t(i,j,1,k) - t_ref)
c
c ---------- get the pressure field
c
               buf_send(5,j,k) = p(i,j,k) - pxym(k) - c23*e(i,j,k)
c
c ---------- get the flux velocity minus the grid speed
c
               buf_send(6,j,k) = wf(i,j,k) - gm(i,j,k,5)
c
c ---------- shape of the gridlines
c
               buf_send(7,j,k) = 0.5*(zgrid_w(i,j,km1,1) + 
     +                                zgrid_w(i,j,k,1))
            enddo
            enddo
            if(myid .ne. iss) then
              call mpi_send(buf_send(1,iys,izs),n_send,
     +                      mpi_real8,iss,1,
     +                      mpi_comm_world,ierr)
            else
              do k=izs,ize
              do j=iys,iye
              do ii=1,nvar_o1
                 temp_x(ii,j,k) = buf_send(ii,j,k)
              enddo
              enddo
              enddo
              do l=iss+1,ise
                 call recv_yz_var(temp_x,nvar_o1,nny,
     +                            iy_s(l),iy_e(l),izs,ize,l)
              enddo
#if defined(SWAP)
              call byteswap(temp_x)
#endif
              offset = int((iviz_x + ix_order(i) - 1),k8)*nsize + nsize2
              call mpi_file_write_at(nviz_x,offset,temp_x,n_write,
     +                          mpi_real4,istatus,ierr)
              if (ierr .ne. 0) goto 9993
            endif
         endif
      enddo
c
c ------------- ascii file with facts in it that goes
c               with visualization
c
      if(l_root) then
         write(nviz_s,5000) time, amonin, zi, utau
 5000    format(4e20.8)
      endif
c
c ---- last time step or hit mtape close the files
c
      if (it .eq. itmax .or. mtape) then
         if(npln_z .ne. 0) then
            call mpi_file_close(nviz_z, ierr)
            ionce_z = 0
         endif
         if(npln_y .ne. 0) then
            call mpi_file_close(nviz_y, ierr)
            ionce_y = 0
         endif
         if(npln_x .ne. 0) then
            call mpi_file_close(nviz_x, ierr)
            ionce_x = 0
         endif
         if(l_root) then
            close(nviz_s)
            istuff = 0
         endif
      endif
c
      return
c --------------------------  errors in writing viz file
 9991 continue
      write(6,6000) nviz_z, iz
 6000 format(' SR. SAVE_VIS:',/,
     +       '    trouble cannot write xy viz file on unit = ',i2,/,
     +       '             at iz = ',i4)
      call mpi_finalize(ierr)
      stop
c --------------------------  errors in writing viz file
 9992 continue
      write(6,6100) nviz_y, iz, iviz_y
 6100 format(' SR. SAVE_VIS:',/,
     +       '    trouble cannot write xz viz file on unit = ',i2,/,
     +       '             at iz = ',i4,/,
     +       '            iviz_y = ',i8)
c --------------------------  errors in writing viz file
 9993 continue
      write(6,6200) nviz_x, iz, iviz_x
 6200 format(' SR. SAVE_VIS:',/,
     +       '    trouble cannot write yz viz file on unit = ',i2,/,
     +       '             at iz = ',i4,/,
     +       '            iviz_x = ',i8)
      call mpi_finalize(ierr)
      stop
      end
      subroutine save_bndy(it)
c
c --------------- save boundary shape and boundary speed
c                 as function of time
c                 at same time step as viz files
c
      use pars
      use fields
      use con_data
      use con_stats
      use fftwk
#if defined(SWAP)
      use module_byteswap
#endif
      include 'mpif.h'
c
      parameter(nvar_o = 2)
c
      integer istatus(mpi_status_size), ierr
      integer(kind=mpi_offset_kind) :: offset, disp
      integer(kind=k8)              :: nsize, nsize2
c
      real(kind=4), dimension(2,nnx,iys:iye) :: temp_z
c
c ------------- don't touch
c
      data ionce_z, iviz_z /0, 0/
      save ionce_z, iviz_z
c
c ------ open file once
c
c     write(nprt,4341) nbndy, path_bndy
 4341 format(' 4341 nbndy = ',i5,' path_bndy = ',a80)
c
      if(ionce_z .eq. 0) then
        ionce_z = 1
        call mpi_file_open(mpi_comm_world, path_bndy,
     +                     mpi_mode_create+mpi_mode_rdwr,
     +                     mpi_info_null, nbndy, ierr)
        disp = 0
        call mpi_file_set_view(nbndy,disp,mpi_real4,mpi_real4,
     +                        'native',mpi_info_null,ierr)
      endif
c
c ---------- xy plane of data
c
      iviz_z  = iviz_z + 1
      nsize   = int(nvar_o,k8)*nnx*nny
      nsize2  = int(nvar_o,k8)*nnx*(iys-1)
      n_write = nvar_o*nnx*(iye+1-iys)
c
      if(iss .ne. 0) go to 999
c
      k = 0
c
      do j=iys,iye
      do i=1,nnx
         temp_z(1,i,j) = bndy_t(i,j,1)
         temp_z(2,i,j) = gm(i,j,k,5)
      enddo
      enddo
#if defined(SWAP)
      call byteswap(temp_z)
#endif
      offset = int((iviz_z - 1),k8)*nsize + nsize2
      call mpi_file_write_at(nbndy,offset,temp_z,n_write,
     +                       mpi_real4,istatus,ierr)
      if (ierr .ne. 0) go to 9991
c
  999 continue
c
c ---- last time step or hit mtape close the files
c
      if(it .eq. itmax .or. mtape) then
         call mpi_file_close(nbndy, ierr)
         ionce_z = 0
         iviz_z  = 0
      endif
c
c
      return
c --------------------------  errors in writing bndy file
 9991 continue
      write(6,6000) nbndy
 6000 format(' SR. SAVE_BNDY:',/,
     +       '    trouble cannot write boundary file on unit = ',i2)
      call mpi_finalize(ierr)
      stop
      end
      subroutine recv_yz_var(temp_x,nvar,nny,iys,iye,izs,ize,ir)
c
      include 'mpif.h'
      integer istatus(mpi_status_size)
c
      real buf(nvar,iys:iye,izs:ize)
      real(kind=4), dimension(nvar,nny,izs:ize) :: temp_x
c
      num = nvar*(ize+1-izs)*(iye+1-iys)
      call mpi_recv(buf(1,iys,izs),num,mpi_real8,ir,1,
     +             mpi_comm_world,istatus,ierr)
      do k=izs,ize
      do j=iys,iye
      do ii=1,nvar
         temp_x(ii,j,k) = buf(ii,j,k)
      enddo
      enddo
      enddo
c
      return
      end
      subroutine save_v(it)
c
c --------------- save 3d fields
c
      use pars
      use fields
#if defined(SWAP)
      use module_byteswap
#endif
      include 'mpif.h'
      logical there
c
      integer status(mpi_status_size), ierr
      integer(kind=mpi_offset_kind) :: offset, disp
      integer(kind=k8)                 nsize, nsize2
c
      real, allocatable, dimension(:,:,:) :: temp
      allocate(temp(nvar+4,nnx,iys:iye))
c
c ---- open file
c
      call mpi_file_open(mpi_comm_world, path_sav_v,
     +                   mpi_mode_create+mpi_mode_rdwr,
     +                   mpi_info_null, nvel, ierr)
c
c ---- set file view
c
      disp = 0
      call mpi_file_set_view(nvel,disp,mpi_real8,mpi_real8,
     +                      'native',mpi_info_null,ierr)
c
c ---- write data
c
      nsize   = int(nvar+4,k8)*nnx*nny
      nsize2  = int(nvar+4,k8)*nnx*(iys-1)
      n_write = (nvar+4)*nnx*(iye+1-iys)
c
      do k=izs,ize
         do j = iys,iye
         do i = 1,nnx
            temp(1,i,j)      = u(i,j,k)
            temp(2,i,j)      = v(i,j,k)
            temp(3,i,j)      = w(i,j,k)
            temp(4,i,j)      = uf(i,j,k)
            temp(5,i,j)      = vf(i,j,k)
            temp(6,i,j)      = wf(i,j,k)
            temp(nvar+3,i,j) = e(i,j,k)
            temp(nvar+4,i,j) = gm(i,j,k,5)
         enddo
         enddo
         do is = 1,nscl
            do j = iys,iye
            do i = 1,nnx
               temp(6+is,i,j) = t(i,j,is,k)
            enddo
            enddo
         enddo
#if defined(SWAP)
      call byteswap(temp)
#endif
c
         offset = int((k-1),k8)*nsize + nsize2
c        call mpi_file_write_at_all(nvel,offset,temp,n_write,
         call mpi_file_write_at(nvel,offset,temp,n_write,
     +                              mpi_real8,status,ierr)
         if (ierr /= 0) goto 9991
c
      enddo
c
c ---- close file
c
      call mpi_file_close(nvel, ierr)
c
c ---- check file
c
      if (l_root) then
         inquire(file=path_sav_v,exist=there)
         if(.not.there) then
            write(6,8000) nvel,myid
            call mpi_finalize(ierr)
            stop
         endif
         write(6,7000) it,path_sav_v
      endif
c
      deallocate(temp)
c
      return
c --------------------------  errors in writing restart file
 9991 continue
      write(6,6000) nvel, iz
 6000 format(' SR. SAVE_V:',/,
     +       '    trouble cannot write restart file on unit = ',i2,/,
     +       '             at iz = ',i4)
      call mpi_finalize(ierr)
      stop
c --------------------
 7000 format(' **** DATA SET AT IT = ',I6,/,
     +       '      VELOCITY DATA IS WRITTEN IN FILE  ',a80)
 8000 format(' in SAVE_V: trouble writing file ',i5,'  myid = ',i5,
     +       ' at iz = ',i5)
      end
      subroutine save_c(it)
c
c --------------- root process writes constant file
c                 sequential fortan binary
c
      use pars
      use fields
      use fftwk
      use con_data
      use con_stats
c
      logical there
      character options*8, passwd*1
c
c ---- open file
c
      open(nvelc,err=9992,file=path_sav_c,form='unformatted',
     +                status='unknown')
      write(nvelc,err=9992) c_c, c_s, case
      close(nvelc)
c
        inquire(file=path_sav_c,exist=there)
        if(.not.there) then
           write(6,8001) path_sav_c
           call mpi_finalize(ierr)
           stop
        endif
c -----------------------------  output ok message
      write(6,7001) path_sav_c
c
      return
c --------------------------  errors in writing constant file
 9992 continue
      write(6,6100) nvelc
 6100 format(' SR. SAVE_V:',/,
     +  '    trouble cannot open/write constant file on unit = ',i2)
      call mpi_finalize(ierr)
      stop
c ---------------------
 7001 format('      CONSTANT DATA IS WRITTEN IN FILE  ',a80)
 8001 format(' SR. SAVE_C: Trouble constant file not in path =',a80)
      end
      subroutine save_p
c
c -------------- save pressure file
c
      use pars
      use fields
#if defined(SWAP)
      use module_byteswap
#endif
      include 'mpif.h'
      logical there
c
      integer status(mpi_status_size), ierr
      integer(kind=mpi_offset_kind) :: offset, disp
      integer(kind=k8)              :: nsize, nsize2
c
      real temp(nnx,iys:iye)
c
c ---- open file
c
      call mpi_file_open(mpi_comm_world, path_sav_p,
     +                   mpi_mode_create+mpi_mode_rdwr,
     +                   mpi_info_null, npre, ierr)
c
c ---- set file view
c
      disp = 0
      call mpi_file_set_view(npre,disp,mpi_real8,mpi_real8,
     +                      'native',mpi_info_null,ierr)
c
c ---- write data
c
      nsize   = int(nnx,k8)*nny
      nsize2  = int(nnx,k8)*(iys -1)
      n_write = nnx*(iye+1-iys)
      do k=izs,ize
         do j=iys,iye
         do i=1,nnx
            temp(i,j) = p(i,j,k)
         enddo
         enddo
#if defined(SWAP)
      call byteswap(temp)
#endif
         offset = int((k-1),k8)*nsize + nsize2
         call mpi_file_write_at(npre,offset,temp,n_write,
     +                              mpi_real8,status,ierr)
      enddo
c
c ---- close file
c
      call mpi_file_close(npre, ierr)
c
c ---- check file
c
      if (l_root) then
         inquire(file=path_sav_p,exist=there)
         if(.not.there) then
            write(6,8000) path_sav_p
            call mpi_finalize(ierr)
            stop
         endif
         write(6,7000) path_sav_p
      endif
c
      return
c -------------------- process write errors
 9991 continue
      write(6,6000) npre, iz
 6000 format(' SR. SAVE_P:',/,
     +       '    trouble cannot write pressure file on unit = ',i2,/,
     +       '             at iz = ',i4)
      call mpi_finalize(ierr)
      stop
c -----------------------
 7000 format('      PRESSURE DATA IS WRITTEN IN FILE  ',a80)
 8000 format(' SR. SAVE_P: Trouble pressure file not in path =',a80)
      end
      subroutine get_units
c
      use pars
c
c -------------- unit numbers for files
c
      nvel   = 20 
      npre   = 30
      nhis1  = 40
      nvelc  = 50
      nhisp  = 60
      nviz_z = 80
      nviz_y = 82
      nviz_x = 84
      nviz_s = 90 
      nbndy  = 91 
      ngrd   = 25 
c
c ------------- unit number for standard print out
c               for each mpi task
c
      nprt = 1 
c
c ------------- open unit for standard printout
c
      path_prt = case_inp(1:3)//'.le.xxxxx.out'
      write(path_prt(8:12),'(i5.5)') myid
      open(nprt,file=path_prt,form='formatted')
c
      return
      end
      subroutine get_output_filenames
c
c ----------- build file names for velocity, pressure, and constants
c
      use pars
      include 'mpif.h'
      character cgrid*10, num*3
c
c --------------- build character strings for file name
c
      cgrid = '.le.'
      write(num,'(i3.3)') itn
      call blnk(path_sav_v)
      call blnk(path_sav_p)
      call blnk(path_sav_c)
      call blnk(path_sav_part)
      path_sav_v = trim(path_sav)//'/u'//
     +                 cgrid(1:4)//case(1:3)//num(1:3)
      path_sav_p = trim(path_sav)//'/p'//
     +                 cgrid(1:4)//case(1:3)//num(1:3)
      path_sav_c = trim(path_sav)//'/u'//
     +                 cgrid(1:4)//case(1:3)//num(1:3)//'.con'
      path_sav_part = trim(path_sav)//'/part'//
     +                 cgrid(1:4)//case(1:3)//num(1:3)
c     path_sav_g = trim(path_sav)//'/'//case(1:3)//'.grid'
c
      return
      end
      subroutine open_his(istep)
c
c ------------------- open history files by root
c                     isize determined in sr. fill_cs
c
      use pars
      include 'mpif.h'
      character cgrid*4, iblks*16
      logical there
c
c --------------- build character strings for ascii history file name
c
      cgrid = '.le.'
      call blnk(iblks)
      write(iblks(1:7),'(i7.7)') istep
      iblks(8:8) = '_'
      write(iblks(9:15),'(i7.7)') (istep + itape)
      iblnk = index(path_his,' ')
      call blnk(path_sav_h)
      path_sav_h = path_his(1:iblnk-1)//'/his'//
     +         cgrid(1:4)//case(1:3)//'.'//iblks(1:15)
c
c --------------- build character strings for ieee profile history file
c                 set record counter for direct access file = 0
c
      krec = 0
      cgrid = '.le.'
      call blnk(iblks)
      write(iblks(1:7),'(i7.7)') istep
      iblks(8:8) = '_'
      write(iblks(9:15),'(i7.7)') (istep + itape)
      iblnk = index(path_his,' ')
      call blnk(path_sav_hp)
      path_sav_hp = path_his(1:iblnk-1)//'/his'//
     +         cgrid(1:4)//case(1:3)//'.'//iblks(1:15)//'.ieee'
c
c ----------------- save data in directory
c
      if(l_root) then

      close(nhis1)
      open(nhis1,err=3000,file=path_sav_h,form='formatted')
c
      close(nhisp)
      open(nhisp,err=4000,file=path_sav_hp,
     +        form='unformatted',access='direct',recl=isize*j_recl,
     +        status='unknown')
      endif
c
      return
c ------------------- process errors
 3000 continue
      write(6,6301) nhis1, path_sav_h
 6301 format(' 6301, SR. OPEN_HIS:',/,
     +       '    cannot open history1 file on unit = ',i2,/,
     +       '    path = ',a80)
      stop
c-------------------
 4000 continue
      write(6,6302) nhisp, path_sav_hp
 6302 format(' 6302, SR. OPEN_HIS:',/,
     +       '    cannot open history profile file on unit = ',i2,/,
     +       '    path = ',a80)
      stop
      end
      subroutine range(n1,n2,nprocs,irank,ista,iend)
c
c ---------- the ibm range finder to balance load
c
      iwork1 = (n2 - n1 + 1)/nprocs
      iwork2 = mod(n2 - n1 +1, nprocs)
      ista = irank*iwork1 + n1 + min(irank,iwork2)
      iend = ista + iwork1 - 1
      if(iwork2 .gt. irank) iend = iend + 1
c
      return
      end
      subroutine viz_output_filename(istep)
c
c ------------------- set visualization files,
c                     leaves files in scratch directory
c
      use pars
      include 'mpif.h'
      character iblks*16
c
c --------------- build character strings for file names
c                 with time step
c
      call blnk(iblks)
      iblks(1:1) = '.'
      write(iblks(2:8),'(i7.7)') istep
      iblks(9:9) = '_'
      write(iblks(10:16),'(i7.7)') (istep + itape)
c
      iloc = index(path_seed,' ')
      path_viz_xy = path_seed(1:iloc-1)
     +         //'/viz.'//case(1:3)//iblks(1:16)//'.xy.data'
c
      path_viz_xz = path_seed(1:iloc-1)
     +         //'/viz.'//case(1:3)//iblks(1:16)//'.xz.data'
c
      path_viz_yz = path_seed(1:iloc-1)
     +         //'/viz.'//case(1:3)//iblks(1:16)//'.yz.data'
c
      path_stuf = path_seed(1:iloc-1)
     +         //'/stuff.'//case(1:3)//iblks(1:16)//'.data'
c
      path_bndy = path_seed(1:iloc-1)
     +         //'/bndy.'//case(1:3)//iblks(1:16)//'.data'
c
c     if(l_root) then
c        write(6,8001) path_viz_xy
c8001    format(' 8001: viz file = ',a80)
c        write(6,8001) path_viz_xz
c        write(6,8001) path_viz_yz
c        write(6,8001) path_stuf
c        write(6,8001) path_seed
c     endif
c
      return
      end
      subroutine set_range
c
c ---- build special x,y,z-ranges. dimensioned for 0:numprocs-1
c      indexed with myid
c
c      [ix_s:ix_e] x-range for computing y-derivatives nx-pts/ncpu_s
c                  in xtoy and ytox tranposes
c
c      [i2x_s:2ix_e] x-range for computing complx y-derivatives 2*nx-pts/ncpu_s
c                  in xtoy and ytox tranposes. special for moving surfaces
c
c      [jx_s:jx_e] x-range for computing 2d fft (nx+2)-pts/ncpu_s
c                  must be even in each x-interval for complex fft in y
c
c      [kx_s:kx_e] x-range for pressure solver transpose (nx+2)-pts/ncpu_z
c                  nx+2 fourier coefficients for xtoz and ztox transposes
c
c      [mx_s:mx_e] x-range split across z cpus as nx-pts/ncpu_z
c                  for use in surface layer routines 
c
c      [is_s:is_e] starting and ending processor id's for a
c                  particular z-level
c
c      [iy_s:iy_e] y-range for computing y-derivatives ny-pts/ncpu_s
c                  in xtoy and ytox tranposes
c
c      [jy_s:jy_e] y-range for use in xtoz and ztox transposes 
c                  in pressure solution
c
c      [iz_s:iz_e] z-range for a particular vertical slab
c
c
      use pars
c
      ii = -1
      do nn=0,ncpu_z-1
         call range(1,nnx+2,ncpu_z,nn,lx_s,lx_e)
         call range(1,nnx,ncpu_z,nn,nx_s,nx_e)
         call range(1,nny,ncpu_z,nn,ly_s,ly_e)
         call range(1,nnz,ncpu_z,nn,mz_s,mz_e)
         do mm=0,ncpu_s-1
            call range(1,nny,ncpu_s,mm,ny_s,ny_e)
            call range(1,nnx,ncpu_s,mm,nxy_s,nxy_e)
            call range(1,ncx,ncpu_s,mm,l2x_s,l2x_e)
            ii       = ii + 1
c
            ix_s(ii)  = nxy_s
            ix_e(ii)  = nxy_e
            i2x_s(ii) = (nxy_s - 1)*2 + 1
            i2x_e(ii) = nxy_e*2
            jx_s(ii)  = (l2x_s - 1)*2 + 1
            jx_e(ii)  = l2x_e*2
            kx_s(ii)  = lx_s
            kx_e(ii)  = lx_e
            mx_s(ii)  = nx_s
            mx_e(ii)  = nx_e
c
            iy_s(ii)  = ny_s
            iy_e(ii)  = ny_e
            jy_s(ii)  = ly_s
            jy_e(ii)  = ly_e
c
            iz_s(ii)  = mz_s
            iz_e(ii)  = mz_e
c
            is_s(ii)  = (ii/ncpu_s)*ncpu_s
            is_e(ii)  = is_s(ii) + ncpu_s - 1
         enddo
      enddo
c
      iys  =  iy_s(myid)
      iye  =  iy_e(myid)
      jys  =  jy_s(myid)
      jye  =  jy_e(myid)
      ixs  =  ix_s(myid)
      ixe  =  ix_e(myid)
      jxs  =  jx_s(myid)
      jxe  =  jx_e(myid)
      kxs  =  kx_s(myid)
      kxe  =  kx_e(myid)
      mxs  =  mx_s(myid)
      mxe  =  mx_e(myid)
      izs  =  iz_s(myid)
      ize  =  iz_e(myid)
      i2xs =  i2x_s(myid)
      i2xe =  i2x_e(myid)
c
c ----------- get starting and  ending processor id's on each
c             vertical slab
c
      iss = is_s(myid)
      ise = is_e(myid)
c
c ------------ debug ranges 
c
      if(l_debug) then
         write(nprt,1200) myid, (nn, ix_s(nn), ix_e(nn), jx_s(nn),
     +                     jx_e(nn), kx_s(nn), kx_e(nn),
     +                     i2x_s(nn), i2x_e(nn),
     +                     nn = 0,numprocs-1)
 1200    format(' myid =  ',i4,/,
     +       ' nn',5x,' ixs ',5x,' ixe ',5x,' jxs ',5x,' jxe '
     +       ,5x,' kxs ',5x,' kxe',5x,' i2xs ',5x,' i2xe',/,(9i6))
c
         write(nprt,1213) myid, (nn, iy_s(nn), iy_e(nn),
     +                   jy_s(nn), jy_e(nn),
     +                   iz_s(nn), iz_e(nn), is_s(nn), is_e(nn),
     +                   nn=0,numprocs-1)
 1213    format(' myid = ',i3,/,
     +       ' nn ',3x,' iys ',5x,' iye ',5x,
     +       ' jys ',5x,' jye ',5x,
     +       ' izs ',5x,' ize',5x,' iss ',5x,' ise ',/,
     +       (9i6))
      endif
c
      return
      end
      subroutine mpi_sum_xy(f,myid,iss,ise,nsend)
c
c --------- get horizontal x-y sum over a set of proccessors [iss:ise]
c           for vector f(i). f(i) is overwritten. skip if single processor
c
      include 'mpif.h'
      integer istatus(mpi_status_size)
      real work(nsend,iss:ise), f(nsend)
c
      if(iss .eq. ise) go to 999
c
      do j=1,nsend
         work(j,myid) = f(j)
         f(j)         = 0.0
      enddo
      do i=iss,ise
         if(i .ne. myid) then
            call mpi_sendrecv(work(1,myid),nsend,mpi_real8,i,1,
     +               work(1,i),nsend,mpi_real8,i,1,
     +           mpi_comm_world,istatus,ierr)
         endif
      enddo
      do i=iss,ise
      do j=1,nsend
         f(j) = f(j) + work(j,i)
      enddo
      enddo
c
  999 continue
c
      return
      end
      subroutine mpi_sum_z(f,i_root,myid,nsend,iall)
c
c --------- get sums on root or all processors
c           for all z for vector f(i)
c
      include 'mpif.h'
      integer istatus(mpi_status_size)
      real recv_b(nsend), f(nsend)
c
c -------- just root gets the result
c
      if(iall .ne. 1) then
         call mpi_reduce(f(1),recv_b(1),nsend,mpi_real8,mpi_sum,i_root,
     +                  mpi_comm_world,ierr)
         if(myid .eq. i_root) then
            do i=1,nsend
               f(i) = recv_b(i)
            enddo
         endif
      else
c
c -------- everyone gets the result
c
         call mpi_allreduce(f(1),recv_b(1),nsend,mpi_real8,mpi_sum,
     +                  mpi_comm_world,ierr)
         do i=1,nsend
            f(i) = recv_b(i)
         enddo
      endif
c
      return
      end
      subroutine mpi_sum_z_s(f,i_root,myid,nsend,nscl,iall)
c
c --------- get sums on root or all processors
c           for all z for vector f(i,nscl)
c
      include 'mpif.h'
      integer istatus(mpi_status_size)
      real recv_b(nsend,nscl), f(nsend,nscl)
c
      if(iall .ne. 1) then
         call mpi_reduce(f(1,1),recv_b(1,1),nsend*nscl,mpi_real8,
     +        mpi_sum,i_root,mpi_comm_world,ierr)
         if(myid .eq. i_root) then
            do iscl=1,nscl
            do i=1,nsend
               f(i,iscl) = recv_b(i,iscl)
            enddo
            enddo
         endif
      else
         call mpi_allreduce(f(1,1),recv_b(1,1),nsend*nscl,mpi_real8,
     +        mpi_sum, mpi_comm_world,ierr)
         do iscl=1,nscl
         do i=1,nsend
            f(i,iscl) = recv_b(i,iscl)
         enddo
         enddo
      endif
c
      return
      end
      subroutine mpi_gath_root(fs,fr,iz_s,iz_e,izs,ize,nz,myid,np,ns)
c
c ---------- gather results on root processors
c
      include 'mpif.h'
      integer istatus(mpi_status_size)
      integer iz_s(0:np-1), iz_e(0:np-1)
      real fs(izs:ize), fr(1:nz)
c
      if(np .eq. 1) go to 999
c
      irow_r = mod(myid,ns)
      if(myid .gt. ns) then
        call mpi_send(fs(izs),ize+1-izs,mpi_real8,irow_r,1,
     +       mpi_comm_world,ierr)
      else
        do l=irow_r+ns,np-1,ns
           ind = iz_s(l) + 1
           num = iz_e(l) + 1 - iz_s(l)
           call mpi_recv(fr(ind),num,mpi_real8,l,1,
     +       mpi_comm_world,istatus,ierr)
        enddo
      endif
c
  999 continue
c
      return
      end
      subroutine mpi_send_root(fs,num,myid,np,ns)
c
c ---------- send root results to other processors above it
c
      include 'mpif.h'
      integer istatus(mpi_status_size)
      real fs(num)
c
      if(np .eq. 1) go to 999
c
      irow_r = mod(myid,ns)
      if(myid .ge. ns) then
        call mpi_recv(fs(1),num,mpi_real8,irow_r,1,
     +       mpi_comm_world,istatus,ierr)
      else
        do l=irow_r+ns,np-1,ns
           call mpi_send(fs(1),num,mpi_real8,l,1,
     +          mpi_comm_world,ierr)
        enddo
      endif
c
  999 continue
c
      return
      end
      subroutine xtoy_trans(f,g,nx,ny,ixs,ixe,ix_s,ix_e,
     +           iys,iye,iy_s,iy_e,iz1,iz2,
     +           myid,ncpu_s,np)
c 
c ------- transpose array  f(nx,iys:iye,iz1:iz2) ---> g(ny,ixs:ixe,iz1:iz2)
c
      include 'mpif.h'
      integer istatus(mpi_status_size)
c
      real f(nx,iys:iye,iz1:iz2), 
     +     g(ny,ixs:ixe,iz1:iz2)
      real ft(nx*(iye+1-iys)*(iz2 - iz1 + 1)),
     +     gt(ny*(ixe+1-ixs)*(iz2 - iz1 + 1))
      integer ix_s(0:np-1), ix_e(0:np-1),
     +        iy_s(0:np-1), iy_e(0:np-1)
c
      jk = (iye - iys + 1)*(iz2 - iz1 + 1)
      ik = (ixe - ixs + 1)*(iz2 - iz1 + 1)
c
c ----------- get cpus on slab for myid
c
      islab = myid/ncpu_s
      iss   = islab*ncpu_s
      ise   = iss + ncpu_s - 1
c
      do i=iss,ise
         nsend = (ix_e(i) - ix_s(i) + 1)*jk
         nrecv = (iy_e(i) - iy_s(i) + 1)*ik
         if(i .eq. myid) then
            call send_xtoy(f,gt(1),nx,ix_s(i),ix_e(i),
     +                  iy_s(myid),iy_e(myid),iz1,iz2)
         else
            call send_xtoy(f,ft(1),nx,ix_s(i),ix_e(i),
     +                  iy_s(myid),iy_e(myid),iz1,iz2)
            call mpi_sendrecv(
     +          ft(1),nsend,mpi_real8,i,1,
     +          gt(1),nrecv,mpi_real8,i,1,
     +          mpi_comm_world,istatus,ierr)
         endif
         call recv_xtoy(g,gt(1),ny,ix_s(myid),ix_e(myid),
     +                  iy_s(i),iy_e(i),iz1,iz2)
      enddo
c
      return
      end
      subroutine send_xtoy(f,ft,nx,ixs,ixe,iys,iye,izs,ize)
c
c ------------- grab correct chunk of array to be sent
c
      real f(nx,iys:iye,izs:ize), ft(ixs:ixe,iys:iye,izs:ize)
c
      do k=izs,ize
      do j=iys,iye
      do i=ixs,ixe
         ft(i,j,k) = f(i,j,k)
      enddo
      enddo
      enddo
c
      return
      end
      subroutine recv_xtoy(g,gt,ny,ixs,ixe,iys,iye,izs,ize)
      real g(ny,ixs:ixe,izs:ize), gt(ixs:ixe,iys:iye,izs:ize)
c
      do k=izs,ize
      do j=iys,iye
      do i=ixs,ixe
         g(j,i,k) = gt(i,j,k)
      enddo
      enddo
      enddo
c
      return
      end
      subroutine ytox_trans(g,f,nx,ny,ixs,ixe,ix_s,ix_e,
     +           iys,iye,iy_s,iy_e,iz1,iz2,
     +           myid,ncpu_s,np)
c 
c ------- transpose array g(ny,ixs:ixe,iz1:iz2) ---> f(nx,iys:iye,iz1:iz2)
c
      include 'mpif.h'
      integer istatus(mpi_status_size)
c
      real f(nx,iys:iye,iz1:iz2), 
     +     g(ny,ixs:ixe,iz1:iz2)
      real ft(nx*(iye+1-iys)*(iz2 - iz1 + 1)),
     +     gt(ny*(ixe+1-ixs)*(iz2 - iz1 + 1))
c
      integer ix_s(0:np-1), ix_e(0:np-1),
     +        iy_s(0:np-1), iy_e(0:np-1)
c
      jk = (iye - iys + 1)*(iz2 - iz1 + 1)
      ik = (ixe - ixs + 1)*(iz2 - iz1 + 1)
c
c ----------- get cpus on slab for myid
c
      islab = myid/ncpu_s
      iss   = islab*ncpu_s
      ise   = iss + ncpu_s - 1
      do i=iss,ise
         nsend = (iy_e(i) - iy_s(i) + 1)*ik
         nrecv = (ix_e(i) - ix_s(i) + 1)*jk
         if(i .eq. myid) then
            call send_ytox(g,ft(1),ny,ix_s(myid),ix_e(myid),
     +                  iy_s(i),iy_e(i),iz1,iz2)
         else
            call send_ytox(g,gt(1),ny,ix_s(myid),ix_e(myid),
     +                  iy_s(i),iy_e(i),iz1,iz2)
            call mpi_sendrecv(
     +          gt(1),nsend,mpi_real8,i,1,
     +          ft(1),nrecv,mpi_real8,i,1,
     +          mpi_comm_world,istatus,ierr)
         endif
         call recv_ytox(f,ft(1),nx,ix_s(i),ix_e(i),
     +                  iy_s(myid),iy_e(myid),iz1,iz2)
      enddo
c
      return
      end
      subroutine send_ytox(g,gt,ny,ixs,ixe,iys,iye,izs,ize)
c
c ------------- grab correct chunk of array to be sent
c
      real g(ny,ixs:ixe,izs:ize), gt(iys:iye,ixs:ixe,izs:ize)
c
      do k=izs,ize
      do i=ixs,ixe
      do j=iys,iye
         gt(j,i,k) = g(j,i,k)
      enddo
      enddo
      enddo
c
      return
      end
      subroutine recv_ytox(f,ft,nx,ixs,ixe,iys,iye,izs,ize)
      real f(nx,iys:iye,izs:ize), ft(iys:iye,ixs:ixe,izs:ize)
c
      do k=izs,ize
      do i=ixs,ixe
      do j=iys,iye
         f(i,j,k) = ft(j,i,k)
      enddo
      enddo
      enddo
c
      return
      end
      subroutine xtoz_trans(f,g,nx,nz,ixs,ixe,ix_s,ix_e,
     +           iys,iye,izs,ize,iz_s,iz_e,
     +           myid,ncpu_s,numprocs)
c
c ------- transpose array  f(nx,iys:iye,izs-1:ize+1) 
c                     ---> g(0:nz+1,iys:iye,ixs:ixe)
c
      include 'mpif.h'
      integer istatus(mpi_status_size)
c
      real f(nx,iys:iye,izs-1:ize+1), g(0:nz+1,iys:iye,ixs:ixe)
      real ft(nx*(iye+1-iys)*(ize-izs+1)),
     +     gt(nz*(ixe+1-ixs)*(iye-iys+1))
      integer ix_s(0:numprocs-1), ix_e(0:numprocs-1),
     +        iz_s(0:numprocs-1), iz_e(0:numprocs-1)
c
      jk = (ize - izs + 1)*(iye - iys + 1)
      ij = (ixe - ixs + 1)*(iye - iys + 1)
c
c ----------- get starting location
c
      iss = myid - (myid/ncpu_s)*ncpu_s
c
      do i=iss,numprocs-1,ncpu_s
         nsend = (ix_e(i) - ix_s(i) + 1)*jk
         nrecv = (iz_e(i) - iz_s(i) + 1)*ij
         if(i .eq. myid) then
            call send_xtoz(f,gt(1),nx,ix_s(i),ix_e(i),
     +                  iys,iye,iz_s(myid),iz_e(myid))
         else
            call send_xtoz(f,ft(1),nx,ix_s(i),ix_e(i),
     +                  iys,iye,iz_s(myid),iz_e(myid))
            call mpi_sendrecv(
     +          ft(1),nsend,mpi_real8,i,1,
     +          gt(1),nrecv,mpi_real8,i,1,
     +          mpi_comm_world,istatus,ierr)
         endif
         call recv_xtoz(g,gt(1),nz,ix_s(myid),ix_e(myid),
     +                  iys,iye,iz_s(i),iz_e(i))
      enddo
c
      return
      end
      subroutine send_xtoz(f,ft,nx,ixs,ixe,iys,iye,izs,ize)
c
c ------- grab correct chunk of array to be sent and skip ghost points
c
      real f(nx,iys:iye,izs-1:ize+1), ft(ixs:ixe,iys:iye,izs:ize)
c
      do k=izs,ize
      do j=iys,iye
      do i=ixs,ixe
         ft(i,j,k) = f(i,j,k)
      enddo
      enddo
      enddo
c
      return
      end
      subroutine recv_xtoz(g,gt,nz,ixs,ixe,iys,iye,izs,ize)
      real g(0:nz+1,iys:iye,ixs:ixe), gt(ixs:ixe,iys:iye,izs:ize)
c
      do k=izs,ize
      do j=iys,iye
      do i=ixs,ixe
         g(k,j,i) = gt(i,j,k)
      enddo
      enddo
      enddo
c
      return
      end
      subroutine ztox_trans(g,f,nx,nz,ixs,ixe,ix_s,ix_e,
     +           iys,iye,izs,ize,iz_s,iz_e,
     +           myid,ncpu_s,numprocs)
c
c ------- transpose array g(0:nz+1,iys:iye,ixs:ixe) 
c                    ---> f(nx,iys:iye,izs-1:ize+1)
c
      include 'mpif.h'
      integer istatus(mpi_status_size)
c
      real f(nx,iys:iye,izs-1:ize+1), g(0:nz+1,iys:iye,ixs:ixe)
      real ft(nx*(iye+1-iys)*(ize-izs+3)),
     +     gt((nz+3)*(iye+1-iys)*(ixe-ixs+1))
c
      integer ix_s(0:numprocs-1), ix_e(0:numprocs-1),
     +        iz_s(0:numprocs-1), iz_e(0:numprocs-1)
c
      jk = (ize - izs + 3)*(iye - iys + 1)
      ij = (ixe - ixs + 1)*(iye - iys + 1)
c
c ------------- get starting location
c
      iss = myid - (myid/ncpu_s)*ncpu_s
c
      do i=iss,numprocs-1,ncpu_s
         nsend = (iz_e(i) - iz_s(i) + 3)*ij
         nrecv = (ix_e(i) - ix_s(i) + 1)*jk
         if(i .eq. myid) then
            call send_ztox(g,ft(1),nz,ix_s(myid),ix_e(myid),
     +                  iys,iye,iz_s(i),iz_e(i))
         else
            call send_ztox(g,gt(1),nz,ix_s(myid),ix_e(myid),
     +                  iys,iye,iz_s(i),iz_e(i))
            call mpi_sendrecv(
     +          gt(1),nsend,mpi_real8,i,1,
     +          ft(1),nrecv,mpi_real8,i,1,
     +          mpi_comm_world,istatus,ierr)
         endif
         call recv_ztox(f,ft(1),nx,ix_s(i),ix_e(i),
     +                  iys,iye,iz_s(myid),iz_e(myid))
      enddo
c
      return
      end
      subroutine send_ztox(g,gt,nz,ixs,ixe,iys,iye,izs,ize)
c
c ------------- grab correct chunk of array to be sent,
c               account for ghost points
c
      real g(0:nz+1,iys:iye,ixs:ixe), gt(izs-1:ize+1,iys:iye,ixs:ixe)
c
      do j=iys,iye
      do i=ixs,ixe
      do k=izs-1,ize+1
         gt(k,j,i) = g(k,j,i)
      enddo
      enddo
      enddo
c
      return
      end
      subroutine recv_ztox(f,ft,nx,ixs,ixe,iys,iye,izs,ize)
      real f(nx,iys:iye,izs-1:ize+1), ft(izs-1:ize+1,iys:iye,ixs:ixe)
c
      do i=ixs,ixe
      do j=iys,iye
      do k=izs-1,ize+1
         f(i,j,k) = ft(k,j,i)
      enddo
      enddo
      enddo
c
      return
      end
      subroutine exchange
c
c ------------- exchange ghost points with mpi,
c               nb and nt are the destination and
c               source nodes. Allows for 1z per cpu
c
      use pars
      use fields
c     use fftwk
      include 'mpif.h'
c
      real fs(nnx,iys:iye,(5+nscl)),fr(nnx,iys:iye,(5+nscl))
      integer istatus(mpi_status_size)
c
      nb = myid - ncpu_s
      nt = myid + ncpu_s
c
c ------------ account for endpoints
c
      if(iss .eq. 0) then
         nb = mpi_proc_null
      endif
      if(ise .eq. numprocs-1) then
         nt = mpi_proc_null
      endif
      nsend = nnx*(iye + 1 - iys)*(5+nscl)
      nrecv = nsend
c
c --------- send top of myid, receive bottom from myid - ncpu_s
c
      do iy=iys,iye
      do ix=1,nnx
         fs(ix,iy,1) = u(ix,iy,ize)
         fs(ix,iy,2) = v(ix,iy,ize)
         fs(ix,iy,3) = w(ix,iy,ize)
         fs(ix,iy,4) = e(ix,iy,ize)
         fs(ix,iy,5) = wf(ix,iy,ize)
      enddo
      enddo
      do iscl=1,nscl
         jloc = 5 + iscl
         do iy=iys,iye
         do ix=1,nnx
            fs(ix,iy,jloc) = t(ix,iy,iscl,ize)
         enddo
         enddo
      enddo
c
      call mpi_sendrecv(
     +     fs(1,iys,1),nsend,mpi_real8,nt,0,
     +     fr(1,iys,1),nrecv,mpi_real8,nb,0,
     +     mpi_comm_world,istatus,ierr)
c
      if(iss .ne. 0) then
         izm1 = izs-1
         do iy=iys,iye
         do ix=1,nnx
            u(ix,iy,izm1) = fr(ix,iy,1)
            v(ix,iy,izm1) = fr(ix,iy,2)
            w(ix,iy,izm1) = fr(ix,iy,3)
            e(ix,iy,izm1) = fr(ix,iy,4)
            wf(ix,iy,izm1) = fr(ix,iy,5)
         enddo
         enddo
         do iscl=1,nscl
            jloc = 5 + iscl
            do iy=iys,iye
            do ix=1,nnx
               t(ix,iy,iscl,izm1) = fr(ix,iy,jloc)
            enddo
            enddo
         enddo
      endif
c
c -------- send bottom of myid, receive bottom from myid + ncpu_s
c
      do iy=iys,iye
      do ix=1,nnx
         fs(ix,iy,1) = u(ix,iy,izs)
         fs(ix,iy,2) = v(ix,iy,izs)
         fs(ix,iy,3) = w(ix,iy,izs)
         fs(ix,iy,4) = e(ix,iy,izs)
      enddo
      enddo
      do iscl=1,nscl
         jloc = 4 + iscl
         do iy=iys,iye
         do ix=1,nnx
            fs(ix,iy,jloc) = t(ix,iy,iscl,izs)
         enddo
         enddo
      enddo
      nsend = nnx*(iye + 1 - iys)*(4+nscl)
      nrecv = nsend
c
      call mpi_sendrecv(
     +     fs(1,iys,1),nsend,mpi_real8,nb,1,
     +     fr(1,iys,1),nrecv,mpi_real8,nt,1,
     +     mpi_comm_world,istatus,ierr)
c
      if(ise .ne. numprocs-1) then
         izp1 = ize+1
         do iy=iys,iye
         do ix=1,nnx
            u(ix,iy,izp1) = fr(ix,iy,1)
            v(ix,iy,izp1) = fr(ix,iy,2)
            w(ix,iy,izp1) = fr(ix,iy,3)
            e(ix,iy,izp1) = fr(ix,iy,4)
         enddo
         enddo
         do iscl=1,nscl
            jloc = 4 + iscl
            do iy=iys,iye
            do ix=1,nnx
               t(ix,iy,iscl,izp1) = fr(ix,iy,jloc)
            enddo
            enddo
         enddo
      endif
c
c --------------- send extra scalar points 
c
      nsend = nnx*(iye + 1 - iys)*nscl
      nrecv = nsend
c
c -------------- send top of myid, receive bottom from myid - ncpu_s
c
      izm1 = ize-1
      do iscl=1,nscl
         do iy=iys,iye
         do ix=1,nnx
            fs(ix,iy,iscl) = t(ix,iy,iscl,izm1)
         enddo
         enddo
      enddo
c
      call mpi_sendrecv(
     +     fs(1,iys,1),nsend,mpi_real8,nt,0,
     +     fr(1,iys,1),nrecv,mpi_real8,nb,0,
     +     mpi_comm_world,istatus,ierr)
c
      if(iss .ne. 0) then
         izm2 = izs-2
         do iscl=1,nscl
            do iy=iys,iye
            do ix=1,nnx
               t(ix,iy,iscl,izm2) = fr(ix,iy,iscl)
            enddo
            enddo
         enddo
      endif
c
c -------------- send bottom of myid, receive bottom from myid + ncpu_s
c
      izp1 = izs+1
      do iscl=1,nscl
         do iy=iys,iye
         do ix=1,nnx
            fs(ix,iy,iscl) = t(ix,iy,iscl,izp1)
         enddo
         enddo
      enddo
c
      call mpi_sendrecv(
     +     fs(1,iys,1),nsend,mpi_real8,nb,1,
     +     fr(1,iys,1),nrecv,mpi_real8,nt,1,
     +     mpi_comm_world,istatus,ierr)
c
      if(ise .ne. numprocs-1) then
         izp2 = ize+2
         do iscl=1,nscl
            do iy=iys,iye
            do ix=1,nnx
               t(ix,iy,iscl,izp2) = fr(ix,iy,iscl)
            enddo
            enddo
         enddo
      endif
c
      return
      end
      subroutine bcast_pbc
c
c ---- send upper boundary conditions to other processors 
c      for fft solution of pressure
c
      use pars
      use fields
      include 'mpif.h'
      integer istatus(mpi_status_size)
c
      if(numprocs .eq. 1) go to 999
c
      irow_r = mod(myid,ncpu_s)
      irow_t = is_s(numprocs-1) + irow_r
      num = nnx*(iye+1-iys)
c
c ----- check which row myid is in
c
      if(iss .ne. is_s(numprocs-1)) then
c
c ------ not in the top row, receive from top
c
        call mpi_recv(pbc(1,iys,1),num,mpi_real8,irow_t,1,
     +       mpi_comm_world,istatus,ierr)
      else
c
c ------ myid is in the top row, send to everyone below
c
        do l=irow_r,irow_t-ncpu_s,ncpu_s
           call mpi_send(pbc(1,iys,1),num,mpi_real8,l,1,
     +          mpi_comm_world,ierr)
        enddo
      endif
c
c --------- same thing for another variable
c
      if(iss .ne. is_s(numprocs-1)) then
c
c ------ not in the top row, receive from top
c
        call mpi_recv(pbc2(1,iys,1),num,mpi_real8,irow_t,1,
     +       mpi_comm_world,istatus,ierr)
      else
c
c ------ in the top row, send to everyone below
c
        do l=irow_r,irow_t-ncpu_s,ncpu_s
           call mpi_send(pbc2(1,iys,1),num,mpi_real8,l,1,
     +          mpi_comm_world,ierr)
        enddo
      endif
c
  999 continue
c
      return
      end
      subroutine bcast_surf
c
c ---- send bottom geometry to all other processors 
c      for computation of pressure drag at all z
c
      use pars
      use fields
      include 'mpif.h'
      integer istatus(mpi_status_size)
c
      if(iss == 0) then
        k = 1
        do j=iys,iye
        do i=1,nnx
           gms(i,j,1) = gm(i,j,k,1)
           gms(i,j,2) = gm(i,j,k,2)
           gms(i,j,3) = gm(i,j,k,3)
        enddo
        enddo
      endif
c
      if(numprocs == 1) go to 999
c
      irow_r = mod(myid,ncpu_s)
      irow_t = is_s(numprocs-1) + irow_r
      num    = nnx*(iye+1-iys)
c
c ----- check which row myid is in
c
      if(iss /= is_s(0)) then
c
c ------ not in the bottom row, receive from bottom
c
        call mpi_recv(gms(1,iys,1),num,mpi_real8,irow_r,1,
     +       mpi_comm_world,istatus,ierr)
      else
c
c ------ myid is in the bottom row, send to everyone else
c
        do l=irow_r+ncpu_s,irow_t,ncpu_s
           call mpi_send(gms(1,iys,1),num,mpi_real8,l,1,
     +          mpi_comm_world,ierr)
        enddo
      endif
c
c --------- same thing for another variable
c
      if(iss /= is_s(0)) then
c
c ------ not in the bottom row, receive from bottom
c
        call mpi_recv(gms(1,iys,2),num,mpi_real8,irow_r,1,
     +       mpi_comm_world,istatus,ierr)
      else
c
c ------ myid is in the bottom row, send to everyone else
c
        do l=irow_r+ncpu_s,irow_t,ncpu_s
           call mpi_send(gms(1,iys,2),num,mpi_real8,l,1,
     +          mpi_comm_world,ierr)
        enddo
      endif
c
c --------- same thing for another variable
c
      if(iss /= is_s(0)) then
c
c ------ not in the bottom row, receive from bottom
c
        call mpi_recv(gms(1,iys,3),num,mpi_real8,irow_r,1,
     +       mpi_comm_world,istatus,ierr)
      else
c
c ------ myid is in the bottom row, send to everyone else
c
        do l=irow_r+ncpu_s,irow_t,ncpu_s
           call mpi_send(gms(1,iys,3),num,mpi_real8,l,1,
     +          mpi_comm_world,ierr)
        enddo
      endif
  999 continue
c
      return
      end

!!!!! ----- D. Richter, 3/11/14 ---
!!!!! ----- Adding particles to Peter's wavy code

      subroutine particle_init
      use particles
      use pars
      use con_data
      use tank_pars
      implicit none
      include 'mpif.h' 
      integer :: values(8)
      integer :: idx,ix
      real :: xv,yv,zv,ran2
      real :: yp1,ypn,xpart(nnx),y2part(nnx),ddx

      !Create the seed for the random number generator:
      call date_and_time(VALUES=values)
      iseed = -(myid+values(8)+values(7)+values(6))


      !Initialize ngidx, the particle global index
      ngidx = 1
      
      !For the channel case, set the total number of particles:
      numpart = tnumpart/numprocs
      if (myid==0) then
         numpart = numpart + mod(tnumpart,numprocs)
      end if

      !Initialize the linked list of particles:
      nullify(part,first_particle)

      yp1 = 2.0e+30
      ypn = yp1
      !Set up xpart for interpolation of h:
      ddx = xl/float(nnx)
      do ix=1,nnx
         xpart(ix) = float(ix-1)*ddx
      end do
      call spline(xpart,z_tank_i,nnx,yp1,ypn,y2part)
      
      !Now initialize all particles with a random location on that processor
      do idx=1,numpart
         xv = ran2(iseed)*(xmax-xmin) + xmin
         yv = ran2(iseed)*(ymax-ymin) + ymin
         zv = ran2(iseed)*(zl-0.25) + 0.25
         !zv = 0.3
         call create_particle((/xv,yv,zv/),vp_init,Tp_init,idx,
     +       z_tank_i(1:nnx),xpart(1:nnx),y2part(1:nnx),zl)
      end do

      partTsrc = 0.0
      partTsrc_t = 0.0

      end subroutine particle_init
      subroutine particle_setup

      use particles
      use pars
      use tank_pars
      use con_data
      implicit none 
      include 'mpif.h'

      integer :: blcts(3),types(3)
      integer :: ierr
      integer(kind=MPI_ADDRESS_KIND) :: extent,lb
      integer(kind=MPI_ADDRESS_KIND) :: extent2,lb2,displs(3)
      real :: ddx
      integer :: ix

      !First set up the neighbors for the interpolation stage:
      call assign_nbrs

      !Also assign the x,y,z max and mins to track particles leaving
      call set_bounds

      taup_i = 18.0*muf/rhop/(2.0*radius)**2

      if (myid==0) write(*,*) 'Particle radius = ',radius
      if (myid==0) write(*,*) 'Particle density = ',rhop
      if (myid==0) write(*,*) 'Particle taup = ',1.0/taup_i
      if (myid==0) write(*,*) 'Particle gravity = ',part_grav
      if (myid==0) write(*,*) 'muf = ',muf
      if (myid==0) write(*,*) 'CpaCpp = ',CpaCpp
      if (myid==0) write(*,*) 'Pra = ',Pra

      num_reintro = 0
      tot_reintro = 0
      his_reintro = 0

      !Initialize the linked list of particles:
      nullify(part,first_particle)

      !Set up MPI datatypes for sending particle information
      !MUST UPDATE IF THINGS ARE ADDED/REMOVED FROM PARTICLE STRUCTURE
      
      blcts(1:3) = (/2,3*7,2/)
      displs(1) = 0
      types(1) = mpi_integer
      call mpi_type_get_extent(mpi_integer,lb,extent,ierr)
      
      !Displace 2*size of mpi_integer (2 integer: pidx,procidx)
      displs(2) = extent*2
      types(2) = mpi_real8
      call mpi_type_get_extent(mpi_real8,lb,extent,ierr)
      !Displace (7*3)*size of mpi_real8 (6 3-vectors plus Tp,Tprhs,Tf)
      displs(3) = displs(2) + extent*(7*3)
      types(3) = mpi_integer8

      !Now define the type:
      call mpi_type_create_struct(3,blcts,
     +            displs,types,particletype,ierr)


       call mpi_type_get_true_extent(particletype,lb2,extent2,ierr)
       call mpi_type_get_extent(particletype,lb2,extent,ierr)
       if (extent .NE. sizeof(part) ) then
          if (myid==0) then
          write(*,*) 'WARNING: extent of particletype not equal
     +                  to sizeof(part):'
          write(*,*) 'sizeof(part) = ', sizeof(part)
!          write(*,*) 'sizeof(part%pidx) = ', sizeof(part%pidx)
          write(*,*) 'mpi_type_get_true_extent(particletype) = ',extent2
          write(*,*) 'mpi_type_get_extent(particletype) = ',extent
          end if
       end if
      
      !Need to compute any padding which may exist in particle struct:
      pad_diff = extent-extent2 
      if (myid==0) then
      write(*,*) 'mpi_get_extent = ',extent
      write(*,*) 'mpi_get_true_extent = ',extent2
      write(*,*) 'sizeof(part) = ',sizeof(part)
      write(*,*) 'DIFF = ',pad_diff
      end if
      if (pad_diff .LT. 0) then
        write(*,*) 'WARNING: mpi_get_extent - mpi_get_true_extent LT 0!'
        call mpi_finalize(ierr)
        stop
      end if


      call mpi_type_commit(particletype,ierr)

      end subroutine particle_setup
      subroutine assign_nbrs
        use pars
        use particles
        include 'mpif.h'
      !Figure out which processors lie to all sides: 
      !For the case where particles lie in columns not 
      !aligning with the velocity, there will be no MPI_PROC_NULL since
      !x and y are BOTH periodic
     
      !On right boundary:
      if ( mod(myid+1,ncpu_s) == 0 ) then
         !On the top:
         if ( myid .GE. ncpu_s*(ncpu_z-1) ) then
            rproc = myid-ncpu_s+1
            trproc = 0 
            tproc = ncpu_s-1 
            tlproc = ncpu_s-2 
            lproc = myid-1
            blproc = myid-ncpu_s-1
            bproc = myid-ncpu_s
            brproc = myid-ncpu_s - ncpu_s+1
         !On the bottom:
         elseif ( myid .LT. ncpu_s ) then
            rproc = myid-ncpu_s+1
            trproc = myid+1
            tproc = myid+ncpu_s
            tlproc = myid+ncpu_s-1
            lproc = myid-1
            blproc = myid+ncpu_s*(ncpu_z-1)-1 
            bproc = myid+ncpu_s*(ncpu_z-1) 
            brproc = ncpu_s*(ncpu_z-1) 
         !In the middle of right side:
         else 
            rproc = myid-ncpu_s+1
            trproc = myid+1
            tproc = myid+ncpu_s
            tlproc = myid+ncpu_s-1
            lproc = myid-1
            blproc = myid-ncpu_s-1
            bproc = myid-ncpu_s
            brproc = myid-ncpu_s - ncpu_s+1
         end if 

      !On the left boundary:
      elseif ( mod(myid,ncpu_s) == 0) then
         !On the top:
         if ( myid .GE. ncpu_s*(ncpu_z-1) ) then
            rproc = myid+1
            trproc = 1 
            tproc = 0 
            tlproc = ncpu_s-1
            lproc = myid+ncpu_s-1
            blproc = myid-1
            bproc = myid-ncpu_s
            brproc = myid-ncpu_s+1
         !On the bottom:
         elseif ( myid .LT. ncpu_s ) then
            rproc = myid+1
            trproc = myid+ncpu_s+1
            tproc = myid+ncpu_s
            tlproc = myid+ncpu_s+ncpu_s-1
            lproc = myid+ncpu_s-1
            blproc = numprocs-1 
            bproc = ncpu_s*(ncpu_z-1) 
            brproc = ncpu_s*(ncpu_z-1)+1 
         !In the middle of left side:
         else
            rproc = myid+1
            trproc = myid+ncpu_s+1
            tproc = myid+ncpu_s
            tlproc = myid+ncpu_s + ncpu_s-1
            lproc = myid+ncpu_s-1
            blproc = myid-1
            bproc = myid-ncpu_s
            brproc = myid-ncpu_s+1
         end if
      !On the top boundary
      elseif ( myid .GE. ncpu_s*(ncpu_z-1) ) then
         !Only check if in the middle:
         if ( .NOT. ( mod(myid,ncpu_s) == 0) ) then
            if ( .NOT. (mod(myid+1,ncpu_s) == 0) ) then
               rproc = myid+1
               trproc = myid-(ncpu_s*(ncpu_z-1))+1 
               tproc = myid-(ncpu_s*(ncpu_z-1)) 
               tlproc = myid-(ncpu_s*(ncpu_z-1))-1 
               lproc = myid-1
               blproc = myid-ncpu_s-1
               bproc = myid-ncpu_s
               brproc = myid-ncpu_s+1
            end if
         end if 
      !On the bottom boundary
      elseif ( myid .LT. ncpu_s) then
         if ( .NOT. ( mod(myid,ncpu_s) == 0) ) then
            if ( .NOT. (mod(myid+1,ncpu_s) == 0) ) then
               rproc = myid+1
               trproc = myid+ncpu_s+1
               tproc = myid+ncpu_s
               tlproc = myid+ncpu_s-1
               lproc = myid-1
               blproc = myid+ncpu_s*(ncpu_z-1)-1
               bproc = myid+ncpu_s*(ncpu_z-1) 
               brproc = myid+ncpu_s*(ncpu_z-1)+1 
            end if
         end if
      !Everywhere else:
      else 
         rproc = myid+1
         trproc = myid+ncpu_s+1
         tproc = myid+ncpu_s
         tlproc = myid+ncpu_s-1
         lproc = myid-1
         blproc = myid-ncpu_s-1
         bproc = myid-ncpu_s
         brproc = myid-ncpu_s+1
      end if

      return
      end subroutine assign_nbrs
      subroutine set_bounds  
      use pars
      use particles
      use con_data
      use con_stats
      implicit none
      include 'mpif.h'
      
      !Assign the bounds of each processor
      !(this probably already exists in code, but this is for my sake)
      ymin = dy*(iys-1)
      ymax = dy*(iye)
      zmin = z(izs-1)
      zmax = z(ize)  
      xmin = dx*(mxs-1)
      xmax = dx*(mxe)

      end subroutine set_bounds
      subroutine create_particle(xp,vp,Tp,idx,ztank,xles,y2)
      use particles
      use pars
      implicit none

      real :: xp(3),vp(3),Tp,hpart
      real :: ztank(nnx),xles(nnx),y2(nnx)
      integer :: idx,ix

      if (.NOT. associated(first_particle)) then
         allocate(first_particle)
         part => first_particle
         nullify(part%next,part%prev)
      else
         !Add to beginning of list since it's more convenient
         part => first_particle
         allocate(part%prev)
         first_particle => part%prev
         part%prev%next => part
         part => first_particle
         nullify(part%prev)
      end if

      part%xip(1:3) = xp(1:3)
      call splint(xles,ztank,y2,nnx,part%xip(1),hpart)
      part%xp(1:2) = part%xip(1:2)
      part%xp(3) = part%xip(3) + 
     +             hpart*(1.0-part%xip(3)/zl)**a_decay

      part%vp(1:3) = vp(1:3)
      part%Tp = Tp
      part%Tf = Tp
      part%uf(1:3) = 0.0
      part%xrhs(1:3) = 0.0
      part%vrhs(1:3) = 0.0 
      part%Tprhs = 0.0
      part%pidx = idx 
      part%procidx = myid
      
      end subroutine create_particle
      subroutine save_particles
      use particles
      use pars
      implicit none
      include 'mpif.h'

      integer :: istatus(mpi_status_size), ierr, fh
      integer(kind=mpi_offset_kind) :: zoffset,offset
      integer :: pnum_vec(numprocs)
      integer :: iproc,i
      type(particle) :: writebuf(numpart),tmp

      !Do this with mpi_write_at_all
      !Need to figure out the displacements - need numpart from each proc
      call mpi_allgather(numpart,1,mpi_integer,pnum_vec,1,mpi_integer,
     +                   mpi_comm_world,ierr)

      !Package all the particles into writebuf:
      i = 1
      part => first_particle
      do while (associated(part))
      writebuf(i) = part
      !write(*,'a5,3e15.6') 'xp:',part%xp(1:3)
      part => part%next
      i = i + 1
      end do

      !Now only write to the file if you actually have particles
      !EXCEPTION: proc 0, which needs to write tnumpart regardless
      call mpi_file_open(mpi_comm_world, path_sav_part,
     +                   mpi_mode_create+mpi_mode_rdwr,
     +                   mpi_info_null,fh,ierr)

      zoffset = 0
      !Write tnumpart first:
      if (myid==0) then
      call mpi_file_write_at(fh,zoffset,tnumpart,1,mpi_integer,
     +                       istatus,ierr)
      write(*,*) 'wrote tnumpart = ',tnumpart
      end if

      zoffset = zoffset + 4
     
      !Now compute the offset (in bytes!):
      offset = zoffset 
      do iproc = 0,myid-1
         offset = offset + pnum_vec(iproc+1)*(sizeof(tmp)-pad_diff) 
      end do

      !Now everyone else write, ONLY if numpart > 0
      if (numpart .GT. 0) then
      call mpi_file_write_at(fh,offset,writebuf,numpart,
     +                       particletype,istatus,ierr)
!      write(*,*) 'wrote writebuf(1)%pidx = ',writebuf(1)%pidx
!      write(*,'a30,3e15.6') 'wrote writebuf(1)%vp =',writebuf(1)%vp(1:3)
!      write(*,'a30,3e15.6') 'wrote writebuf(1)%xp =',writebuf(1)%xp(1:3)
!      write(*,*) 'wrote writebuf(2)%pidx = ',writebuf(2)%pidx
!      write(*,'a30,3e15.6') 'wrote writebuf(2)%vp =',writebuf(2)%vp(1:3)
!      write(*,'a30,3e15.6') 'wrote writebuf(2)%xp =',writebuf(2)%xp(1:3)
      end if

      call mpi_file_close(fh,ierr)

      write(*,*) 'proc',myid,'wrote numpart = ',numpart

      if (myid==0) write(*,7000) path_sav_part
 7000 format(' PARTICLE DATA IS WRITTEN IN FILE  ',a80)

      end subroutine save_particles
      subroutine read_part_res
      use pars
      use particles
      implicit none
      include 'mpif.h'

      integer :: istatus(mpi_status_size), ierr, fh
      integer(kind=mpi_offset_kind) :: zoffset,offset
      integer :: myp,totalp 
      integer :: iproc,i,pidxmax
      type(particle), allocatable :: readbuf(:)

      if (myid==0) write(*,7000) path_part 
 7000 format(' READING PARTICLE DATA FROM  ',a80)


      call mpi_file_open(mpi_comm_world,path_part,
     +                   mpi_mode_rdonly,
     +                   mpi_info_null,fh,ierr)

      !First read in the residual array:
!      offset = 0
!      call mpi_file_read_at_all(fh,offset,residual,rbins,
!     +                      mpi_real8,istatus,ierr)

      !Read in the total number of particles:
      offset = 0
      call mpi_file_read_at_all(fh,offset,tnumpart,1,
     +                      mpi_integer,istatus,ierr)
      if (myid==0) write(*,*) 'read tnumpart = ',tnumpart
    
      offset = 4
      allocate(readbuf(tnumpart))
      call mpi_file_read_at_all(fh,offset,readbuf,tnumpart,
     +                       particletype,istatus,ierr)

      do i = 1,tnumpart
        !Now - does it lie within this proc's bounds?
        if (readbuf(i)%xp(2) .GT. ymin .AND.
     +       readbuf(i)%xp(2) .LT. ymax .AND.
     +       readbuf(i)%xp(1) .GT. xmin .AND.
     +       readbuf(i)%xp(1) .LT. xmax) then 
            if (.NOT. associated(first_particle)) then
               allocate(first_particle)
               first_particle = readbuf(i)
               nullify(first_particle%prev,first_particle%next)
               part => first_particle
            else
               allocate(part%next)
               part%next = readbuf(i)
               part%next%prev => part
               part => part%next
               nullify(part%next)
            end if

        end if
      end do

      deallocate(readbuf)

      call mpi_file_close(fh,ierr)
      
      !Now just check how many each processor obtained:
      !At the same time, figure out max(pidx) and set ngidx 
      !to one plus this value:
      pidxmax = 0
      part => first_particle
      myp = 0
      do while (associated(part))
         myp = myp+1
         if (part%pidx .gt. pidxmax) pidxmax = part%pidx
         part => part%next
      end do

      !Set ngidx (the index for creating new particles) to 1+pidmax:
      ngidx = pidxmax + 1

      numpart = myp
     
      call mpi_allreduce(myp,totalp,1,mpi_integer,mpi_sum,
     +                   mpi_comm_world,ierr)

      write(*,*) 'proc',myid,'read in numpart:',myp
      if (myid==0) write(*,*) 'total number of particles read:',totalp

      end subroutine read_part_res
      subroutine particle_update_rk3(it,istage)
      use pars
      use particles
      use con_data
      use con_stats
      use tank_pars
      implicit none
      include 'mpif.h'

      integer :: istage,ierr,it
      real :: g(3)
      real :: denom,dtl,sigma,ttest
      integer :: ix,iy,iz
      real :: Rep,diff(3),diffnorm,corrfac,myRep_avg,xtmp(3),vtmp(3)
      real :: Nup,Tptmp
      real :: yp1,ypn,hpart,xpart(nnx),y2part(nnx),ddx

      real :: t_s,t_f,t_s1,t_f1

      g(1:3) = (/0.0, 0.0, part_grav/)

      !First fill extended velocity field for interpolation
      !t_s = mpi_wtime()
      call fill_ext 
      !t_f = mpi_wtime()
      !call mpi_barrier(mpi_comm_world,ierr)
      !if (myid==5) write(*,*) 'time fill_ext:',t_f-t_s

      !Get spline fit of surface boundary to interpolate h(xp,yp):
      yp1 = 2.0e+30
      ypn = yp1
      ddx = xl/float(nnx)
      do ix=1,nnx
         xpart(ix) = float(ix-1)*ddx
      end do
      call spline(xpart,z_tank_i,nnx,yp1,ypn,y2part)

      !update xip since waves have moved since last particle
      part => first_particle
      do while (associated(part))
            !Update part%xip
            call splint(xpart,z_tank_i,y2part,nnx,part%xp(1),hpart)
            part%xip(1:3) = part%xp(1:3)
            if (iz_space == 5) then    !Algebraic stretching to smooth out waves
                call get_zeta_algeb(a_decay,zl,hpart,part%xip(1:3))
            end if
            part => part%next
      end do
         
      !Apply bottom boundary conditions here since mesh will have moved from previous:
      call particle_bcs_nonperiodic

      partcount_t = 0.0
      vpsum_t = 0.0
      upwp_t = 0.0
      vpsqrsum_t = 0.0
      Tpsum_t = 0.0
      Tpsqrsum_t = 0.0
      wpTpsum_t = 0.0
      myRep_avg = 0.0

      !t_s = mpi_wtime()

      !Loop over the linked list of particles:
      part => first_particle
      do while (associated(part))
         
         !First, interpolate to get the fluid velocity part%uf(1:3):
         !For wavy code, must pass in the wave height at particle location
         !Get this from spline:
         call splint(xpart,z_tank_i,y2part,nnx,part%xp(1),hpart)

         call uf_interp(hpart)
!         write(*,*) 'hpart,uf,zeta = ',hpart,part%uf(1),part%uf(2),
!     +   part%uf(3),part%xip(1),part%xip(2),part%xip(3)
         !part%uf = (/1.0,0.0,0.0/)
         !Now advance the particle and position via RK3 (same as velocity)
        
         diff(1:3) = part%vp - part%uf
         diffnorm = sqrt(diff(1)**2 + diff(2)**2 + diff(3)**2)
         Rep = 2.0*radius*diffnorm/muf
         myRep_avg = myRep_avg + Rep
         corrfac = (1.0 + 0.15*Rep**(0.687))

         !Compute Nusselt number for particle:
         !Ranz-Marshall relation
         Nup = 2.0 + 0.6*Rep**(1.0/2.0)*Pra**(1.0/3.0)

         xtmp(1:3) = part%xp(1:3) + dt*zetas(istage)*part%xrhs(1:3)
         vtmp(1:3) = part%vp(1:3) + dt*zetas(istage)*part%vrhs(1:3) 
         Tptmp = part%Tp + dt*zetas(istage)*part%Tprhs
 
         if (it .LE. 1) then 
            part%xrhs(1:3) = part%vp(1:3)
            part%xp(1:3) = xtmp(1:3) + dt*gama(istage)*part%xrhs(1:3)
            part%vp(1:3) = part%uf
            part%Tp = part%Tf
            part%Tprhs = -Nup/3.0/Pra*CpaCpp*taup_i*(part%Tp-part%Tf)
         else
            part%xrhs(1:3) = part%vp(1:3)
            part%vrhs(1:3) = corrfac*taup_i*(part%uf(1:3)-part%vp(1:3))
     +                                  - g(1:3)
            part%Tprhs = -Nup/3.0/Pra*CpaCpp*taup_i*(part%Tp-part%Tf)

            part%xp(1:3) = xtmp(1:3) + dt*gama(istage)*part%xrhs(1:3)

            !Update part%xip as well:
            call splint(xpart,z_tank_i,y2part,nnx,part%xp(1),hpart)
            part%xip(1:3) = part%xp(1:3)
            if (iz_space == 5) then    !Algebraic stretching to smooth out waves
                call get_zeta_algeb(a_decay,zl,hpart,part%xip(1:3))
            end if
 
            part%vp(1:3) = vtmp(1:3) + dt*gama(istage)*part%vrhs(1:3)
            part%Tp = Tptmp + dt*gama(istage)*part%Tprhs
          end if

        part => part%next
      end do
      !t_f1 = mpi_wtime()
      !write(*,*) 'proc,loop time: ',myid,t_f1-t_s
      !call mpi_barrier(mpi_comm_world,ierr)
      !t_f = mpi_wtime()
      !if (myid==5) write(*,*) 'time loop:', t_f-t_s

      !Enforce nonperiodic bcs (either elastic or destroying particles)
      !t_s = mpi_wtime()
      !call particle_bcs_nonperiodic
      !call mpi_barrier(mpi_comm_world,ierr)
      !t_f = mpi_wtime()
      !if (myid==5) write(*,*) 'time bc_non:', t_f - t_s

      if (istage == 1) tot_reintro = 0
      call particle_reintro
      if (istage == 3) his_reintro = tot_reintro

      !Check to see if particles left processor
      !If they did, remove from one list and add to another
      !t_s = mpi_wtime()
      call particle_exchange
      !call mpi_barrier(mpi_comm_world,ierr)
      !t_f = mpi_wtime()
      !if (myid==5) write(*,*) 'time exchg:', t_f - t_s

      !Now enforce periodic bcs 
      !just updates x,y locations if over xl,yl or under 0
      !t_s = mpi_wtime()
      call particle_bcs_periodic
      !call mpi_barrier(mpi_comm_world,ierr)
      !t_f = mpi_wtime()
      !if (myid==5) write(*,*) 'time bc_per:', t_f - t_s

      !Now that particles are in their updated position, 
      !compute their contribution to the momentum coupling:
      !t_s = mpi_wtime()
      !call particle_coupling_update
      !call mpi_barrier(mpi_comm_world,ierr)
      !t_f = mpi_wtime()
      !if (myid==5) write(*,*) 'time cpl: ', t_f - t_s

      !Finally, now that coupling and statistics arrays are filled, 
      !Transpose them back to align with the velocities:
      call ztox_trans(partsrc_t(0:nnz+1,iys:iye,mxs:mxe,1),
     +                partsrc(1:nnx,iys:iye,izs-1:ize+1,1),nnx,nnz,mxs,
     +                mxe,mx_s,mx_e,iys,iye,izs,ize,iz_s,iz_e,myid,
     +                ncpu_s,numprocs)
      call ztox_trans(partsrc_t(0:nnz+1,iys:iye,mxs:mxe,2),
     +                partsrc(1:nnx,iys:iye,izs-1:ize+1,2),nnx,nnz,mxs,
     +                mxe,mx_s,mx_e,iys,iye,izs,ize,iz_s,iz_e,myid,
     +                ncpu_s,numprocs)
      call ztox_trans(partsrc_t(0:nnz+1,iys:iye,mxs:mxe,3),
     +                partsrc(1:nnx,iys:iye,izs-1:ize+1,3),nnx,nnz,mxs,
     +                mxe,mx_s,mx_e,iys,iye,izs,ize,iz_s,iz_e,myid,
     +                ncpu_s,numprocs)
      call ztox_trans(partTsrc_t(0:nnz+1,iys:iye,mxs:mxe),
     +                partTsrc(1:nnx,iys:iye,izs-1:ize+1),nnx,nnz,mxs,
     +                mxe,mx_s,mx_e,iys,iye,izs,ize,iz_s,iz_e,myid,
     +                ncpu_s,numprocs)

      !Try only calling these when the history data is being written:
      if(mtrans  .and. istage .eq. 3) then
      call ztox_trans(upwp_t(0:nnz+1,iys:iye,mxs:mxe),
     +                upwp(1:nnx,iys:iye,izs-1:ize+1),nnx,nnz,mxs,
     +                mxe,mx_s,mx_e,iys,iye,izs,ize,iz_s,iz_e,myid,
     +                ncpu_s,numprocs)

      call ztox_trans(vpsum_t(0:nnz+1,iys:iye,mxs:mxe,1),
     +                vpsum(1:nnx,iys:iye,izs-1:ize+1,1),nnx,nnz,mxs,
     +                mxe,mx_s,mx_e,iys,iye,izs,ize,iz_s,iz_e,myid,
     +                ncpu_s,numprocs)
      call ztox_trans(vpsum_t(0:nnz+1,iys:iye,mxs:mxe,2),
     +                vpsum(1:nnx,iys:iye,izs-1:ize+1,2),nnx,nnz,mxs,
     +                mxe,mx_s,mx_e,iys,iye,izs,ize,iz_s,iz_e,myid,
     +                ncpu_s,numprocs)
      call ztox_trans(vpsum_t(0:nnz+1,iys:iye,mxs:mxe,3),
     +                vpsum(1:nnx,iys:iye,izs-1:ize+1,3),nnx,nnz,mxs,
     +                mxe,mx_s,mx_e,iys,iye,izs,ize,iz_s,iz_e,myid,
     +                ncpu_s,numprocs)

      call ztox_trans(vpsqrsum_t(0:nnz+1,iys:iye,mxs:mxe,1),
     +                vpsqrsum(1:nnx,iys:iye,izs-1:ize+1,1),nnx,nnz,mxs,
     +                mxe,mx_s,mx_e,iys,iye,izs,ize,iz_s,iz_e,myid,
     +                ncpu_s,numprocs)
      call ztox_trans(vpsqrsum_t(0:nnz+1,iys:iye,mxs:mxe,2),
     +                vpsqrsum(1:nnx,iys:iye,izs-1:ize+1,2),nnx,nnz,mxs,
     +                mxe,mx_s,mx_e,iys,iye,izs,ize,iz_s,iz_e,myid,
     +                ncpu_s,numprocs)
      call ztox_trans(vpsqrsum_t(0:nnz+1,iys:iye,mxs:mxe,3),
     +                vpsqrsum(1:nnx,iys:iye,izs-1:ize+1,3),nnx,nnz,mxs,
     +                mxe,mx_s,mx_e,iys,iye,izs,ize,iz_s,iz_e,myid,
     +                ncpu_s,numprocs)

      call ztox_trans(Tpsum_t(0:nnz+1,iys:iye,mxs:mxe),
     +                Tpsum(1:nnx,iys:iye,izs-1:ize+1),nnx,nnz,mxs,
     +                mxe,mx_s,mx_e,iys,iye,izs,ize,iz_s,iz_e,myid,
     +                ncpu_s,numprocs)
      call ztox_trans(Tpsqrsum_t(0:nnz+1,iys:iye,mxs:mxe),
     +                Tpsqrsum(1:nnx,iys:iye,izs-1:ize+1),nnx,nnz,mxs,
     +                mxe,mx_s,mx_e,iys,iye,izs,ize,iz_s,iz_e,myid,
     +                ncpu_s,numprocs)
      call ztox_trans(wpTpsum_t(0:nnz+1,iys:iye,mxs:mxe),
     +                wpTpsum(1:nnx,iys:iye,izs-1:ize+1),nnx,nnz,mxs,
     +                mxe,mx_s,mx_e,iys,iye,izs,ize,iz_s,iz_e,myid,
     +                ncpu_s,numprocs)

      call ztox_trans(partcount_t(0:nnz+1,iys:iye,mxs:mxe),
     +                partcount(1:nnx,iys:iye,izs-1:ize+1),nnx,nnz,mxs,
     +                mxe,mx_s,mx_e,iys,iye,izs,ize,iz_s,iz_e,myid,
     +                ncpu_s,numprocs)
      end if

      !t_s = mpi_wtime
      !Get particle count:
      numpart = 0
      part => first_particle
      do while (associated(part))
      numpart = numpart + 1
      part => part%next
      end do
      !call mpi_barrier(mpi_comm_world,ierr)
      !t_f = mpi_wtime()
      !if (myid==5) write(*,*) 'time numpart: ', t_f - t_s

      !t_s = mpi_wtime()
      !Compute total number of particles
      call mpi_allreduce(numpart,tnumpart,1,mpi_integer,mpi_sum,
     +                   mpi_comm_world,ierr)
      !Compute average particle Reynolds number
      call mpi_allreduce(myRep_avg,Rep_avg,1,mpi_real8,mpi_sum,
     +                   mpi_comm_world,ierr)
      Rep_avg = Rep_avg/tnumpart
      !call mpi_barrier(mpi_comm_world,ierr)
      !t_f = mpi_wtime()
      !if (myid==5) write(*,*) 'time mpi_allreduce: ', t_f - t_s

      end subroutine particle_update_rk3
      subroutine particle_bcs_nonperiodic
      use particles
      use con_data
      use pars
      implicit none
      real :: top,bot

      !Assumes domain goes from [0,xl),[0,yl),[0,zl]
      !Also maintain the number of particles on each proc

      num_reintro = 0
      part => first_particle
      do while (associated(part))

      !Remove particles which fall under the radius
      !Rebound particles which hit top

      top = zl - radius
      bot = 0.0 + radius

      if (part%xip(3) .GT. top) then
         part%xp(3) = top - (part%xp(3)-top)
         part%vp(3) = -part%vp(3)
         part => part%next
      elseif (part%xip(3) .LT. bot) then

         call destroy_particle
         num_reintro = num_reintro + 1

      else
         part => part%next
      end if

      end do

      end subroutine particle_bcs_nonperiodic
      subroutine particle_reintro(istage)
      use particles
      use pars
      use con_data
      use tank_pars
      implicit none
      include 'mpif.h'

      integer :: ierr,randproc,np,tmp_reintro,istage,ix
      real :: xv,yv,zv,ran2,vinj
      real :: xpart(nnx),y2part(nnx),yp1,ypn,ddx

      call mpi_allreduce(num_reintro,tmp_reintro,1,mpi_integer,mpi_sum,
     +       mpi_comm_world,ierr)

      if (myid==0) write(*,*) 'time,tot_reintro: ',time,tmp_reintro

      tot_reintro = tot_reintro + tmp_reintro

      !Set up xpart for interpolation of h:
      yp1 = 2.0e+30
      ypn = yp1
      ddx = xl/float(nnx)
      do ix=1,nnx
         xpart(ix) = float(ix-1)*ddx
      end do
      call spline(xpart,z_tank_i,nnx,yp1,ypn,y2part)

      !Now everyone knows how many total particles need to be reintroduced
      !For each one to be reintroduced, get a random processor who creates it:

      do np=1,tmp_reintro

      !Proc 0 gets a random proc ID, broadcasts it out:
      if (myid==0) randproc = floor(ran2(iseed)*numprocs)

      call mpi_bcast(randproc,1,mpi_integer,0,mpi_comm_world,ierr)

       if (myid==randproc) then

        xv = ran2(iseed)*(xmax-xmin) + xmin
        yv = ran2(iseed)*(ymax-ymin) + ymin

        !Inject the particles upwards:
        !get the initial vertical velocity:
        vinj = ran2(iseed)*Vpmax
        !vinj = Vpmax
        zv = 10.0*radius
        !zv = zw1
        call create_particle((/xv,yv,zv/),(/0.0,0.0,vinj/),300.0,2,
     +       z_tank_i(1:nnx),xpart(1:nnx),y2part(1:nnx))

       end if
      end do

      end subroutine particle_reintro
      subroutine particle_bcs_periodic
      use particles
      use con_data
      use pars
      implicit none 

      !Assumes domain goes from [0,xl),[0,yl),[0,zl] 
      !Also maintain the number of particles on each proc
      
      part => first_particle
      do while (associated(part))

      !x,y periodic
   
      if (part%xp(1) .GT. xl) then
         part%xp(1) = part%xp(1)-xl
      elseif (part%xp(1) .LT. 0) then
         part%xp(1) = xl + part%xp(1)
      end if

      if (part%xp(2) .GT. yl) then
         part%xp(2) = part%xp(2)-yl
      elseif (part%xp(2) .LT. 0) then
         part%xp(2) = yl + part%xp(2)
      end if

      part => part%next

      end do


      end subroutine particle_bcs_periodic
      subroutine particle_exchange
      use pars
      use particles
      use con_data
      use con_stats
      implicit none
      include 'mpif.h'

      type(particle), pointer :: tmp
      integer :: idx,psum,csum
      integer :: ir,itr,itop,itl,il,ibl,ib,ibr
      integer :: istatus(mpi_status_size),ierr
      integer :: status_array(mpi_status_size,16),req(16)
      type(particle), allocatable :: rbuf_s(:),trbuf_s(:)
      type(particle), allocatable :: tbuf_s(:),tlbuf_s(:)
      type(particle), allocatable :: lbuf_s(:),blbuf_s(:)
      type(particle), allocatable :: bbuf_s(:),brbuf_s(:)
      type(particle), allocatable :: rbuf_r(:),trbuf_r(:)
      type(particle), allocatable :: tbuf_r(:),tlbuf_r(:)
      type(particle), allocatable :: lbuf_r(:),blbuf_r(:)
      type(particle), allocatable :: bbuf_r(:),brbuf_r(:)
      type(particle), allocatable :: totalbuf(:)
      
      !Zero out the counters for how many particles to send each dir.
      pr_s=0;ptr_s=0;pt_s=0;ptl_s=0;pl_s=0;pbl_s=0;pb_s=0;pbr_s=0
      
      !As soon as the location is updated, must check to see if it left the proc:
      !May be a better way of doing this, but it seems most reasonable:
      part => first_particle
      do while (associated(part))     

         !First get numbers being sent to all sides:
         if (part%xp(2) .GT. ymax) then 
            if (part%xp(1) .GT. xmax) then !top right
               ptr_s = ptr_s + 1
            elseif (part%xp(1) .LT. xmin) then !bottom right
               pbr_s = pbr_s + 1
            else  !right
               pr_s = pr_s + 1
            end if
         elseif (part%xp(2) .LT. ymin) then
            if (part%xp(1) .GT. xmax) then !top left
               ptl_s = ptl_s + 1
            else if (part%xp(1) .LT. xmin) then !bottom left
               pbl_s = pbl_s + 1
            else  !left
               pl_s = pl_s + 1
            end if
         elseif ( (part%xp(1) .GT. xmax) .AND.
     +           (part%xp(2) .LT. ymax) .AND.
     +           (part%xp(2) .GT. ymin) ) then !top
            pt_s = pt_s + 1
         elseif ( (part%xp(1) .LT. xmin) .AND.
     +           (part%xp(2) .LT. ymax) .AND.
     +           (part%xp(2) .GT. ymin) ) then !bottom
            pb_s = pb_s + 1
         end if
         
         part => part%next
      end do
      
      !Now allocate the send buffers based on these counts:
      allocate(rbuf_s(pr_s),trbuf_s(ptr_s),tbuf_s(pt_s),tlbuf_s(ptl_s))
      allocate(lbuf_s(pl_s),blbuf_s(pbl_s),bbuf_s(pb_s),brbuf_s(pbr_s))

      !Now loop back through the particles and fill the buffers:
      !NOTE: If it finds one, add it to buffer and REMOVE from list
      ir=1;itr=1;itop=1;itl=1;il=1;ibl=1;ib=1;ibr=1

      part => first_particle
      do while (associated(part))
         
         if (part%xp(2) .GT. ymax) then 
            if (part%xp(1) .GT. xmax) then !top right
!               write(*,*) 'Proc',myid,'about to send part to 
!     +proc',trproc,'TOP RIGHT'
               trbuf_s(itr) = part
               call destroy_particle
               itr = itr + 1 
            elseif (part%xp(1) .LT. xmin) then !bottom right
!               write(*,*) 'Proc',myid,'about to send part to 
!     +proc',brproc,'BOTTOM RIGHT'
               brbuf_s(ibr) = part
               call destroy_particle
               ibr = ibr + 1
            else   !right
!               write(*,*) 'Proc',myid,'about to send part to 
!     +proc',rproc,'RIGHT'
               rbuf_s(ir) = part
               call destroy_particle
               ir = ir + 1
            end if
         elseif (part%xp(2) .LT. ymin) then
            if (part%xp(1) .GT. xmax) then !top left
!               write(*,*) 'Proc',myid,'about to send part to 
!     +proc',tlproc,'TOP LEFT'
               tlbuf_s(itl) = part
               call destroy_particle
               itl = itl + 1
            else if (part%xp(1) .LT. xmin) then !bottom left
!               write(*,*) 'Proc',myid,'about to send part to 
!     +proc',blproc,'BOTTOM LEFT'
               blbuf_s(ibl) = part
               call destroy_particle
               ibl = ibl + 1
            else  !left
!               write(*,*) 'Proc',myid,'about to send part to 
!     +proc',lproc,'LEFT'
               lbuf_s(il) = part
               call destroy_particle
               il = il + 1
            end if
         elseif ( (part%xp(1) .GT. xmax) .AND.
     +           (part%xp(2) .LT. ymax) .AND.
     +           (part%xp(2) .GT. ymin) ) then !top
!               write(*,*) 'Proc',myid,'about to send part to 
!     +proc',tproc,'TOP'
            tbuf_s(itop) = part
            call destroy_particle
            itop = itop + 1
         elseif ( (part%xp(1) .LT. xmin) .AND.
     +           (part%xp(2) .LT. ymax) .AND.
     +           (part%xp(2) .GT. ymin) ) then !bottom
!               write(*,*) 'Proc',myid,'about to send part to 
!     +proc',bproc,'BOTTOM'
            bbuf_s(ib) = part
            call destroy_particle
            ib = ib + 1 
         else
         part => part%next
         end if 
         
      end do

      !Now everyone exchanges the counts with all neighbors:
      !Left/right:
      call MPI_Sendrecv(pr_s,1,mpi_integer,rproc,3,
     +        pl_r,1,mpi_integer,lproc,3,mpi_comm_world,istatus,ierr)

      call MPI_Sendrecv(pl_s,1,mpi_integer,lproc,4,
     +        pr_r,1,mpi_integer,rproc,4,mpi_comm_world,istatus,ierr)

      !Top/bottom:
      call MPI_Sendrecv(pt_s,1,mpi_integer,tproc,5,
     +        pb_r,1,mpi_integer,bproc,5,mpi_comm_world,istatus,ierr)

      call MPI_Sendrecv(pb_s,1,mpi_integer,bproc,6,
     +        pt_r,1,mpi_integer,tproc,6,mpi_comm_world,istatus,ierr)

      !Top right/bottom left:
      call MPI_Sendrecv(ptr_s,1,mpi_integer,trproc,7,
     +        pbl_r,1,mpi_integer,blproc,7,
     +        mpi_comm_world,istatus,ierr)

      call MPI_Sendrecv(pbl_s,1,mpi_integer,blproc,8,
     +        ptr_r,1,mpi_integer,trproc,8,
     +        mpi_comm_world,istatus,ierr)

       !Top left/bottom right:
      call MPI_Sendrecv(ptl_s,1,mpi_integer,tlproc,9,
     +        pbr_r,1,mpi_integer,brproc,9,
     +        mpi_comm_world,istatus,ierr)

      call MPI_Sendrecv(pbr_s,1,mpi_integer,brproc,10,
     +         ptl_r,1,mpi_integer,tlproc,10,
     +         mpi_comm_world,istatus,ierr)

      !Now everyone has the number of particles arriving from every neighbor
      !If the count is greater than zero, exchange:

      !Allocate room to receive from each side
      allocate(rbuf_r(pr_r),trbuf_r(ptr_r),tbuf_r(pt_r),tlbuf_r(ptl_r))
      allocate(lbuf_r(pl_r),blbuf_r(pbl_r),bbuf_r(pb_r),brbuf_r(pbr_r))
     
      !Send to right:
      if (pr_s .GT. 0) then
      call mpi_isend(rbuf_s,pr_s,particletype,rproc,11,
     +               mpi_comm_world,req(1),ierr)
      else
      req(1) = mpi_request_null
      end if

      !Receive from left:
      if (pl_r .GT. 0) then
      call mpi_irecv(lbuf_r,pl_r,particletype,lproc,11,
     +               mpi_comm_world,req(2),ierr)
      else
      req(2) = mpi_request_null
      end if

      !Send to left:
      if (pl_s .GT. 0) then
      call mpi_isend(lbuf_s,pl_s,particletype,lproc,12,
     +               mpi_comm_world,req(3),ierr)
      else
      req(3) = mpi_request_null
      end if

      !Receive from right:
      if (pr_r .GT. 0) then
      call mpi_irecv(rbuf_r,pr_r,particletype,rproc,12,
     +               mpi_comm_world,req(4),ierr)
      else
      req(4) = mpi_request_null
      end if

      !Send to top:
      if (pt_s .GT. 0) then
      call mpi_isend(tbuf_s,pt_s,particletype,tproc,13,
     +                mpi_comm_world,req(5),ierr)
      else
      req(5) = mpi_request_null
      end if
      
      !Receive from bottom:
      if (pb_r .GT. 0) then
      call mpi_irecv(bbuf_r,pb_r,particletype,bproc,13,
     +                mpi_comm_world,req(6),ierr)
      else
      req(6) = mpi_request_null
      end if

      !Send to bottom:
      if (pb_s .GT. 0) then
      call mpi_isend(bbuf_s,pb_s,particletype,bproc,14,
     +                mpi_comm_world,req(7),ierr)
      else
      req(7) = mpi_request_null
      end if
      
      !Recieve from top:
      if (pt_r .GT. 0) then
      call mpi_irecv(tbuf_r,pt_r,particletype,tproc,14,
     +                mpi_comm_world,req(8),ierr)
      else
      req(8) = mpi_request_null
      end if

      !Send to top right:
      if (ptr_s .GT. 0) then
      call mpi_isend(trbuf_s,ptr_s,particletype,trproc,15,
     +                mpi_comm_world,req(9),ierr)
      else
      req(9) = mpi_request_null
      end if
     
      !Receive from bottom left:
      if (pbl_r .GT. 0) then
      call mpi_irecv(blbuf_r,pbl_r,particletype,blproc,15,
     +                mpi_comm_world,req(10),ierr)
      else 
      req(10) = mpi_request_null
      end if
    
      !Send to bottom left:
      if (pbl_s .GT. 0) then
      call mpi_isend(blbuf_s,pbl_s,particletype,blproc,16,
     +                mpi_comm_world,req(11),ierr)
      else
      req(11) = mpi_request_null
      end if
     
      !Receive from top right:
      if (ptr_r .GT. 0) then
      call mpi_irecv(trbuf_r,ptr_r,particletype,trproc,16,
     +                mpi_comm_world,req(12),ierr)
      else 
      req(12) = mpi_request_null
      end if

      !Send to top left:
      if (ptl_s .GT. 0) then
      call mpi_isend(tlbuf_s,ptl_s,particletype,tlproc,17,
     +                mpi_comm_world,req(13),ierr)
      else 
      req(13) = mpi_request_null
      end if
    
      !Receive from bottom right:
      if (pbr_r .GT. 0) then
      call mpi_irecv(brbuf_r,pbr_r,particletype,brproc,17,
     +                mpi_comm_world,req(14),ierr)
      else 
      req(14) = mpi_request_null
      end if
  
      !Send to bottom right:
      if (pbr_s .GT. 0) then
      call mpi_isend(brbuf_s,pbr_s,particletype,brproc,18,
     +                mpi_comm_world,req(15),ierr)
      else
      req(15) = mpi_request_null
      end if
  
      !Receive from top left:
      if (ptl_r .GT. 0) then
      call mpi_irecv(tlbuf_r,ptl_r,particletype,tlproc,18,
     +                mpi_comm_world,req(16),ierr)
      else
      req(16) = mpi_request_null
      end if

      call mpi_waitall(16,req,status_array,ierr)

      !Now add incoming particles to linked list:
      !NOTE: add them to beginning since it's easiest to access (first_particle)

      !Form one large buffer to loop through and add:
      psum = pr_r+ptr_r+pt_r+ptl_r+pl_r+pbl_r+pb_r+pbr_r
      csum = 0
      allocate(totalbuf(psum))
      if (pr_r .GT. 0) then 
         totalbuf(1:pr_r) = rbuf_r(1:pr_r)
         csum = csum + pr_r 
      end if
      if (ptr_r .GT. 0) then 
         totalbuf(csum+1:csum+ptr_r) = trbuf_r(1:ptr_r)
         csum = csum + ptr_r
      end if
      if (pt_r .GT. 0) then 
         totalbuf(csum+1:csum+pt_r) = tbuf_r(1:pt_r)
         csum = csum + pt_r
      end if
      if (ptl_r .GT. 0) then 
         totalbuf(csum+1:csum+ptl_r) = tlbuf_r(1:ptl_r)
         csum = csum + ptl_r
      end if
      if (pl_r .GT. 0) then 
         totalbuf(csum+1:csum+pl_r) = lbuf_r(1:pl_r)
         csum = csum + pl_r
      end if
      if (pbl_r .GT. 0) then 
         totalbuf(csum+1:csum+pbl_r) = blbuf_r(1:pbl_r)
         csum = csum + pbl_r
      end if
      if (pb_r .GT. 0) then 
         totalbuf(csum+1:csum+pb_r) = bbuf_r(1:pb_r)
         csum = csum + pb_r
      end if
      if (pbr_r .GT. 0) then 
         totalbuf(csum+1:csum+pbr_r) = brbuf_r(1:pbr_r)
         csum = csum + pbr_r
      end if

      do idx = 1,psum
        if (.NOT. associated(first_particle)) then
           allocate(first_particle)
           first_particle = totalbuf(idx)
           nullify(first_particle%next,first_particle%prev)
        else
           allocate(first_particle%prev)
           tmp => first_particle%prev
           tmp = totalbuf(idx)
           tmp%next => first_particle
           nullify(tmp%prev)
           first_particle => tmp
           nullify(tmp)
        end if
      end do  
      
      deallocate(rbuf_s,trbuf_s,tbuf_s,tlbuf_s)
      deallocate(lbuf_s,blbuf_s,bbuf_s,brbuf_s)
      deallocate(rbuf_r,trbuf_r,tbuf_r,tlbuf_r)
      deallocate(lbuf_r,blbuf_r,bbuf_r,brbuf_r)
      deallocate(totalbuf)

      end subroutine particle_exchange
      subroutine destroy_particle
      use particles
      implicit none

      type(particle), pointer :: tmp

      !Is it the first and last in the list?
      if (associated(part,first_particle) .AND. 
     +    (.NOT. associated(part%next)) ) then
          nullify(first_particle)
          deallocate(part)
      else
        if (associated(part,first_particle)) then !Is it the first particle?
           first_particle => part%next
           part => first_particle
           deallocate(part%prev)
        elseif (.NOT. associated(part%next)) then !Is it the last particle?
           nullify(part%prev%next)
           deallocate(part)
        else
           tmp => part
           part => part%next
           tmp%prev%next => tmp%next
           tmp%next%prev => tmp%prev
           deallocate(tmp)
        end if
      end if
   
      end subroutine destroy_particle

      subroutine fill_ext 
      use pars
      use particles
      use fields
      use con_stats
      use con_data
      implicit none
      include 'mpif.h'

      integer :: istatus(mpi_status_size),ierr
      integer :: ix,iy,iz
      !preceding letter: r=right,l=left,t=top,b=bot.
      !_s: buf of things to send TO r,l,t,b
      !_r: buf of things to recv FROM r,l,t,b 
      real :: tbuf_s(nnz+2,iye-iys+1,2,4),tbuf_r(nnz+2,iye-iys+1,3,4)
      real :: bbuf_s(nnz+2,iye-iys+1,3,4),bbuf_r(nnz+2,iye-iys+1,2,4)
      real :: rbuf_s(nnz+2,2,mxe-mxs+1,4),rbuf_r(nnz+2,3,mxe-mxs+1,4)
      real :: lbuf_s(nnz+2,3,mxe-mxs+1,4),lbuf_r(nnz+2,2,mxe-mxs+1,4)

      !Corners:
      real :: trbuf_s(nnz+2,2,2,4),trbuf_r(nnz+2,3,3,4)
      real :: brbuf_s(nnz+2,2,3,4),brbuf_r(nnz+2,3,2,4)
      real :: blbuf_s(nnz+2,3,3,4),blbuf_r(nnz+2,2,2,4)
      real :: tlbuf_s(nnz+2,3,2,4),tlbuf_r(nnx+2,2,3,4)
      !MPI send counts:
      integer :: rc_s,rc_r,trc_s,trc_r,tc_s,tc_r,tlc_s,tlc_r
      integer :: lc_s,lc_r,blc_s,blc_r,bc_s,bc_r,brc_s,brc_r

      !Debugging:
      real :: xv,yv,zv
 
      !To update the particle ODE in time, need the interpolated
      !velocity field
      !This requires filling uext,vext,wext from nearby procs
      uext = 0.0
      vext = 0.0
      wext = 0.0
      Text = 0.0

      !First fill the center, since this is just u,v,w on that proc:

      !In the column setup, need to tranpose u,v,w first into u_t,v_t,w_t:
      call xtoz_trans(u(1:nnx,iys:iye,izs-1:ize+1),u_t,nnx,nnz,
     +                mxs,mxe,mx_s,mx_e,iys,iye,izs,ize,iz_s,iz_e,
     +                myid,ncpu_s,numprocs)
      call xtoz_trans(v(1:nnx,iys:iye,izs-1:ize+1),v_t,nnx,nnz,
     +                mxs,mxe,mx_s,mx_e,iys,iye,izs,ize,iz_s,iz_e,
     +                myid,ncpu_s,numprocs)
      call xtoz_trans(w(1:nnx,iys:iye,izs-1:ize+1),w_t,nnx,nnz,
     +                mxs,mxe,mx_s,mx_e,iys,iye,izs,ize,iz_s,iz_e,
     +                myid,ncpu_s,numprocs)
      call xtoz_trans(t(1:nnx,iys:iye,1,izs-1:ize+1),T_t,nnx,nnz,
     +                mxs,mxe,mx_s,mx_e,iys,iye,izs,ize,iz_s,iz_e,
     +                myid,ncpu_s,numprocs)

      uext(0:nnz+1,iys:iye,mxs:mxe) = u_t(0:nnz+1,iys:iye,mxs:mxe)
      vext(0:nnz+1,iys:iye,mxs:mxe) = v_t(0:nnz+1,iys:iye,mxs:mxe)
      wext(0:nnz+1,iys:iye,mxs:mxe) = w_t(0:nnz+1,iys:iye,mxs:mxe)
      Text(0:nnz+1,iys:iye,mxs:mxe) = T_t(0:nnz+1,iys:iye,mxs:mxe)

      !Recall that SR assign_nbrs assigned rproc,lproc, etc.

      !Going to call 6 sendrecv calls - one for each proc. nbr.:
      
      !Fill the send buffers:
      
      !I know these are redundant, but so I can keep them straight...
      tc_s = 4*(nnz+2)*2*(iye-iys+1)
      tc_r = 4*(nnz+2)*3*(iye-iys+1)
      trc_s = 4*(nnz+2)*2*2
      trc_r = 4*(nnz+2)*3*3
      rc_s = 4*(nnz+2)*(mxe-mxs+1)*2
      rc_r = 4*(nnx+2)*(mxe-mxs+1)*3
      tlc_s = 4*(nnz+2)*3*2
      tlc_r = 4*(nnz+2)*2*3
      bc_s = 4*(nnz+2)*3*(iye-iys+1)
      bc_r = 4*(nnz+2)*2*(iye-iys+1)
      blc_s = 4*(nnz+2)*3*3
      blc_r = 4*(nnz+2)*2*2
      lc_s = 4*(nnz+2)*(mxe-mxs+1)*3
      lc_r = 4*(nnz+2)*(mxe-mxs+1)*2
      brc_s = 4*(nnz+2)*2*3
      brc_r = 4*(nnz+2)*3*2
     
      !First u:
      tbuf_s(1:nnz+2,1:iye-iys+1,1:2,1) = u_t(0:nnz+1,iys:iye,mxe-1:mxe)
      trbuf_s(1:nnz+2,1:2,1:2,1) = u_t(0:nnz+1,iye-1:iye,mxe-1:mxe)
      rbuf_s(1:nnz+2,1:2,1:mxe-mxs+1,1) = u_t(0:nnz+1,iye-1:iye,mxs:mxe)
      brbuf_s(1:nnz+2,1:2,1:3,1) = u_t(0:nnz+1,iye-1:iye,mxs:mxs+2)
      bbuf_s(1:nnz+2,1:iye-iys+1,1:3,1) = u_t(0:nnz+1,iys:iye,mxs:mxs+2)
      blbuf_s(1:nnz+2,1:3,1:3,1) = u_t(0:nnz+1,iys:iys+2,mxs:mxs+2)
      lbuf_s(1:nnz+2,1:3,1:mxe-mxs+1,1) = u_t(0:nnz+1,iys:iys+2,mxs:mxe)
      tlbuf_s(1:nnz+2,1:3,1:2,1) = u_t(0:nnz+1,iys:iys+2,mxe-1:mxe)

      !v:
      tbuf_s(1:nnz+2,1:iye-iys+1,1:2,2) = v_t(0:nnz+1,iys:iye,mxe-1:mxe)
      trbuf_s(1:nnz+2,1:2,1:2,2) = v_t(0:nnz+1,iye-1:iye,mxe-1:mxe)
      rbuf_s(1:nnz+2,1:2,1:mxe-mxs+1,2) = v_t(0:nnz+1,iye-1:iye,mxs:mxe)
      brbuf_s(1:nnz+2,1:2,1:3,2) = v_t(0:nnz+1,iye-1:iye,mxs:mxs+2)
      bbuf_s(1:nnz+2,1:iye-iys+1,1:3,2) = v_t(0:nnz+1,iys:iye,mxs:mxs+2)
      blbuf_s(1:nnz+2,1:3,1:3,2) = v_t(0:nnz+1,iys:iys+2,mxs:mxs+2)
      lbuf_s(1:nnz+2,1:3,1:mxe-mxs+1,2) = v_t(0:nnz+1,iys:iys+2,mxs:mxe)
      tlbuf_s(1:nnz+2,1:3,1:2,2) = v_t(0:nnz+1,iys:iys+2,mxe-1:mxe)

      !w:
      tbuf_s(1:nnz+2,1:iye-iys+1,1:2,3) = w_t(0:nnz+1,iys:iye,mxe-1:mxe)
      trbuf_s(1:nnz+2,1:2,1:2,3) = w_t(0:nnz+1,iye-1:iye,mxe-1:mxe)
      rbuf_s(1:nnz+2,1:2,1:mxe-mxs+1,3) = w_t(0:nnz+1,iye-1:iye,mxs:mxe)
      brbuf_s(1:nnz+2,1:2,1:3,3) = w_t(0:nnz+1,iye-1:iye,mxs:mxs+2)
      bbuf_s(1:nnz+2,1:iye-iys+1,1:3,3) = w_t(0:nnz+1,iys:iye,mxs:mxs+2)
      blbuf_s(1:nnz+2,1:3,1:3,3) = w_t(0:nnz+1,iys:iys+2,mxs:mxs+2)
      lbuf_s(1:nnz+2,1:3,1:mxe-mxs+1,3) = w_t(0:nnz+1,iys:iys+2,mxs:mxe)
      tlbuf_s(1:nnz+2,1:3,1:2,3) = w_t(0:nnz+1,iys:iys+2,mxe-1:mxe)

      !T:
      tbuf_s(1:nnz+2,1:iye-iys+1,1:2,4) = T_t(0:nnz+1,iys:iye,mxe-1:mxe)
      trbuf_s(1:nnz+2,1:2,1:2,4) = T_t(0:nnz+1,iye-1:iye,mxe-1:mxe)
      rbuf_s(1:nnz+2,1:2,1:mxe-mxs+1,4) = T_t(0:nnz+1,iye-1:iye,mxs:mxe)
      brbuf_s(1:nnz+2,1:2,1:3,4) = T_t(0:nnz+1,iye-1:iye,mxs:mxs+2)
      bbuf_s(1:nnz+2,1:iye-iys+1,1:3,4) = T_t(0:nnz+1,iys:iye,mxs:mxs+2)
      blbuf_s(1:nnz+2,1:3,1:3,4) = T_t(0:nnz+1,iys:iys+2,mxs:mxs+2)
      lbuf_s(1:nnz+2,1:3,1:mxe-mxs+1,4) = T_t(0:nnz+1,iys:iys+2,mxs:mxe)
      tlbuf_s(1:nnz+2,1:3,1:2,4) = T_t(0:nnz+1,iys:iys+2,mxe-1:mxe)
     
      !Zero out recieve buffers 
      rbuf_r=0.0;trbuf_r=0.0;tbuf_r=0.0;tlbuf_r=0.0;lbuf_r=0.0
      blbuf_r=0.0;bbuf_r=0.0;brbuf_r=0.0

      !Left/right:
      call MPI_Sendrecv(rbuf_s,rc_s,mpi_real8,rproc,3,
     +        lbuf_r,lc_r,mpi_real8,lproc,3,mpi_comm_world,istatus,ierr)

      call mpi_barrier(mpi_comm_world,ierr)
      call MPI_Sendrecv(lbuf_s,lc_s,mpi_real8,lproc,4,
     +        rbuf_r,rc_r,mpi_real8,rproc,4,mpi_comm_world,istatus,ierr)

      !Top/bottom:
      call MPI_Sendrecv(tbuf_s,tc_s,mpi_real8,tproc,5,
     +        bbuf_r,bc_r,mpi_real8,bproc,5,mpi_comm_world,istatus,ierr)

      call MPI_Sendrecv(bbuf_s,bc_s,mpi_real8,bproc,6,
     +        tbuf_r,tc_r,mpi_real8,tproc,6,mpi_comm_world,istatus,ierr)

      !Top right/bottom left:
      call MPI_Sendrecv(trbuf_s,trc_s,mpi_real8,trproc,7,
     +        blbuf_r,blc_r,mpi_real8,blproc,7,
     +        mpi_comm_world,istatus,ierr)

      call MPI_Sendrecv(blbuf_s,blc_s,mpi_real8,blproc,8,
     +        trbuf_r,trc_r,mpi_real8,trproc,8,
     +        mpi_comm_world,istatus,ierr)

       !Top left/bottom right:
      call MPI_Sendrecv(tlbuf_s,tlc_s,mpi_real8,tlproc,9,
     +        brbuf_r,brc_r,mpi_real8,brproc,9,
     +        mpi_comm_world,istatus,ierr)

      call MPI_Sendrecv(brbuf_s,brc_s,mpi_real8,brproc,10,
     +         tlbuf_r,tlc_r,mpi_real8,tlproc,10,
     +         mpi_comm_world,istatus,ierr)

      !Now fill the ext arrays with the recieved buffers:
      uext(0:nnz+1,iys:iye,mxe+1:mxe+3) = 
     +     tbuf_r(1:nnz+2,1:iye-iys+1,1:3,1)
      uext(0:nnz+1,iye+1:iye+3,mxe+1:mxe+3) = trbuf_r(1:nnz+2,1:3,1:3,1)
      uext(0:nnz+1,iye+1:iye+3,mxs:mxe) =
     +     rbuf_r(1:nnz+2,1:3,1:mxe-mxs+1,1)
      uext(0:nnz+1,iye+1:iye+3,mxs-2:mxs-1) = brbuf_r(1:nnz+2,1:3,1:2,1)
      uext(0:nnz+1,iys:iye,mxs-2:mxs-1) = 
     +     bbuf_r(1:nnz+2,1:iye-iys+1,1:2,1)
      uext(0:nnz+1,iys-2:iys-1,mxs-2:mxs-1) = blbuf_r(1:nnz+2,1:2,1:2,1)
      uext(0:nnz+1,iys-2:iys-1,mxs:mxe) =
     +     lbuf_r(1:nnz+2,1:2,1:mxe-mxs+1,1)
      uext(0:nnz+1,iys-2:iys-1,mxe+1:mxe+3) = tlbuf_r(1:nnz+2,1:2,1:3,1)
 
      vext(0:nnz+1,iys:iye,mxe+1:mxe+3) = 
     +     tbuf_r(1:nnz+2,1:iye-iys+1,1:3,2)
      vext(0:nnz+1,iye+1:iye+3,mxe+1:mxe+3) = trbuf_r(1:nnz+2,1:3,1:3,2)
      vext(0:nnz+1,iye+1:iye+3,mxs:mxe) =
     +     rbuf_r(1:nnz+2,1:3,1:mxe-mxs+1,2)
      vext(0:nnz+1,iye+1:iye+3,mxs-2:mxs-1) = brbuf_r(1:nnz+2,1:3,1:2,2)
      vext(0:nnz+1,iys:iye,mxs-2:mxs-1) = 
     +     bbuf_r(1:nnz+2,1:iye-iys+1,1:2,2)
      vext(0:nnz+1,iys-2:iys-1,mxs-2:mxs-1) = blbuf_r(1:nnz+2,1:2,1:2,2)
      vext(0:nnz+1,iys-2:iys-1,mxs:mxe) =
     +     lbuf_r(1:nnz+2,1:2,1:mxe-mxs+1,2)
      vext(0:nnz+1,iys-2:iys-1,mxe+1:mxe+3) = tlbuf_r(1:nnz+2,1:2,1:3,2)

      wext(0:nnz+1,iys:iye,mxe+1:mxe+3) = 
     +     tbuf_r(1:nnz+2,1:iye-iys+1,1:3,3)
      wext(0:nnz+1,iye+1:iye+3,mxe+1:mxe+3) = trbuf_r(1:nnz+2,1:3,1:3,3)
      wext(0:nnz+1,iye+1:iye+3,mxs:mxe) =
     +     rbuf_r(1:nnz+2,1:3,1:mxe-mxs+1,3)
      wext(0:nnz+1,iye+1:iye+3,mxs-2:mxs-1) = brbuf_r(1:nnz+2,1:3,1:2,3)
      wext(0:nnz+1,iys:iye,mxs-2:mxs-1) = 
     +     bbuf_r(1:nnz+2,1:iye-iys+1,1:2,3)
      wext(0:nnz+1,iys-2:iys-1,mxs-2:mxs-1) = blbuf_r(1:nnz+2,1:2,1:2,3)
      wext(0:nnz+1,iys-2:iys-1,mxs:mxe) =
     +     lbuf_r(1:nnz+2,1:2,1:mxe-mxs+1,3)
      wext(0:nnz+1,iys-2:iys-1,mxe+1:mxe+3) = tlbuf_r(1:nnz+2,1:2,1:3,3)

      Text(0:nnz+1,iys:iye,mxe+1:mxe+3) = 
     +     tbuf_r(1:nnz+2,1:iye-iys+1,1:3,4)
      Text(0:nnz+1,iye+1:iye+3,mxe+1:mxe+3) = trbuf_r(1:nnz+2,1:3,1:3,4)
      Text(0:nnz+1,iye+1:iye+3,mxs:mxe) =
     +     rbuf_r(1:nnz+2,1:3,1:mxe-mxs+1,4)
      Text(0:nnz+1,iye+1:iye+3,mxs-2:mxs-1) = brbuf_r(1:nnz+2,1:3,1:2,4)
      Text(0:nnz+1,iys:iye,mxs-2:mxs-1) = 
     +     bbuf_r(1:nnz+2,1:iye-iys+1,1:2,4)
      Text(0:nnz+1,iys-2:iys-1,mxs-2:mxs-1) = blbuf_r(1:nnz+2,1:2,1:2,4)
      Text(0:nnz+1,iys-2:iys-1,mxs:mxe) =
     +     lbuf_r(1:nnz+2,1:2,1:mxe-mxs+1,4)
      Text(0:nnz+1,iys-2:iys-1,mxe+1:mxe+3) = tlbuf_r(1:nnz+2,1:2,1:3,4)


      end subroutine fill_ext
      subroutine get_zeta_algeb(alpha,L,h,xip)
      implicit none

      real :: f,fp,h,alpha,tol,err,zeta,zetanew,L,z
      real, intent(inout) :: xip(1:3)

      err = 1.0
      z = xip(3)
      zeta = z
      do while (err .gt. 1e-10)
        f = zeta + h*(1.0 - zeta/L)**alpha - z
        fp = 1 - alpha*h/L*(1.0 - zeta/L)**(alpha-1.0)

        zetanew = zeta - f/fp
        err = abs(zeta-zetanew)/zeta
        zeta = zetanew
      end do
      xip(3) = zeta 

      end subroutine get_zeta_algeb
      subroutine uf_interp(hpart)
      use pars
      use particles
      use fields
      use con_stats
      use con_data
      implicit none
       
      integer :: ix,iy,izuv,izw,iz,i,k,j
      integer :: first,last
      real :: xkval,xjval,pj,dxvec(2)
      integer :: ijpts(2,6),kuvpts(6)
      real :: wt(3,6)
      real :: ran2,hpart
      
      !Interpolates to get the fluid velocity 
      !NOTE: interpolating in COMPUTATIONAL space! 
      !part%xp is in physical space - first must figure out where in 
      !computational space that lies and put into part%xip! 
      !then interpolate velocity to that position:

      !Newton's method to back out the computational location (xi,eta,zeta)
      !into part%xip given h at that location:

      part%xip(1:3) = part%xp(1:3)
      if (iz_space == 5) then    !Algebraic stretching to smooth out waves
          call get_zeta_algeb(a_decay,zl,hpart,part%xip(1:3))
      end if

      !Following Orlando's code, get the "leftmost" node
      !This is just the minimum (i,j,k) on the volume 

      ijpts(1,3) = floor(part%xip(1)/dx) + 1 
      ijpts(2,3) = floor(part%xip(2)/dy) + 1

      if (ijpts(1,3) .le. 0)  then
      write(*,*) 'PROB:',part%xip(1),part%xip(2),part%xip(3)
      end if
     
      !Fill in the neighbors:
      ijpts(1,2) = ijpts(1,3)-1
      ijpts(1,1) = ijpts(1,2)-1
      ijpts(1,4) = ijpts(1,3)+1
      ijpts(1,5) = ijpts(1,4)+1
      ijpts(1,6) = ijpts(1,5)+1

      ijpts(2,2) = ijpts(2,3)-1
      ijpts(2,1) = ijpts(2,2)-1
      ijpts(2,4) = ijpts(2,3)+1
      ijpts(2,5) = ijpts(2,4)+1
      ijpts(2,6) = ijpts(2,5)+1
     
      !Finding the k-lhnode is different since grid may be stretched
      
      !Do (u,v) loop first:
      do iz=0,nnz+1
         if (zz(iz) .GT. part%xip(3)) go to 1199
      end do
1199  continue

      kuvpts(3) = iz-1
      !Then fill in the rest:
      kuvpts(4) = kuvpts(3)+1
      kuvpts(5) = kuvpts(4)+1
      kuvpts(6) = kuvpts(5)+1
      kuvpts(2) = kuvpts(3)-1
      kuvpts(1) = kuvpts(2)-1


!---------
!      !As an aside, use ijpts,kuvpts to update the particle numbers at
!      each cell:
!
!      !call inputs  are the nodes associated with the volume that each
!      part. lies in
      call particle_stats(ijpts(1,3),ijpts(2,3),kuvpts(3))
!   
!---------


      !Fill in the weights:
      !First for x and y since they are periodic:
      wt(1:3,1:6) = 0.0
      dxvec(1) = dx
      dxvec(2) = dy
      do iz = 1,2
      do j = 1,6
         xjval = dxvec(iz)*(ijpts(iz,j)-1)
         pj = 1.0
         do k = 1,6
            xkval = dxvec(iz)*(ijpts(iz,k)-1)
            if (j .NE. k) then
                  pj = pj*(part%xip(iz)-xkval)/(xjval-xkval)
            end if
         end do
         wt(iz,j) = pj
       end do
       end do

       !Now compute weights in z-dir
       !There are 2 sections: weights at (u,v) nodes (kuvpts) 
       !And weights computed at w nodes (kwpts)

       !Compute weights at kuvpts
       !Must check to see how close we are to a top/bot boundary
       if (kuvpts(3) == 1) then
          first = 3
          last = 4
          !Set these equal to 1 so uext(-1) won't be accessed
          !Note: the value doesn't matter since weight will be 0
          kuvpts(1) = 1
          kuvpts(2) = 1
       elseif (kuvpts(3) == 0) then
          first = 4
          last = 5
          kuvpts(1) = 1
          kuvpts(2) = 1
          kuvpts(3) = 1
       elseif (kuvpts(3) .LT. 0) then 
          first = 0
          last = 0
       elseif (kuvpts(3) == 2) then 
          first = 2
          last = 5
       !Between top cell center and the domain boundary
       elseif (kuvpts(3) == nnz) then
          first = 2
          last = 3
          kuvpts(4) = nnz
          kuvpts(5) = nnz
          kuvpts(6) = nnz
       elseif (kuvpts(3) .GT. nnz) then
          first = 0
          last = 0
       !Between 2nd to last and last cell center at top
       elseif (kuvpts(3) == nnz-1) then
          first = 3
          last = 4
          kuvpts(5) = nnz
          kuvpts(6) = nnz
       elseif (kuvpts(3) == nnz-2) then
          first = 2
          last = 5
       else
          first = 1
          last = 6
       end if

       !Recall that wt has been set to zero, so
       !weights will be zero if (first,last) isn't (1,6)
       do j = first,last
           xjval = zz(kuvpts(j))
           pj = 1.0
           do k = first,last
              xkval = zz(kuvpts(k))
              if (j .NE. k) then
                 pj = pj*(part%xip(3)-xkval)/(xjval-xkval)
              end if
           end do
           wt(3,j) = pj
      end do

      !Now we have the weights - compute the velocity at xp:
        part%uf(1:3) = 0.0
        part%Tf = 0.0
        do k = 1,6
        do j = 1,6
        do i = 1,6
            ix = ijpts(1,i)
            iy = ijpts(2,j)
            izuv = kuvpts(k)
            part%uf(1) = part%uf(1)+uext(izuv,iy,ix)*wt(1,i)*
     +                   wt(2,j)*wt(3,k) 
            part%uf(2) = part%uf(2)+vext(izuv,iy,ix)*wt(1,i)*
     +                   wt(2,j)*wt(3,k) 
            part%uf(3) = part%uf(3)+wext(izuv,iy,ix)*wt(1,i)*
     +                   wt(2,j)*wt(3,k) 
            part%Tf = part%Tf+Text(izuv,iy,ix)*wt(1,i)*
     +                   wt(2,j)*wt(3,k) 
         end do
         end do 
         end do


      end subroutine uf_interp 

      subroutine particle_stats(ipt,jpt,kpt)
      use particles
      use pars
      use con_data
      implicit none
      integer :: i,ipt,jpt,kpt
      real :: partmass

      !Takes in ipt,jpt,kpt as the node to the "bottom left" of the
      !particle
      !(i.e. the node in the negative direction for x,y,z)
      !and computes quantities needed to get particle statistics

      !partcount_t(kpt,jpt,ipt) = partcount_t(kpt,jpt,ipt) + 1.0

      partmass = rhop*2.0/3.0*pi2*(radius)**3
      partcount_t(kpt,jpt,ipt) = partcount_t(kpt,jpt,ipt) + partmass  !PARTICLE AVERAGES ARE MASS-WEIGHTED

      !Get su mean, mean-squared of particle velocities at each level
      upwp_t(kpt,jpt,ipt) = upwp_t(kpt,jpt,ipt) +
     +                      partmass*part%vp(1)*part%vp(3)
      do i = 1,3
      vpsum_t(kpt,jpt,ipt,i) = vpsum_t(kpt,jpt,ipt,i) +
     +                         part%vp(i)*partmass
      vpsqrsum_t(kpt,jpt,ipt,i)=vpsqrsum_t(kpt,jpt,ipt,i)+
     +                          partmass*part%vp(i)**2
      end do

      Tpsum_t(kpt,jpt,ipt) = Tpsum_t(kpt,jpt,ipt) +
     +                       partmass*part%Tp
      Tpsqrsum_t(kpt,jpt,ipt) = Tpsqrsum_t(kpt,jpt,ipt) +
     +                          partmass*part%Tp**2
      wpTpsum_t(kpt,jpt,ipt) = wpTpsum_t(kpt,jpt,ipt) +
     +                          partmass*part%Tp*part%vp(3)

      end subroutine particle_stats


      function ran2(idum)
      integer :: idum,IM1,IM2,IMM1,IA1,IA2,IQ1,IQ2,IR1,IR2,NTAB,NDIV
      real :: ran2,AM,EPS,RNMX
      PARAMETER (IM1=2147483563,IM2=2147483399,AM=1./IM1,IMM1=IM1-1,
     +     IA1=40014,IA2=40692,IQ1=53668,IQ2=52774,IR1=12211,
     +     IR2=3791,NTAB=32,NDIV=1+IMM1/NTAB,EPS=1.2e-7,RNMX=1.-EPS)
      INTEGER :: idum2,j,k,iv(NTAB),iy
      SAVE iv,iy,idum2
      DATA idum2/123456789/,iv/NTAB*0/,iy/0/

      if (idum .le. 0) then
          idum=max(-idum,1)
          idum2 = idum
          do j = NTAB+8,1,-1
             k=idum/IQ1
             idum=IA1*(idum-k*IQ1)-k*IR1
             if (idum .lt. 0) idum=idum+IM1
             if (j .le. NTAB) iv(j) = idum
          end do
          iy=iv(1)
      end if
      k=idum/IQ1
      idum=IA1*(idum-k*IQ1)-k*IR1
      if (idum .lt. 0) idum=idum+IM1
      k=idum2/IQ2
      idum2=IA2*(idum2-k*IQ2)-k*IR2
      if (idum2 .lt. 0) idum2=idum2+IM2
      j = 1+iy/NDIV
      iy = iv(j) - idum2
      iv(j) = idum
      if (iy .lt. 1) iy = iy+IMM1
      ran2=min(AM*iy,RNMX)
      return
      end function ran2

      subroutine read_input_file
      use pars
      use particles
      use con_data
      implicit none

      character(48) :: label
      character(180) :: params_dir
      namelist /step_params/ iti,itmax,imean,ihst,itape,
     +                       itstr,it_his,it_viz,iviz,itn

      namelist /grid_params/ ncpu_s, Uo, Ttop, Tbot,
     +         qstar, tsfcc, ugcont, vgcont,
     +         zi, zl, xl, yl, zw1, dpdx_con,
     +         zo

      namelist /path_names/ path_seed,path_part,path_res,
     +         path_ran

      namelist /flags/ iradup,ifilt,itcut,isubs,ibrcl,iocean,idebug,
     +         ivis0,new_vis,ismlt,ifree,iupwnd,iskew,ibuoy,ifix_dt,
     +         i_move_step,method,iz_space,iflat,i3d_surf,i_pm,lpbc,
     +         k_stab,no_pgrad,ispray,iDNS,ifields

      namelist /constants/ grav, t00, fcor, tnumpart,
     +         radius,rhop,part_grav,Vpmax,muf,CpaCpp,Pra,
     +         vp_init,Tp_init


      !params.in contains namelists to read
      !open(12, file="./params.in", status="old")
      call get_command_argument(1,params_dir)
      open(12,file=params_dir,status="old")

      read(12,nml=step_params)
      if (myid==0) print step_params

      read(12,nml=flags)
      if (myid==0) print flags

      read(12,nml=grid_params)
      if (myid==0) print grid_params

      read(12,nml=path_names)
      if (myid==0) print path_names

      read(12,nml=constants)
      if (myid==0) print constants



      end subroutine read_input_file
